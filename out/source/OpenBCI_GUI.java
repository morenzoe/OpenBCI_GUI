/* autogenerated by Processing revision 1292 on 2023-07-18 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import edu.ucsd.sccn.*;

import ddf.minim.*;
import ddf.minim.ugens.*;
import java.lang.Math;
import processing.core.*;
import processing.data.*;
import java.util.*;
import processing.serial.*;
import java.awt.event.*;
import processing.net.*;
import grafica.*;
import gifAnimation.*;
import java.lang.reflect.*;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.FileNotFoundException;
import java.awt.MouseInfo;
import java.lang.Process;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.Random;
import java.awt.Robot;
import java.awt.AWTException;
import netP5.*;
import oscP5.*;
import hypermedia.net.*;
import java.nio.ByteBuffer;
import edu.ucsd.sccn.LSL;
import com.fazecast.jSerialComm.*;
import org.apache.commons.lang3.time.StopWatch;
import http.requests.*;
import java.util.concurrent.atomic.AtomicBoolean;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import java.io.*;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.lang3.tuple.Pair;
import brainflow.*;
import org.apache.commons.lang3.tuple.Pair;
import brainflow.*;
import org.apache.commons.lang3.tuple.Pair;
import brainflow.*;
import java.util.*;
import org.apache.commons.lang3.SystemUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.lang3.tuple.ImmutablePair;
import brainflow.*;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.lang3.tuple.ImmutablePair;
import java.lang.Math;
import java.io.PrintStream;
import java.io.FileOutputStream;
import java.awt.datatransfer.*;
import java.awt.Toolkit;
import java.awt.Desktop;
import controlP5.*;
import openbci_gui_helpers.*;
import java.io.IOException;
import java.util.List;
import openbci_gui_helpers.GanglionError;
import com.vmichalak.protocol.ssdp.Device;
import com.vmichalak.protocol.ssdp.SSDPClient;
import java.text.NumberFormat;
import ddf.minim.analysis.*;
import brainflow.DataFilter;
import brainflow.FilterTypes;
import java.io.StringWriter;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.prefs.Preferences;
import static java.lang.System.setErr;
import static java.util.prefs.Preferences.systemRoot;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.awt.Frame;
import processing.awt.PSurfaceAWT;
import java.util.Stack;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.ClipboardOwner;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import java.io.*;
import java.util.regex.*;
import java.util.List;
import java.awt.Frame;
import processing.awt.PSurfaceAWT;
import java.util.LinkedList;
import java.util.ListIterator;
import java.awt.Desktop;
import java.net.*;
import java.nio.file.*;
import java.util.concurrent.*;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.tuple.Pair;
import brainflow.BoardIds;
import brainflow.BoardShim;
import brainflow.BrainFlowClassifiers;
import brainflow.BrainFlowInputParams;
import brainflow.BrainFlowMetrics;
import brainflow.BrainFlowModelParams;
import brainflow.DataFilter;
import brainflow.LogLevels;
import brainflow.MLModel;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.tuple.Pair;
import brainflow.BoardIds;
import brainflow.BoardShim;
import brainflow.BrainFlowClassifiers;
import brainflow.BrainFlowInputParams;
import brainflow.BrainFlowMetrics;
import brainflow.BrainFlowModelParams;
import brainflow.DataFilter;
import brainflow.LogLevels;
import brainflow.MLModel;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.io.FileReader;
import org.apache.commons.lang3.math.NumberUtils;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class OpenBCI_GUI extends PApplet {


///////////////////////////////////////////////////////////////////////////////
//
//   GUI for controlling the ADS1299-based OpenBCI
//
//   Created: Chip Audette, Oct 2013 - May 2014
//   Modified: Conor Russomanno & Joel Murphy, August 2014 - Dec 2014
//   Modified (v2.0): Conor Russomanno & Joel Murphy (AJ Keller helped too), June 2016
//   Modified (v3.0) AJ Keller (Conor Russomanno & Joel Murphy & Wangshu), September 2017
//   Modified (v4.0) AJ Keller (Richard Waltman), September 2018
//   Modified (v5.0) Richard Waltman, August 2020
//
//   Requires gwoptics graphing library for processing.  Built on V0.5.0
//   http://www.gwoptics.org/processing/gwoptics_p5lib/
//
//   Requires ControlP5 library, but an older one.  This will only work
//   with the ControlP5 library that is included with this GitHub repository
//
//   No warranty. Use at your own risk. Use for whatever you'd like.
//
////////////////////////////////////////////////////////////////////////////////
  // To make sound.  Following minim example "frequencyModulation"
 // To make sound.  Following minim example "frequencyModulation"
 //for exp, log, sqrt...they seem better than Processing's built-in


 //for Array.copyOfRange()
 //for serial communication to Arduino/OpenBCI
 //to allow for event listener on screen resize
 // For TCP networking
 //used for graphs
  //for animated gifs
 // For callbacks
 // For input





 //Used in DataLogging.pde





// import java.net.InetAddress; // Used for ping, however not working right now.

 //used for simulating mouse clicks

 // for OSC
 // for OSC
 //for UDP
 //for BDF file writing
 //for LSL
 //Helps distinguish serial ports on Windows





//------------------------------------------------------------------------
//                       Global Variables & Instances
//------------------------------------------------------------------------
//Used to check GUI version in TopNav.pde and displayed on the splash screen on startup
String localGUIVersionString = "v5.2.1";
String localGUIVersionDate = "July 2023";
String guiLatestVersionGithubAPI = "https://api.github.com/repos/OpenBCI/OpenBCI_GUI/releases/latest";
String guiLatestReleaseLocation = "https://github.com/OpenBCI/OpenBCI_GUI/releases/latest";
Boolean guiIsUpToDate;

PApplet ourApplet;

CopyPaste copyPaste;

//used to switch between application states
final int SYSTEMMODE_INTROANIMATION = -10;
final int SYSTEMMODE_PREINIT = 0;
final int SYSTEMMODE_POSTINIT = 10;
int systemMode = SYSTEMMODE_INTROANIMATION; /* Modes: -10 = intro sequence; 0 = system stopped/control panel setings; 10 = gui; 20 = help guide */

ControlPanel controlPanel;

int selectedSamplingRate = -1; //program-wide variable to track sampling rate, which can change depending on selected data source

boolean midInit = false;
boolean midInitCheck2 = false;
boolean abandonInit = false;
boolean systemHasHalted = true;
boolean reinitRequested = false;

final int NCHAN_CYTON = 8;
final int NCHAN_CYTON_DAISY = 16;
final int NCHAN_GANGLION = 4;

//choose where to get the EEG data
final int DATASOURCE_CYTON = 0; // new default, data from serial with Accel data CHIP 2014-11-03
final int DATASOURCE_GANGLION = 1;  //looking for signal from OpenBCI board via Serial/COM port, no Aux data
final int DATASOURCE_PLAYBACKFILE = 2;  //playback from a pre-recorded text file
final int DATASOURCE_SYNTHETIC = 3;  //Synthetically generated data
final int DATASOURCE_STREAMING = 5;
public int eegDataSource = -1; //default to none of the options
final static int NUM_ACCEL_DIMS = 3;

enum BoardProtocol {
    NONE,
    SERIAL,
    NATIVE_BLE,
    WIFI,
    BLED112
}
public BoardProtocol selectedProtocol = BoardProtocol.NONE;

boolean showStartupError = false;
String startupErrorMessage = "";
//here are variables that are used if loading input data from a CSV text file...double slash ("\\") is necessary to make a single slash
String playbackData_fname = "N/A"; //only used if loading input data from a file
String sdData_fname = "N/A"; //only used if loading input data from a sd file
int nextPlayback_millis = -100; //any negative number

// Initialize board
DataSource currentBoard = new BoardNull();

DataLogger dataLogger = new DataLogger();

// Intialize interface protocols
InterfaceSerial iSerial = new InterfaceSerial(); //This is messy, half-deprecated code. See comments in InterfaceSerial.pde - Nov. 2020
String openBCI_portName = "N/A";  //starts as N/A but is selected from control panel to match your OpenBCI USB Dongle's serial/COM
int openBCI_baud = 115200; //baud rate from the Arduino

String ganglion_portName = "N/A";

String wifi_portName = "N/A";
String wifi_ipAddress = "192.168.4.1";

String brainflowStreamer = "";

////// ---- Define variables related to OpenBCI board operations
//Define number of channels from cyton...first EEG channels, then aux channels
int nchan = NCHAN_CYTON; //Normally, 8 or 16.  Choose a smaller number to show fewer on the GUI

//define variables related to warnings to the user about whether the EEG data is nearly railed (and, therefore, of dubious quality)
DataStatus is_railed[];

//Cyton SD Card setting
CytonSDMode cyton_sdSetting = CytonSDMode.NO_WRITE;

// Calculate nPointsPerUpdate based on sampling rate and buffer update rate
// @UPDATE_MILLIS: update the buffer every 40 milliseconds
// @nPointsPerUpdate: update the GUI after this many data points have been received.
// The sampling rate should be ideally a multiple of 25, so as to make actual buffer update rate exactly 40ms
final int UPDATE_MILLIS = 40;
int nPointsPerUpdate;   // no longer final, calculate every time in initSystem

//define some data fields for handling data here in processing
float dataProcessingRawBuffer[][]; //2D array to handle multiple data channels, each row is a new channel so that dataBuffY[3][] is channel 4
float dataProcessingFilteredBuffer[][];
float data_elec_imp_ohm[];

//define how much time is shown on the time-domain montage plot (and how much is used in the FFT plot?)
int dataBuff_len_sec = 20 + 2; //Add two seconds to max buffer to account for filter artifact on the left of the graph

StopWatch sessionTimeElapsed;
StopWatch streamTimeElapsed;

String output_fname;

//Used mostly in W_playback.pde
JSONObject savePlaybackHistoryJSON;
JSONObject loadPlaybackHistoryJSON;
String userPlaybackHistoryFile;
boolean playbackHistoryFileExists = false;
String playbackData_ShortName;
boolean recentPlaybackFilesHaveUpdated = false;

// Serial output
processing.serial.Serial serial_output;

//Control Panel for (re)configuring system settings
PlotFontInfo fontInfo;

//program variables
StringBuilder board_message;
boolean textFieldIsActive = false;

//set window size
int win_w;  //window width
int win_h; //window height

PImage cog;
Gif loadingGIF;
Gif loadingGIF_blue;

PImage logo_black;
PImage logo_blue;
PImage logo_white;
PImage consoleImgBlue;
PImage consoleImgWhite;

PFont f1;
PFont f2;
PFont f3;
PFont f4;
PFont f5;

PFont h1; //large Montserrat
PFont h2; //large/medium Montserrat
PFont h3; //medium Montserrat
PFont h4; //small/medium Montserrat
PFont h5; //small Montserrat

PFont p0; //large bold Open Sans
PFont p1; //large Open Sans
PFont p2; //large/medium Open Sans
PFont p3; //medium Open Sans
PFont p15;
static PFont p4; //medium/small Open Sans
PFont p13;
static PFont p5; //small Open Sans
PFont p6; //small Open Sans

boolean setupComplete = false;

//Starting to collect the GUI-wide color pallet here. Rename constants all caps later...
final int WHITE = color(255);
final int BLACK = color(0);
final int OPENBCI_DARKBLUE = color(1, 18, 41);
final int OPENBCI_BLUE = color(31, 69, 110);
final int OPENBCI_BLUE_ALPHA50 = color(31, 69, 110, 50);
final int OPENBCI_BLUE_ALPHA100 = color(31, 69, 110, 100);
final int boxColor = color(200);
final int boxStrokeColor = OPENBCI_DARKBLUE;
final int isSelected_color = color(184, 220, 105); //Used for textfield borders,
final int colorNotPressed = WHITE;
final int buttonsLightBlue = color(57,128,204);
final int GREY_235 = color(235);
final int GREY_200 = color(200);
final int GREY_125 = color(125);
final int GREY_100 = color(100);
final int GREY_20 = color(20);
final int TURN_ON_GREEN = color(195, 242, 181);
final int TURN_OFF_RED = color(255, 210, 210);
final int BOLD_RED = color(224, 56, 45);
final int BUTTON_HOVER = color(177, 184, 193);//color(252, 221, 198);
final int BUTTON_HOVER_LIGHT = color(211, 222, 232);
final int BUTTON_PRESSED = color(150, 170, 200); //OPENBCI_DARKBLUE;
final int BUTTON_PRESSED_LIGHT = color(179, 187, 199);
final int BUTTON_LOCKED_GREY = color(128);
final int BUTTON_PRESSED_DARKGREY = color(50);
final int BUTTON_NOOBGREEN = color(114,204,171);
final int BUTTON_EXPERTPURPLE = color(135,95,154);
final int BUTTON_CAUTIONRED = color(214,100,100);
final int OBJECT_BORDER_GREY = color(150);
final int TOPNAV_DARKBLUE = OPENBCI_BLUE;
final int SUBNAV_LIGHTBLUE = buttonsLightBlue;
//Use the same colors for X,Y,Z throughout Accelerometer widget
final int ACCEL_X_COLOR = BOLD_RED;
final int ACCEL_Y_COLOR = color(49, 113, 89);
final int ACCEL_Z_COLOR = color(54, 87, 158);
//Signal check colors
final int SIGNAL_CHECK_YELLOW = color(221, 178, 13); //Same color as yellow channel color found below
final int SIGNAL_CHECK_YELLOW_LOWALPHA = color(221, 178, 13, 150);
final int SIGNAL_CHECK_RED = BOLD_RED;
final int SIGNAL_CHECK_RED_LOWALPHA = color(224, 56, 45, 150);


final int COLOR_SCHEME_DEFAULT = 1;
final int COLOR_SCHEME_ALTERNATIVE_A = 2;
// int COLOR_SCHEME_ALTERNATIVE_B = 3;
int colorScheme = COLOR_SCHEME_ALTERNATIVE_A;

WidgetManager wm;
boolean wmVisible = true;
CColor cp5_colors;

//Channel Colors -- Defaulted to matching the OpenBCI electrode ribbon cable
final int[] channelColors = {
    color(129, 129, 129),
    color(124, 75, 141),
    color(54, 87, 158),
    color(49, 113, 89),
    SIGNAL_CHECK_YELLOW,
    color(253, 94, 52),
    BOLD_RED,
    color(162, 82, 49)
};

//Global variable for general navigation bar height
final int navHeight = 22;

ButtonHelpText buttonHelpText;

TextFieldUpdateHelper textfieldUpdateHelper;

static CustomOutputStream outputStream;

//Variables from TopNav.pde. Used to set text when stopping/starting data stream.
public final static String stopButton_pressToStop_txt = "Stop Data Stream";
public final static String stopButton_pressToStart_txt = "Start Data Stream";

DirectoryManager directoryManager;
SessionSettings settings;
GuiSettings guiSettings;
DataProcessing dataProcessing;
FilterSettings filterSettings;

final int navBarHeight = 32;
TopNav topNav;

ddf.minim.analysis.FFT[] fftBuff = new ddf.minim.analysis.FFT[nchan];    //from the minim library
boolean isFFTFiltered = true; //yes by default ... this is used in dataProcessing.pde to determine which uV array feeds the FFT calculation

StringBuilder globalScreenResolution;
StringBuilder globalScreenDPI;

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

//========================SETUP============================//

public void settings() {
    //LINUX GFX FIX #816
    System.setProperty("jogl.disable.openglcore", "false");

    win_w = 1024;
    win_h = 768;

    // If less than 1366x768, set smaller minimum GUI size
    // Nov 2020 - Accomodate as low as 1024 X 640
    if (displayWidth <= 1366 || displayHeight <= 768) {
        win_w = 980;
        win_h = 580;
    }
    size(win_w, win_h, P2D);

    globalScreenResolution = new StringBuilder("Screen Resolution: ");
    globalScreenResolution.append(displayWidth);
    globalScreenResolution.append(" X ");
    globalScreenResolution.append(displayHeight);
    //Account for high-dpi displays on Mac, Windows, and Linux Machines Fixes #968
    pixelDensity(displayDensity());
    globalScreenDPI = new StringBuilder("High-DPI Screen Detected: ");
    globalScreenDPI.append(displayDensity() == 2);
}

public void setup() {
    frameRate(120);

    copyPaste = new CopyPaste();

    //V1 FONTS
    f1 = createFont("fonts/Raleway-SemiBold.otf", 16);
    //Account for Macs with Retina Display and textfield text being too large
    int f2FontSize = isMac() && (displayDensity() > 1) ? 8 : 15;
    f2 = createFont("fonts/Raleway-Regular.otf", f2FontSize);
    f3 = createFont("fonts/Raleway-SemiBold.otf", 15);
    f4 = createFont("fonts/Raleway-SemiBold.otf", 64);  // clear bigger fonts for widgets
    //Account for Macs with Retina Display and textfield text being too large
    int f5FontSize = isMac() && (displayDensity() > 1) ? 6 : 12;
    f5 = createFont("fonts/Raleway-Regular.otf", f5FontSize);

    h1 = createFont("fonts/Montserrat-Regular.otf", 20);
    h2 = createFont("fonts/Montserrat-Regular.otf", 18);
    h3 = createFont("fonts/Montserrat-Regular.otf", 16);
    h4 = createFont("fonts/Montserrat-Regular.otf", 14);
    h5 = createFont("fonts/Montserrat-Regular.otf", 12);

    p0 = createFont("fonts/OpenSans-Semibold.ttf", 24);
    p1 = createFont("fonts/OpenSans-Regular.ttf", 20);
    p2 = createFont("fonts/OpenSans-Regular.ttf", 18);
    p3 = createFont("fonts/OpenSans-Regular.ttf", 16);
    p15 = createFont("fonts/OpenSans-Regular.ttf", 15);
    p4 = createFont("fonts/OpenSans-Regular.ttf", 14);
    p13 = createFont("fonts/OpenSans-Regular.ttf", 13);
    p5 = createFont("fonts/OpenSans-Regular.ttf", 12);
    p6 = createFont("fonts/OpenSans-Regular.ttf", 10);

    cog = loadImage("obci-logo-blu-cog.png");

    // check if the current directory is writable
    File dummy = new File(sketchPath());
    if (!dummy.canWrite()) {
        showStartupError = true;
        startupErrorMessage = "OpenBCI GUI was launched from a read-only location.\n\n" +
            "Please move the application to a different location and re-launch.\n" +
            "If you just downloaded the GUI, move it out of the disk image or Downloads folder.\n\n" +
            "If this error persists, contact the OpenBCI team for support.";
        return; // early exit
    }
    
    directoryManager = new DirectoryManager();

    // redirect all output to a custom stream that will intercept all prints
    // write them to file and display them in the GUI's console window
    outputStream = new CustomOutputStream(System.out);
    System.setOut(outputStream);
    System.setErr(outputStream);

    StringBuilder osName = new StringBuilder("Operating System and Version: ");
    if (isLinux()) {
        osName.append("Linux");
    } else if (isWindows()) {
        osName.append("Windows");
        //Throw a popup if we detect an incompatible version of Windows. Fixes #964. Found in Extras.pde.
        checkIsOldVersionOfWindowsOS();
        //This is an edge case when using 32-bit Processing Java on Windows. Throw a popup if detected.
        checkIs64BitJava();
    } else if (isMac()) {
        osName.append("Mac");
    }

    osName.append(" - ");
    osName.append(getOperatingSystemVersion());

    println("Console Log Started at Local Time: " + directoryManager.getFileNameDateTime());
    println(globalScreenResolution.toString());
    println(globalScreenDPI.toString());
    println(osName.toString());
    if (isMac()) {
        checkIsMacFullDetail();
    }
    println("JVM Version: " + System.getProperty("java.version"));
    println("Welcome to the Processing-based OpenBCI GUI!"); //Welcome line.
    println("For more information, please visit: https://docs.openbci.com/Software/OpenBCISoftware/GUIDocs/");
    
    // Copy sample data to the Users' Documents folder +  create Recordings folder
    directoryManager.init();
    settings = new SessionSettings();
    guiSettings = new GuiSettings(directoryManager.getSettingsPath());
    userPlaybackHistoryFile = directoryManager.getSettingsPath()+"UserPlaybackHistory.json";

    //open window
    ourApplet = this;

    // Bug #426: If setup takes too long, JOGL will time out waiting for the GUI to draw something.
    // moving the setup to a separate thread solves this. We just have to make sure not to
    // start drawing until delayed setup is done.
    thread("delayedSetup");
}

public void delayedSetup() {
    smooth(); //turn this off if it's too slow

    surface.setResizable(true);  //updated from frame.setResizable in Processing 2
    settings.widthOfLastScreen = width; //for screen resizing (Thank's Tao)
    settings.heightOfLastScreen = height;

    setupContainers();

    fontInfo = new PlotFontInfo();
    helpWidget = new HelpWidget(0, win_h - 30, win_w, 30);
    //Instantiate buttonHelpText before any buttons have been made
    buttonHelpText = new ButtonHelpText();
    textfieldUpdateHelper = new TextFieldUpdateHelper();

    //setup topNav
    topNav = new TopNav();
    
    //Print BrainFlow version
    StringBuilder brainflowVersion = new StringBuilder("BrainFlow Version: ");
    try {
        brainflowVersion.append(BoardShim.get_version());
    } catch (BrainFlowError e) {
        e.printStackTrace();
    }
    println(brainflowVersion);


    logo_black = loadImage("obci-logo-blk.png");
    logo_blue = loadImage("obci-logo-blu.png");
    logo_white = loadImage("obci-logo-wht.png");
    consoleImgBlue = loadImage("console-45x45-dots_blue.png");
    consoleImgWhite = loadImage("console-45x45-dots_white.png");
    loadingGIF = new Gif(this, "ajax_loader_gray_512.gif");
    loadingGIF.loop();
    loadingGIF_blue = new Gif(this, "obci_cog_anim-normalblue.gif");
    loadingGIF_blue.loop();

    prepareExitHandler();

    sessionTimeElapsed = new StopWatch();
    streamTimeElapsed = new StopWatch();

    asyncLoadAudioFiles();

    synchronized(this) {
        // Instantiate ControlPanel in the synchronized block.
        // It's important to avoid instantiating a ControlP5 during a draw() call
        // Otherwise we get a crash on launch 10% of the time
        controlPanel = new ControlPanel(this);

        setupComplete = true; // signal that the setup thread has finished
        println("OpenBCI_GUI::Setup: Setup is complete!");
    }

    //Apply GUI-wide settings to front end at the end of setup
    guiSettings.applySettings();

    if (!isAdminUser() || isElevationNeeded()) {
        outputError("OpenBCI_GUI: This application is not being run with Administrator access. This could limit the ability to connect to devices or read/write files.");
    }
}

//====================== END-OF-SETUP ==========================//

//======================== DRAW LOOP =============================//

public synchronized void draw() {
    if (showStartupError) {
        drawStartupError();
    } else if (setupComplete && systemMode != SYSTEMMODE_INTROANIMATION) {
        systemUpdate(); //signPost("20");
        systemDraw();   //signPost("30");
        if (midInit) {
            //If Start Session was clicked, wait 2 draw cycles to show overlay, then init session.
            //When Init session is started, the screen will seem to hang.
            systemInitSession();
        }
        if(reinitRequested) {
            haltSystem();
            initSystem();
            reinitRequested = false;
        }
        if (systemMode == SYSTEMMODE_POSTINIT) {
            w_networking.compareAndSetNetworkingFrameLocks();
        }
    } else if (systemMode == SYSTEMMODE_INTROANIMATION) {
        if (settings.introAnimationInit == 0) {
            settings.introAnimationInit = millis();
        } else {
            introAnimation();
        }
    }
}

//====================== END-OF-DRAW ==========================//

private void prepareExitHandler () {
    // This callback will run when the GUI quits
    Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
        public void run () {
            System.out.println("SHUTDOWN HOOK");
            
            haltSystem();
        }
    }
    ));
}

//Init system based on default settings. Called from the "START SESSION" button in the GUI's ControlPanel.
public void initSystem() {
    println("");
    println("");
    println("=================================================");
    println("||             INITIALIZING SYSTEM             ||");
    println("=================================================");
    println("");

    verbosePrint("OpenBCI_GUI: initSystem: -- Init 0 -- ");

    //reset init variables
    systemHasHalted = false;
    boolean abandonInit = false;

    sessionTimeElapsed.reset();
    sessionTimeElapsed.start();
    sessionTimeElapsed.suspend();

    //prepare the source of the input data
    switch (eegDataSource) {
        case DATASOURCE_CYTON:
            if (selectedProtocol == BoardProtocol.SERIAL) {
                if(nchan == 16) {
                    currentBoard = new BoardCytonSerialDaisy(openBCI_portName);
                }
                else {
                    currentBoard = new BoardCytonSerial(openBCI_portName);
                }
            }
            else if (selectedProtocol == BoardProtocol.WIFI) {
                if(nchan == 16) {
                    currentBoard = new BoardCytonWifiDaisy(wifi_ipAddress, selectedSamplingRate);
                }
                else {
                    currentBoard = new BoardCytonWifi(wifi_ipAddress, selectedSamplingRate);
                }
            }
            break;
        case DATASOURCE_SYNTHETIC:
            currentBoard = new BoardBrainFlowSynthetic(nchan);
            println("OpenBCI_GUI: Init session using Synthetic data source");
            break;
        case DATASOURCE_PLAYBACKFILE:
            if (!playbackData_fname.equals("N/A")) {
                currentBoard = getDataSourcePlaybackClassFromFile(playbackData_fname);
                println("OpenBCI_GUI: Init session using Playback data source");
            } else {
                if (!sdData_fname.equals("N/A")) {
                    currentBoard = new DataSourceSDCard(sdData_fname);
                    println("OpenBCI_GUI: Init session using Playback data source");
                }
                else {
                    // no code path to it
                    println("No playback or SD file selected.");
                }
            }
            break;
        case DATASOURCE_GANGLION:
            if (selectedProtocol == BoardProtocol.WIFI) {
                currentBoard = new BoardGanglionWifi(wifi_ipAddress, selectedSamplingRate);
            } else if (selectedProtocol == BoardProtocol.BLED112) {
                String ganglionName = (String)(controlPanel.bleBox.bleList.getItem(controlPanel.bleBox.bleList.activeItem).get("headline"));
                String ganglionPort = (String)(controlPanel.bleBox.bleList.getItem(controlPanel.bleBox.bleList.activeItem).get("subline"));
                String ganglionMac = controlPanel.bleBox.bleMACAddrMap.get(ganglionName);
                println("MAC address for Ganglion is " + ganglionMac);
                currentBoard = new BoardGanglionBLE(ganglionPort, ganglionMac);
            } else if (selectedProtocol == BoardProtocol.NATIVE_BLE) {
                String ganglionName = (String)(controlPanel.bleBox.bleList.getItem(controlPanel.bleBox.bleList.activeItem).get("headline"));
                String ganglionMac = controlPanel.bleBox.bleMACAddrMap.get(ganglionName);
                println("MAC address for Ganglion is " + ganglionName);
                currentBoard = new BoardGanglionNative(ganglionName);
            }
            break;
        case DATASOURCE_STREAMING:
            currentBoard = new BoardBrainFlowStreaming(
                    controlPanel.streamingBoardBox.getBoard().getBoardId(), 
                    controlPanel.streamingBoardBox.getIP(),
                    controlPanel.streamingBoardBox.getPort()
                    );
            println("OpenBCI_GUI: Init session using Streaming data source");
        default:
            break;
    }

    // initialize the chosen board
    boolean success = currentBoard.initialize();
    abandonInit = !success; // abandon if init fails
    
    //Handle edge cases for Cyton and Cyton+Daisy users immediately after board is initialized. Fixes #954
    if (eegDataSource == DATASOURCE_CYTON) {
        println("OpenBCI_GUI: Configuring Cyton Channel Count...");
        if (currentBoard instanceof BoardCytonSerial) {
            Pair<Boolean, String> res = ((BoardBrainFlow)currentBoard).sendCommand("c");
            //println(res.getKey().booleanValue(), res.getValue());
            if (res.getValue().startsWith("daisy removed")) {
                println("OpenBCI_GUI: Daisy is physically attached, using Cyton 8 Channels instead.");
            }
        } else if (currentBoard instanceof BoardCytonSerialDaisy) {
            Pair<Boolean, String> res = ((BoardBrainFlow)currentBoard).sendCommand("C");
            //println(res.getKey().booleanValue(), res.getValue());
            if (res.getValue().startsWith("no daisy to attach")) {
                haltSystem();
                outputError("User selected Cyton+Daisy, but no Daisy is attached. Please change Channel Count to 8 Channels.");
                controlPanel.open();
                return;
            }
        }

        //Show a popup to inform first-time Cyton users about the FTDI buffer fix and Cyton Smoothing feature. Fixes #1026
        //Windows Users: Latest BrainFlow will automatically fix this in the background on Session Start! Fixed in #1039
        if (guiSettings.getShowCytonSmoothingPopup()) {
            println("OpenBCI_GUI: Showing Cyton FTDI Buffer Fix Popup");
            String popupTitle = "Cyton FTDI Buffer Fix Info";
            String popupString = "The default settings for the Cyton Dongle driver can make data appear \"choppy.\" Visit the OpenBCI Docs to learn how to fix this. For now, the GUI will \"smooth\" the data for you.";
            String popupButtonText = "View Fix";
            String popupButtonURL;
            if (isMac()) {
                popupButtonURL = "https://docs.openbci.com/Troubleshooting/FTDI_Fix_Mac/";
                PopupMessage msg = new PopupMessage(popupTitle, popupString, popupButtonText, popupButtonURL);
            } else if (isLinux()){
                popupButtonURL = "https://docs.openbci.com/Troubleshooting/FTDI_Fix_Linux/";
                PopupMessage msg = new PopupMessage(popupTitle, popupString, popupButtonText, popupButtonURL);
            }
            guiSettings.setShowCytonSmoothingPopup(false);
        }
    }

    updateToNChan(currentBoard.getNumEXGChannels());

    dataLogger.initialize();

    verbosePrint("OpenBCI_GUI: initSystem: Initializing core data objects");
    initCoreDataObjects();

    verbosePrint("OpenBCI_GUI: initSystem: -- Init 1 -- " + millis());
    verbosePrint("OpenBCI_GUI: initSystem: Initializing FFT data objects");
    initFFTObjectsAndBuffer();

    verbosePrint("OpenBCI_GUI: initSystem: -- Init 2 -- " + millis());
    verbosePrint("OpenBCI_GUI: initSystem: Closing ControlPanel...");

    controlPanel.close();
    topNav.controlPanelCollapser.setOff();

    verbosePrint("OpenBCI_GUI: initSystem: -- Init 3 -- " + millis());

    if (abandonInit) {
        haltSystem();
        outputError("Failed to initialize board. Please check that the board is on and has power. See Console Log for more details.");
        controlPanel.open();
        return;
    } else {
        //initilize the secondary topnav and all applicable widgets
        topNav.initSecondaryNav();
        wm = new WidgetManager(this);
        nextPlayback_millis = millis(); //used for synthesizeData and readFromFile.  This restarts the clock that keeps the playback at the right pace.
        systemMode = SYSTEMMODE_POSTINIT; //tell system it's ok to leave control panel and start interfacing GUI
    }

    verbosePrint("OpenBCI_GUI: initSystem: -- Init 4 -- " + millis());

     //don't save default session settings StreamingBoard
    if (eegDataSource != DATASOURCE_STREAMING) {
        //Init software settings: create default settings file that is datasource unique
        settings.init();
        settings.initCheckPointFive();
    }
    
    //Make sure topNav buttons draw in the correct spot
    topNav.screenHasBeenResized(width, height);

    //Instantiate Global Filter Settings Class
    filterSettings = new FilterSettings(((DataSource)currentBoard));

    verbosePrint("OpenBCI_GUI: initSystem: -- Init 5 -- " + millis());

    midInit = false;
} //end initSystem

public int getCurrentBoardBufferSize() {
    return dataBuff_len_sec * currentBoard.getSampleRate();
}

/**
* @description Get the correct points of FFT based on sampling rate
* @returns `int` - Points of FFT. 125Hz, 200Hz, 250Hz -> 256points. 1000Hz -> 1024points. 1600Hz -> 2048 points.
*/
public int getNfftSafe() {
    int sampleRate = currentBoard.getSampleRate();
    switch (sampleRate) {
        case 500:
            return 512;
        case 1000:
            return 1024;
        case 1600:
            return 2048;
        case 125:
        case 200:
        case 250:
        default:
            return 256;
    }
}

public void initCoreDataObjects() {
    nPointsPerUpdate = PApplet.parseInt(round(PApplet.parseFloat(UPDATE_MILLIS) * currentBoard.getSampleRate()/ 1000.f));
    dataProcessingRawBuffer = new float[nchan][getCurrentBoardBufferSize()];
    dataProcessingFilteredBuffer = new float[nchan][getCurrentBoardBufferSize()];

    data_elec_imp_ohm = new float[nchan];
    is_railed = new DataStatus[nchan];
    for (int i=0; i<nchan; i++) {
        is_railed[i] = new DataStatus();
    }

    dataProcessing = new DataProcessing(nchan, currentBoard.getSampleRate());
}

public void initFFTObjectsAndBuffer() {
    //initialize the FFT objects
    for (int Ichan=0; Ichan < nchan; Ichan++) {
        // verbosePrint("Init FFT Buff – " + Ichan);
        fftBuff[Ichan] = new ddf.minim.analysis.FFT(getNfftSafe(), currentBoard.getSampleRate());
    }  //make the FFT objects

    //Attempt initialization. If error, print to console and exit function.
    //Fixes GUI crash when trying to load outdated recordings
    try {
        initializeFFTObjects(fftBuff, dataProcessingRawBuffer, getNfftSafe(), currentBoard.getSampleRate());
    } catch (ArrayIndexOutOfBoundsException e) {
        //e.printStackTrace();
        outputError("Playback file load error. Try using a more recent recording.");
        return;
    }
}

public void startRunning() {
    // start streaming on the chosen board
    dataLogger.onStartStreaming();
    currentBoard.startStreaming();
    if (currentBoard.isStreaming()) {
        output("Data stream started.");
        // todo: this should really be some sort of signal that listeners can register for "OnStreamStarted"
        // close hardware settings if user starts streaming
        w_timeSeries.closeADSSettings();
        try {
            streamTimeElapsed.reset();
            streamTimeElapsed.start();
            sessionTimeElapsed.resume();
        } catch (IllegalStateException e) {
            e.printStackTrace();
            outputError("Failed to start Timer.");
        }
    } else {
        outputError("Failed to start data stream. Please check hardware. See Console Log or BrainFlow Log for more details.");
    }
}

public void stopRunning() {
    //Check again if board is streaming to avoid IllegalStateException
    if (currentBoard.isStreaming() && topNav.dataStreamingButtonIsActive()) {
        //If streaming, attempt to stop stream
        currentBoard.stopStreaming();
        output("Data stream stopped.");
        try {
            streamTimeElapsed.stop();
            sessionTimeElapsed.suspend();
            dataLogger.onStopStreaming();
        } catch (IllegalStateException e) {
            e.printStackTrace();
            outputError("GUI Error: Failed to stop Timer. Please make an issue on GitHub in the GUI repo.");
        }
    } else {
        output("Data stream is already stopped.");
    }
}

//halt the data collection
public void haltSystem() {
    if (!systemHasHalted) { //prevents system from halting more than once
        println("openBCI_GUI: haltSystem: Halting system for reconfiguration of settings...");
        
        //Reset the text for the Start Session buttonscreen. Skip when reiniting board while already in playback mode session.
        if (!reinitRequested) {
            controlPanel.initBox.setInitSessionButtonText("START SESSION");
        }

        if (w_networking != null && w_networking.getNetworkActive()) {
            w_networking.stopNetwork();
            println("openBCI_GUI: haltSystem: Network streams stopped");
        }

        if (w_focus != null) {
            w_focus.endSession();
        }
        
        stopRunning();  //stop data transfer

        topNav.resetStartStopButton();
        topNav.destroySmoothingButton(); //Destroy this button if exists and make null, will be re-init if needed next time session starts

        //reset connect loadStrings
        openBCI_portName = "N/A";  // Fixes inability to reconnect after halding  JAM 1/2017
        ganglion_portName = "";
        wifi_portName = "";

        controlPanel.resetListItems();

        if (eegDataSource == DATASOURCE_PLAYBACKFILE) {
            controlPanel.recentPlaybackBox.getRecentPlaybackFiles();
        }
        systemMode = SYSTEMMODE_PREINIT;

        recentPlaybackFilesHaveUpdated = false;

        dataLogger.uninitialize();

        currentBoard.uninitialize();
        currentBoard = new BoardNull(); // back to null

        sessionTimeElapsed.stop();

        systemHasHalted = true;
    }
} //end of halt system

public void systemUpdate() { // for updating data values and variables
    //prepare for updating the GUI
    win_w = width;
    win_h = height;
    
    textfieldUpdateHelper.resetTextFieldIsActive();

    currentBoard.update();

    dataLogger.update();

    helpWidget.update();
    topNav.update();
    if (systemMode == SYSTEMMODE_PREINIT) {
        //updates while in system control panel before START SYSTEM
        controlPanel.update();

        if (settings.widthOfLastScreen != width || settings.heightOfLastScreen != height) {
            topNav.screenHasBeenResized(width, height);
            settings.widthOfLastScreen = width;
            settings.heightOfLastScreen = height;
            //println("W = " + width + " || H = " + height);
        }
    }
    if (systemMode == SYSTEMMODE_POSTINIT) {
        processNewData();
        
        //alternative component listener function (line 177 mouseReleased- 187 frame.addComponentListener) for processing 3,
        //Component listener doesn't seem to work, so staying with this method for now
        if (settings.widthOfLastScreen != width || settings.heightOfLastScreen != height) {
            settings.screenHasBeenResized = true;
            settings.timeOfLastScreenResize = millis();
            settings.widthOfLastScreen = width;
            settings.heightOfLastScreen = height;
        }

        //re-initialize GUI if screen has been resized and it's been more than 1/2 seccond (to prevent reinitialization of GUI from happening too often)
        if (settings.screenHasBeenResized && settings.timeOfLastScreenResize + 500 > millis()) {
            ourApplet = this; //reset PApplet...
            topNav.screenHasBeenResized(width, height);
            wm.screenResized();
            settings.screenHasBeenResized = false;
        }

        if (wm.isWMInitialized) {
            wm.update();
        }
    }
}

public void systemDraw() { //for drawing to the screen
    //redraw the screen...not every time, get paced by when data is being plotted
    background(OPENBCI_DARKBLUE);  //clear the screen
    noStroke();
    //background(255);  //clear the screen

    if (systemMode >= SYSTEMMODE_POSTINIT) {
        wm.draw();
        drawContainers();
    }

    if (systemMode >= SYSTEMMODE_PREINIT) {
        topNav.draw();

        //control panel
        if (controlPanel.isOpen) {
            controlPanel.draw();
        }

        //Draw output window at the bottom of the GUI
        helpWidget.draw();
    }

    //Draw button help text close to the top
    buttonHelpText.draw();

    //Draw Session Start overlay on top of everything
    if (midInit) {
        drawOverlay("Starting Session...");
    } else if (controlPanel.comPortBox.isAutoScanningForCytonSerial()) {
        drawOverlay("Auto-Scanning for Cyton...");
    }

    //Display GUI version and FPS in the title bar of the app
    surface.setTitle("OpenBCI GUI " + localGUIVersionString + " - " + localGUIVersionDate + " - " + PApplet.parseInt(frameRate) + " fps");
}

public void requestReinit() {
    reinitRequested = true;
}

//Always Called after systemDraw()
public void systemInitSession() {
    if (midInitCheck2) {
        println("OpenBCI_GUI: Start session. Calling initSystem().");
        try {
            initSystem(); //found in OpenBCI_GUI.pde
        } catch (Exception e) {
            e.printStackTrace();
            haltSystem();
        }
        midInitCheck2 = false;
        midInit = false;
    } else {
        midInitCheck2 = true;
    }
}

//Global function to update the number of channels
public void updateToNChan(int _nchan) {
    nchan = _nchan;
    settings.slnchan = _nchan; //used in SoftwareSettings.pde only
    fftBuff = new ddf.minim.analysis.FFT[nchan];  //reinitialize the FFT buffer
    println("OpenBCI_GUI: Channel count set to " + str(nchan));
}

public void introAnimation() {
    pushStyle();
    imageMode(CENTER);
    background(255);
    int t1 = 0;
    float transparency = 0;

    if (millis() >= settings.introAnimationInit) {
        transparency = map(millis() - settings.introAnimationInit, t1, settings.introAnimationDuration, 0, 255);
        verbosePrint(String.valueOf(transparency));
        tint(255, transparency);
        //draw OpenBCI Logo Front & Center
        image(cog, width/2, height/2, width/6, width/6);
        textFont(p3, 16);
        textLeading(24);
        fill(31, 69, 110, transparency);
        textAlign(CENTER, CENTER);
        String displayVersion = "OpenBCI GUI " + localGUIVersionString;
        text(displayVersion, width/2, height/2 + width/9);
        text(localGUIVersionDate, width/2, height/2 + ((width/8) * 1.125f));
    }

    //Exit intro animation when the duration has expired AND the Control Panel is ready
    if ((millis() >= settings.introAnimationInit + settings.introAnimationDuration)
        && controlPanel != null) {
        systemMode = SYSTEMMODE_PREINIT;
        controlPanel.open();
    }
    popStyle();
}

public void drawStartupError() {
    final int w = 600;
    final int h = 350;
    final int headerHeight = 75;
    final int padding = 20;

    pushStyle();
    background(OPENBCI_DARKBLUE);
    stroke(204);
    fill(GREY_235);
    rect((width - w)/2, (height - h)/2, w, h);
    noStroke();
    fill(217, 4, 4);
    rect((width - w)/2, (height - h)/2, w, headerHeight);
    textFont(p0, 24);
    fill(255);
    textAlign(LEFT, CENTER);
    text("Error", (width - w)/2 + padding, (height - h)/2, w, headerHeight);
    textFont(p3, 16);
    fill(102);
    textAlign(LEFT, TOP);
    text(startupErrorMessage, (width - w)/2 + padding, (height - h)/2 + padding + headerHeight, w-padding*2, h-padding*2-headerHeight);
    popStyle();
}

public void drawOverlay(String text) {
    //Draw a gray overlay when the Start Session button is pressed
    pushStyle();
    //imageMode(CENTER);
    fill(124, 142);
    rect(0, 0, width, height);
    popStyle();

    pushStyle();
    textFont(p0, 24);
    fill(boxColor, 255);
    stroke(OPENBCI_DARKBLUE, 200);
    rect(width/2 - (textWidth(text)+20)/2, height/2 - 80/2, textWidth(text) + 20, 80);
    fill(OPENBCI_DARKBLUE, 255);
    text(text, width/2 - textWidth(text)/2, height/2 + 8);
    popStyle();
}





interface ADSSettingsEnum {
    public String getName();
}

enum PowerDown implements ADSSettingsEnum {
    ON("Active"),
    OFF("Inactive");

    private String name;

    PowerDown(String _name) {
        this.name = _name;
    }

    @Override
    public String getName() {
        return name;
    }
}

// the scalar values are actually used to scale eeg data
enum Gain implements ADSSettingsEnum {
    X1("x1", 1.0f),
    X2("x2", 2.0f),
    X4("x4", 4.0f),
    X6("x6", 6.0f),
    X8("x8", 8.0f),
    X12("x12", 12.0f),
    X24("x24", 24.0f);

    private String name;
    private double scalar;

    Gain(String _name, double _scalar) {
        this.name = _name;
        this.scalar = _scalar;

    }

    @Override
    public String getName() {
        return name;
    }

    public double getScalar() {
        return scalar;
    }
}

enum InputType implements ADSSettingsEnum {
    NORMAL("Normal"),
    SHORTED("Shorted"),
    BIAS_MEAS("Bias Meas"),
    MVDD("MVDD"),
    TEMP("Temp"),
    TEST("Test"),
    BIAS_DRP("BIAS DRP"),
    BIAS_DRN("BIAS DRN");

    private String name;

    InputType(String _name) {
        this.name = _name;
    }

    @Override
    public String getName() {
        return name;
    }
}

enum Bias implements ADSSettingsEnum {
    NO_INCLUDE("No"),
    INCLUDE("Yes");

    private String name;

    Bias(String _name) {
        this.name = _name;
    }

    @Override
    public String getName() {
        return name;
    }
}

enum Srb2 implements ADSSettingsEnum {
    DISCONNECT("Off"),
    CONNECT("On");

    private String name;

    Srb2(String _name) {
        this.name = _name;
    }

    @Override
    public String getName() {
        return name;
    }
}

enum Srb1 implements ADSSettingsEnum {
    DISCONNECT("Off"),
    CONNECT("On");

    private String name;

    Srb1(String _name) {
        this.name = _name;
    }

    @Override
    public String getName() {
        return name;
    }
}

public class ADS1299SettingsValues {
    public PowerDown[] powerDown;
    public Gain[] gain;
    public InputType[] inputType;
    public Bias[] bias;
    public Srb2[] srb2;
    public Srb1[] srb1;

    //Used for Channel On/Off to reflect what happens in Firmware
    public Bias[] previousBias;
    public Srb2[] previousSrb2;
    public InputType[] previousInputType;

    public ADS1299SettingsValues() {
    }
}

class ADS1299Settings {
    
    public ADS1299SettingsValues values;
    public ADS1299SettingsValues previousValues;
    private ADS1299SettingsValues defaultValues;

    protected Board board;
    protected ADS1299SettingsBoard settingsBoard;

    ADS1299Settings(Board theBoard) {
        board = theBoard;
        settingsBoard = (ADS1299SettingsBoard)theBoard;
        values = new ADS1299SettingsValues();
        previousValues = new ADS1299SettingsValues();
        defaultValues = new ADS1299SettingsValues();

        int channelCount = board.getNumEXGChannels();

        // initialize all arrays with some defaults
        // (which happen to be Cyton defaults, but they don't have to be.
        // we set defaults on board contruction)
        values.powerDown = new PowerDown[channelCount];
        previousValues.powerDown = new PowerDown[channelCount];
        Arrays.fill(values.powerDown, PowerDown.ON);

        values.gain = new Gain[channelCount];
        previousValues.gain = new Gain[channelCount];
        Arrays.fill(values.gain, Gain.X24);

        values.inputType = new InputType[channelCount];
        previousValues.inputType = new InputType[channelCount];
        Arrays.fill(values.inputType, InputType.NORMAL);
        
        values.bias = new Bias[channelCount];
        previousValues.bias = new Bias[channelCount];
        Arrays.fill(values.bias, Bias.INCLUDE);

        values.srb2 = new Srb2[channelCount];
        previousValues.srb2 = new Srb2[channelCount];
        Arrays.fill(values.srb2, Srb2.CONNECT);

        values.srb1 = new Srb1[channelCount];
        previousValues.srb1 = new Srb1[channelCount];
        Arrays.fill(values.srb1, Srb1.DISCONNECT);

        values.previousBias = values.bias.clone();
        values.previousSrb2 = values.srb2.clone();
        values.previousInputType = values.inputType.clone();

        String currentVals = getJson();
        Gson gson = new Gson();
        defaultValues = gson.fromJson(currentVals, ADS1299SettingsValues.class);
    }

    public boolean loadSettingsValues(String filename) {
        try {
            File file = new File(filename);
            StringBuilder fileContents = new StringBuilder((int)file.length());        
            Scanner scanner = new Scanner(file);
            while(scanner.hasNextLine()) {
                fileContents.append(scanner.nextLine() + System.lineSeparator());
            }
            Gson gson = new Gson();
            values = gson.fromJson(fileContents.toString(), ADS1299SettingsValues.class);
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    public String getJson() {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        return gson.toJson(values);
    }

    public boolean saveToFile(String filename) {
        String json = getJson();
        try {
            FileWriter writer = new FileWriter(filename);
            writer.write(json);
            writer.close();
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    public boolean isChannelActive(int chan) {
        return values.powerDown[chan] == PowerDown.ON;
    }

    public void setChannelActive(int chan, boolean active) {
        String oldValues = getJson();
        if (active) {
            values.bias[chan] = values.previousBias[chan];
            values.srb2[chan] = values.previousSrb2[chan];
            values.inputType[chan] = values.previousInputType[chan];
        } else {
            values.previousBias[chan] = values.bias[chan];
            values.previousSrb2[chan] = values.srb2[chan];
            values.previousInputType[chan] = values.inputType[chan];

            values.bias[chan] = Bias.NO_INCLUDE;
            values.srb2[chan] = Srb2.DISCONNECT;
            values.inputType[chan] = InputType.SHORTED;
        }

        values.powerDown[chan] = active ? PowerDown.ON : PowerDown.OFF;
        boolean res = commit(chan);
        if (!res) {
            // restore old settings in UI
            Gson gson = new Gson();
            values = gson.fromJson(oldValues, ADS1299SettingsValues.class);
        }
    }

    //Return true if sendCommand is successful
    public boolean commit(int chan) {
        String command = String.format("x%c%d%d%d%d%d%dX", settingsBoard.getChannelSelector(chan),
                                        values.powerDown[chan].ordinal(), values.gain[chan].ordinal(),
                                        values.inputType[chan].ordinal(), values.bias[chan].ordinal(),
                                        values.srb2[chan].ordinal(), values.srb1[chan].ordinal());

        return board.sendCommand(command).getKey().booleanValue();
    }

    //Return true if all commits are successful
    public boolean[] commitAll() {
        int numChan = board.getNumEXGChannels();
        boolean[] success = new boolean[numChan];
        for (int i=0; i<numChan; i++) {
            success[i] = commit(i);
        }
        return success;
    }

    //Return true if all commits are successful
    public boolean commitDefaultsAllAtOnce() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < board.getNumEXGChannels(); i++) {
            String command = String.format("x%c%d%d%d%d%d%dX", settingsBoard.getChannelSelector(i),
                                        defaultValues.powerDown[i].ordinal(), defaultValues.gain[i].ordinal(),
                                        defaultValues.inputType[i].ordinal(), defaultValues.bias[i].ordinal(),
                                        defaultValues.srb2[i].ordinal(), defaultValues.srb1[i].ordinal());
            sb.append(command);
        }
        return board.sendCommand(sb.toString()).getKey().booleanValue();
    }

    //Return true if all commits are successful
    public void revertAllChannelsToDefaultValues() {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        String defaultValsAsString = gson.toJson(defaultValues);
        values = gson.fromJson(defaultValsAsString, ADS1299SettingsValues.class);
    }

    public void saveAllLastValues() {
        String lastVals = getJson();
        Gson gson = new Gson();
        previousValues = gson.fromJson(lastVals, ADS1299SettingsValues.class);
    }

    public void saveLastValues(int chan) {
        previousValues.gain[chan] = values.gain[chan];
        previousValues.inputType[chan] = values.inputType[chan];
        previousValues.bias[chan] = values.bias[chan];
        previousValues.srb2[chan] = values.srb2[chan];
        previousValues.srb1[chan] = values.srb1[chan];
    }

    public void revertToLastValues(int chan) {
        values.gain[chan] = previousValues.gain[chan];
        values.inputType[chan] = previousValues.inputType[chan];
        values.bias[chan] = previousValues.bias[chan];
        values.srb2[chan] = previousValues.srb2[chan];
        values.srb1[chan] = previousValues.srb1[chan];
    }

    public boolean equalsLastValues(int chan) {        
        boolean equal = previousValues.gain[chan] == values.gain[chan] &&
                        previousValues.inputType[chan] == values.inputType[chan] &&
                        previousValues.bias[chan] == values.bias[chan] &&
                        previousValues.srb2[chan] == values.srb2[chan] &&
                        previousValues.srb1[chan] == values.srb1[chan]
                        ;
        return equal;
    }

    //Get previous or current values as a string
    public String getValuesString(int chan, ADS1299SettingsValues vals) {
        String commandString = String.format("x%c%d%d%d%d%d%dX", settingsBoard.getChannelSelector(chan),
                                        vals.powerDown[chan].ordinal(), vals.gain[chan].ordinal(),
                                        vals.inputType[chan].ordinal(), vals.bias[chan].ordinal(),
                                        vals.srb2[chan].ordinal(), vals.srb1[chan].ordinal());
        return commandString;
    }
}

interface ADS1299SettingsBoard {

    // Interface methods
    public ADS1299Settings getADS1299Settings();
    public char getChannelSelector(int channel);
    public double getGain(int channel);
};



class ADS1299SettingsController {
    private PApplet _parentApplet;
    private boolean isVisible = false;
    private int x, y, w, h;
    private final int padding_3 = 3;
    private final int navH = 22;

    private ControlP5 hwsCp5;
    private final int numControlButtons = 3;
    private Button loadButton;
    private Button saveButton;
    private Button sendButton;
    private int button_w = 80;
    private int button_h = navH;
    private final int columnLabelH = navH;
    private final int commandBarH = navH + padding_3 * 2;
    private int chanBar_h;

    private int spaceBetweenButtons = 5; //space between buttons

    private TextBox gainLabel;
    private TextBox inputTypeLabel;
    private TextBox biasLabel;
    private TextBox srb2Label;
    private TextBox srb1Label;

    private ScrollableList[] gainLists;
    private ScrollableList[] inputTypeLists;
    private ScrollableList[] biasLists;
    private ScrollableList[] srb2Lists;
    private ScrollableList[] srb1Lists;
    private boolean[] hasUnappliedChanges;
    private final int yesOnColor = 0xFFDFF2BF;
    private final int noOffColor = 0xFFFFD2D2;

    private Textfield customCommandTF;
    private Button sendCustomCmdButton;
    private int customCmdUI_x;
    private int customCmdUI_w;

    private ADS1299Settings boardSettings;

    private int channelCount;
    private List<Integer> activeChannels;

    ADS1299SettingsController(PApplet _parent, List<Integer> _activeChannels, int _x, int _y, int _w, int _h, int _channelBarHeight) {
        x = _x;
        y = _y;
        w = _w;
        h = _h;
        chanBar_h = _channelBarHeight;
        
        _parentApplet = _parent;
        hwsCp5 = new ControlP5(_parentApplet);
        hwsCp5.setGraphics(_parentApplet, 0,0);
        hwsCp5.setAutoDraw(false);
        
        int colOffset = (w / numControlButtons) / 2;
        int button_y = y + h + padding_3;
        createHWSettingsLoadButton("HardwareSettingsLoad", "Load", x + colOffset - button_w/2, button_y, button_w, button_h);
        createHWSettingsSaveButton("HardwareSettingsSave", "Save", x + colOffset + (w/numControlButtons) - button_w/2, button_y, button_w, button_h);
        createHWSettingsSendButton("HardwareSettingsSend", "Send", x + colOffset + (w/numControlButtons)*2 - button_w/2, button_y, button_w, button_h);

        activeChannels = _activeChannels;
        ADS1299SettingsBoard settingsBoard = (ADS1299SettingsBoard)currentBoard;
        boardSettings = settingsBoard.getADS1299Settings();
        boardSettings.saveAllLastValues();
        channelCount = currentBoard.getNumEXGChannels();
        hasUnappliedChanges = new boolean[channelCount];
        Arrays.fill(hasUnappliedChanges, Boolean.FALSE);

        //color labelBG = color(220);
        int labelBG = color(255,255,255,0);
        int labelTxt = OPENBCI_DARKBLUE;
        colOffset = (w / 5) / 2;
        int label_y = y - 14 - padding_3;
        gainLabel = new TextBox("PGA Gain", x + colOffset, label_y, labelTxt, labelBG, 12, h5, CENTER, TOP);
        inputTypeLabel = new TextBox("Input Type", x + colOffset + (w/5), label_y, labelTxt, labelBG, 12, h5, CENTER, TOP);
        biasLabel = new TextBox("Bias Include", x + colOffset + (w/5)*2, label_y, labelTxt, labelBG, 12, h5, CENTER, TOP);
        srb2Label = new TextBox("SRB2", x + colOffset + (w/5)*3, label_y, labelTxt, labelBG, 12, h5, CENTER, TOP);
        srb1Label = new TextBox("SRB1", x + colOffset + (w/5)*4, label_y, labelTxt, labelBG, 12, h5, CENTER, TOP);

        createCustomCommandUI();

        createAllDropdowns(chanBar_h);
    }

    public void update() {
        boolean tfactive = customCommandTF.isFocus();
        if (tfactive) {
            textFieldIsActive = true;
        }

        textfieldUpdateHelper.checkTextfield(customCommandTF);
    }

    public void draw() {

        if (isVisible) {
            //Control button space above channels
            pushStyle();
            //stroke(OPENBCI_BLUE_ALPHA50);
            stroke(OBJECT_BORDER_GREY);
            fill(GREY_100);
            rect(x, y - columnLabelH, w, columnLabelH);
            popStyle();

            //background
            pushStyle();
            noStroke();
            fill(GREY_100);
            rect(x, y, w + 1, h);
            popStyle();

            gainLabel.draw();
            inputTypeLabel.draw();
            biasLabel.draw();
            srb2Label.draw();
            srb1Label.draw();

            for (int i = 0; i < channelCount; i++) {
                boolean b = activeChannels.contains(i);
                gainLists[i].setVisible(b);
                inputTypeLists[i].setVisible(b);
                biasLists[i].setVisible(b);
                srb2Lists[i].setVisible(b);
                srb1Lists[i].setVisible(b);

                if (hasUnappliedChanges[i]) {
                    pushStyle();
                    fill(color(57, 128, 204, 190)); //light blue from TopNav
                    //fill(color(245, 64, 64, 180)); //light red
                    rect(x, y + chanBar_h * i, w, chanBar_h);
                    popStyle();
                }
            }

            boolean showCustomCommandUI = guiSettings.getExpertModeBoolean();
            
            //Draw background behind command buttons
            pushStyle();
            fill(GREY_100);
            rect(x, y + h, w + 1, commandBarH);
            if (showCustomCommandUI) {
                rect(customCmdUI_x, y + h + commandBarH, customCmdUI_w, commandBarH); //keep above style for other command buttons
            }
            popStyle();

            customCommandTF.setVisible(showCustomCommandUI);
            sendCustomCmdButton.setVisible(showCustomCommandUI);
            
            //Draw cp5 objects on top of everything
            hwsCp5.draw();
        }
    }

    private void resizeDropdowns(int _channelBarHeight) {
        int dropdownX = 0;
        int dropdownY = 0;
        int dropdownW = PApplet.parseInt((w - (spaceBetweenButtons*6)) / 5);
        int dropdownH = 18;

        int rowCount = 0;
        for (int i : activeChannels) {
            dropdownX = x + spaceBetweenButtons;
            dropdownY = PApplet.parseInt(y + ((_channelBarHeight)*rowCount) + (((_channelBarHeight)-dropdownH)/2));
            final int buttonXIncrement = spaceBetweenButtons + dropdownW;

            gainLists[i].setPosition(dropdownX, dropdownY);
            gainLists[i].setSize(dropdownW,5*dropdownH); //Only enough space for SelectedItem + 4 options in the latter channels
            
            dropdownX += buttonXIncrement;
            inputTypeLists[i].setPosition(dropdownX, dropdownY);
            inputTypeLists[i].setSize(dropdownW,5*dropdownH); //Only enough space for SelectedItem + 4 options in the latter channels

            dropdownX += buttonXIncrement;
            biasLists[i].setPosition(dropdownX, dropdownY);
            biasLists[i].setSize(dropdownW,(biasLists[i].getItems().size()+1)*dropdownH);

            dropdownX += buttonXIncrement;
            srb2Lists[i].setPosition(dropdownX, dropdownY);
            srb2Lists[i].setSize(dropdownW,(srb2Lists[i].getItems().size()+1)*dropdownH);

            dropdownX += buttonXIncrement;
            srb1Lists[i].setPosition(dropdownX, dropdownY);
            srb1Lists[i].setSize(dropdownW,(srb1Lists[i].getItems().size()+1)*dropdownH);

            rowCount++;
        }
    }

    public void resize(int _x, int _y, int _w, int _h, int _channelBarHeight) {
        x = _x;
        y = _y;
        w = _w;
        h = _h;
        chanBar_h = _channelBarHeight;

        hwsCp5.setGraphics(_parentApplet, 0, 0);

        int colOffset = (w / numControlButtons) / 2;
        int button_y = y + h + padding_3;
        loadButton.setPosition(x + colOffset - button_w/2, button_y);
        saveButton.setPosition(x + colOffset + (w/numControlButtons) - button_w/2, button_y);
        sendButton.setPosition(x + colOffset + (w/numControlButtons)*2 - button_w/2, button_y);

        colOffset = (w / 5) / 2;
        int label_y = y - 14 - padding_3;
        gainLabel.setPosition(x + colOffset, label_y);
        inputTypeLabel.setPosition(x + colOffset + (w/5), label_y);
        biasLabel.setPosition(x + colOffset + (w/5)*2, label_y);
        srb2Label.setPosition(x + colOffset + (w/5)*3, label_y);
        srb1Label.setPosition(x + colOffset + (w/5)*4, label_y);

        resizeDropdowns(chanBar_h);

        resizeCustomCommandUI();
        
    }

    //Returns true if board and UI are in sync
    public boolean setIsVisible (boolean v) {
        
        //Check if there are unapplied settings when trying to close Hardware Settings Controller
        if (!v) {
            boolean allChannelsInSync = true;

            for (int i = 0; i < hasUnappliedChanges.length; i++) {
                if (hasUnappliedChanges[i]) {
                    allChannelsInSync = false;
                }
            }

            if (!allChannelsInSync) {
                PopupMessage msg = new PopupMessage("Info", "Highlighted channels have unapplied Hardware Settings. Please press \"Send\" button to sync with board or revert settings.");
                return false;
            }
        }

        isVisible = v;
        return true;
    }

    public boolean getIsVisible() {
        return isVisible;
    }

    private void createHWSettingsLoadButton(String name, String text, int _x, int _y, int _w, int _h) {
        loadButton = createButton(hwsCp5, name, text, _x, _y, _w, _h);
        loadButton.setBorderColor(OBJECT_BORDER_GREY);
        loadButton.setDescription("Load hardware settings from file.");
        loadButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (currentBoard.isStreaming()) {
                    PopupMessage msg = new PopupMessage("Info", "Streaming needs to be stopped before loading hardware settings.");
                } else {
                    selectInput("Select settings file to load", "loadHardwareSettings");
                }
            }
        });
    }

    private void createHWSettingsSaveButton(String name, String text, int _x, int _y, int _w, int _h) {
        saveButton = createButton(hwsCp5, name, text, _x, _y, _w, _h);
        saveButton.setBorderColor(OBJECT_BORDER_GREY);
        saveButton.setDescription("Save hardware settings to file.");
        saveButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                selectOutput("Save settings to file", "storeHardwareSettings");
            }
        });
    }

    private void createHWSettingsSendButton(String name, String text, int _x, int _y, int _w, int _h) {
        sendButton = createButton(hwsCp5, name, text, _x, _y, _w, _h);
        sendButton.setBorderColor(OBJECT_BORDER_GREY);
        sendButton.setDescription("Send hardware settings to the board.");
        sendButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {

                boolean noErrors = true;
                boolean atLeastOneChannelHasChanged = false;

                for (int i = 0; i < channelCount; i++) {
                    if (hasUnappliedChanges[i]) {
                        boolean sendCommandSuccess = ((ADS1299SettingsBoard)currentBoard).getADS1299Settings().commit(i);
                        if (!sendCommandSuccess) {
                            noErrors = false;
                        } else {
                            setHasUnappliedSettings(i, false);
                            atLeastOneChannelHasChanged = true;
                            boardSettings.saveLastValues(i);
                        }
                    }
                }

                if (!atLeastOneChannelHasChanged) {
                    output("No new settings to send to board.");
                } else if (noErrors) {
                    outputSuccess("Hardware Settings sent to board!");
                } else {
                    PopupMessage msg = new PopupMessage("Error", "Failed to send one or more Hardware Settings to board. Check hardware and battery level. Cyton users, check that your dongle is connected with blue light shining.");
                }         
            }
        });
    }

    private ScrollableList createDropdown(int chanNum, String name, ADSSettingsEnum[] enumValues, ADSSettingsEnum e, int _backgroundColor) {
        int dropdownW = PApplet.parseInt((w - (spaceBetweenButtons*6)) / 5);
        int dropdownH = 18;
        ScrollableList list = hwsCp5.addScrollableList(name)
            .setOpen(false)
            .setColorBackground(_backgroundColor) // text field bg color
            .setColorValueLabel(OPENBCI_DARKBLUE)       // text color
            .setColorCaptionLabel(OPENBCI_DARKBLUE)
            .setColorForeground(color(125))    // border color when not selected
            .setColorActive(BUTTON_PRESSED)       // border color when selected
            .setOutlineColor(OBJECT_BORDER_GREY)
            .setSize(dropdownW, dropdownH)//temporary size
            .setBarHeight(dropdownH) //height of top/primary bar
            .setItemHeight(dropdownH) //height of all item/dropdown bars
            .setVisible(true)
            ;
        // for each entry in the enum, add it to the dropdown.
        for (ADSSettingsEnum value : enumValues) {
            // this will store the *actual* enum object inside the dropdown!
            list.addItem(value.getName(), value);
        }
        //Style the text in the ScrollableList
        list.getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(e.getName())
            .setFont(h5)
            .setSize(12)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        list.getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(e.getName())
            .setFont(p6)
            .setSize(10) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
        list.addCallback(new SLCallbackListener(chanNum));
        return list;
    }

    private void createAllDropdowns(int _channelBarHeight) {
        //the size and space of these buttons are dependendant on the size of the screen and full ChannelController
        verbosePrint("ChannelController: createChannelSettingButtons: creating channel setting buttons...");

        gainLists = new ScrollableList[channelCount];
        inputTypeLists = new ScrollableList[channelCount];
        biasLists = new ScrollableList[channelCount];
        srb2Lists = new ScrollableList[channelCount];
        srb1Lists = new ScrollableList[channelCount];
        int _bgColor;

        //Init dropdowns in reverse so that chan 1 draws on top of chan 2, etc.
        for (int i = channelCount - 1; i >= 0; i--) {
            _bgColor = 0xFFFFFFFF;
            gainLists[i] = createDropdown(i, "gain_ch_"+(i+1), boardSettings.values.gain[i].values(), boardSettings.values.gain[i], _bgColor);
            
            _bgColor = 0xFFFFFFFF;
            inputTypeLists[i] = createDropdown(i, "inputType_ch_"+(i+1), boardSettings.values.inputType[i].values(), boardSettings.values.inputType[i], _bgColor);
            
            _bgColor = boardSettings.values.bias[i] == Bias.INCLUDE ? yesOnColor : noOffColor;
            biasLists[i] = createDropdown(i, "bias_ch_"+(i+1), boardSettings.values.bias[i].values(), boardSettings.values.bias[i], _bgColor);

            _bgColor = boardSettings.values.srb2[i] == Srb2.CONNECT ? yesOnColor : noOffColor;            
            srb2Lists[i] = createDropdown(i, "srb2_ch_"+(i+1), boardSettings.values.srb2[i].values(), boardSettings.values.srb2[i], _bgColor);

            _bgColor = boardSettings.values.srb1[i] == Srb1.CONNECT ? yesOnColor : noOffColor;           
            srb1Lists[i] = createDropdown(i, "srb1_ch_"+(i+1), boardSettings.values.srb1[i].values(), boardSettings.values.srb1[i], _bgColor);
        }

        resizeDropdowns(_channelBarHeight);
    }

    private void createCustomCommandUI() {
        customCommandTF = hwsCp5.addTextfield("customCommand")
            .setPosition(0, 0)
            .setCaptionLabel("")
            .setSize(120, 20)
            .setFont(f2)
            .setFocus(false)
            .setColor(color(26, 26, 26))
            .setColorBackground(color(255, 255, 255)) // text field bg color
            .setColorValueLabel(OPENBCI_DARKBLUE)  // text color
            .setColorForeground(OBJECT_BORDER_GREY)  // border color when not selected
            .setColorActive(isSelected_color)  // border color when selected
            .setColorCursor(color(26, 26, 26))
            .setText("")
            .align(5, 10, 20, 40)
            .setAutoClear(false) //Don't clear textfield when pressing Enter key
            ;
        customCommandTF.setDescription("Type a custom command and Send to board.");
        //Clear textfield on double click
        customCommandTF.onDoublePress(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                output("[ExpertMode] Enter the custom command you would like to send to the board.");
                customCommandTF.clear();
            }
        });
        customCommandTF.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if ((theEvent.getAction() == ControlP5.ACTION_BROADCAST) || (theEvent.getAction() == ControlP5.ACTION_LEAVE)) {
                    customCommandTF.setFocus(false);
                }
            }
        });

        sendCustomCmdButton = createButton(hwsCp5, "sendCustomCommand", "Send Custom Command", 0, 0, 10, 10);
        sendCustomCmdButton.setBorderColor(OBJECT_BORDER_GREY);
        sendCustomCmdButton.getCaptionLabel().getStyle().setMarginLeft(1);
        sendCustomCmdButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                String text = dropNonPrintableChars(customCommandTF.getText());
                Pair<Boolean, String> res = ((BoardBrainFlow)currentBoard).sendCommand(text);
                if (res.getKey().booleanValue()) {
                    outputSuccess("[ExpertMode] Success sending command to board: " + text);
                } else {
                    outputError("[ExpertMode] Failure sending command to board: " + text);
                }
                println("ADSSettingsController: Response == " + res.getValue());
            }
        });

        resizeCustomCommandUI();
    }

    public void resizeCustomCommandUI() {
        customCmdUI_x = x;
        customCmdUI_w = w + 1;
        int tf_w = Math.round(button_w * 1.8f);
        int but_w = tf_w;
        //customCmdUI_w = (int)Math.ceil(w * (2f/3f)) + 24;
        int tf_x = customCmdUI_x + Math.round(customCmdUI_w / 2f) - Math.round((tf_w + but_w + padding_3) / 2) + padding_3;
        int tf_y = y + h + commandBarH + padding_3;
        //int tf_w = Math.round((customCmdUI_w - padding_3*2) * .75);
        int tf_h = commandBarH - padding_3*2;
        customCommandTF.setPosition(tf_x, tf_y);
        customCommandTF.setWidth(tf_w);
        customCommandTF.setHeight(tf_h);
        int but_x = tf_x + customCommandTF.getWidth() + padding_3;
        sendCustomCmdButton.setPosition(but_x, tf_y);
        sendCustomCmdButton.setSize(but_w, tf_h - 1);
    }

    private void updateHasUnappliedSettings(int _channel) {
        hasUnappliedChanges[_channel] = !boardSettings.equalsLastValues(_channel);
    }

    public void updateHasUnappliedSettings() {
        for (int i : activeChannels) {
            updateHasUnappliedSettings(i);
        }
    }

    public void setHasUnappliedSettings(int _channel, boolean b) {
        hasUnappliedChanges[_channel] = b;
    }

    public void updateChanSettingsDropdowns(int chan, boolean isActive) {
        int darkNotActive = color(57);
        int c = isActive ? color(255) : darkNotActive;

        gainLists[chan].setValue(boardSettings.values.gain[chan].ordinal());
        gainLists[chan].setColorBackground(c);
        gainLists[chan].setLock(!isActive);

        inputTypeLists[chan].setValue(boardSettings.values.inputType[chan].ordinal());
        inputTypeLists[chan].setColorBackground(c);
        inputTypeLists[chan].setLock(!isActive);

        c = isActive ? (boardSettings.values.bias[chan] == Bias.INCLUDE ? yesOnColor : noOffColor) : darkNotActive;
        biasLists[chan].setValue(boardSettings.values.bias[chan].ordinal());
        biasLists[chan].setColorBackground(c);
        biasLists[chan].setLock(!isActive);

        c = isActive ? (boardSettings.values.srb2[chan] == Srb2.CONNECT ? yesOnColor : noOffColor) : darkNotActive; 
        srb2Lists[chan].setValue(boardSettings.values.srb2[chan].ordinal());
        srb2Lists[chan].setColorBackground(c);
        srb2Lists[chan].setLock(!isActive);

        c = isActive ? (boardSettings.values.srb1[chan] == Srb1.CONNECT ? yesOnColor : noOffColor) : darkNotActive;   
        srb1Lists[chan].setValue(boardSettings.values.srb1[chan].ordinal());
        srb1Lists[chan].setColorBackground(c);
        srb1Lists[chan].setLock(!isActive);  
    }

    public void updateAllChanSettingsDropdowns() {
        for (int i = 0; i < currentBoard.getNumEXGChannels(); i++) {
            updateChanSettingsDropdowns(i, currentBoard.isEXGChannelActive(i));
            setHasUnappliedSettings(i, false);
        }
    }

    private class SLCallbackListener implements CallbackListener {
        private int channel;
    
        SLCallbackListener(int _i)  {
            channel = _i;
        }
        public void controlEvent(CallbackEvent theEvent) {
            int _bgColor = 0xFFFFFFFF;
            //Selecting an item from ScrollableList triggers Broadcast
            if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) { 
                int val = (int)(theEvent.getController()).getValue();
                Map bob = ((ScrollableList)theEvent.getController()).getItem(val);
                ADSSettingsEnum myEnum = (ADSSettingsEnum)bob.get("value");
                verbosePrint("HardwareSettings: " + (theEvent.getController()).getName() + " == " + myEnum.getName());

                if (myEnum instanceof Gain) {
                    //verbosePrint("HardwareSettings: previousVal == " + boardSettings.previousValues.gain[channel]);
                    boardSettings.values.gain[channel] = (Gain)myEnum;
                } else if (myEnum instanceof InputType) {
                    boardSettings.values.inputType[channel] = (InputType)myEnum;
                } else if (myEnum instanceof Bias) {
                    boardSettings.values.bias[channel] = (Bias)myEnum;
                    _bgColor = (Bias)myEnum == Bias.INCLUDE ? yesOnColor : noOffColor;
                    (theEvent.getController()).setColorBackground(_bgColor);
                } else if (myEnum instanceof Srb2) {
                    boardSettings.values.srb2[channel] = (Srb2)myEnum;
                    _bgColor = (Srb2)myEnum == Srb2.CONNECT ? yesOnColor : noOffColor;
                    (theEvent.getController()).setColorBackground(_bgColor);
                } else if (myEnum instanceof Srb1) {
                    boardSettings.values.srb1[channel] = (Srb1)myEnum;
                    _bgColor = (Srb1)myEnum == Srb1.CONNECT ? yesOnColor : noOffColor;
                    (theEvent.getController()).setColorBackground(_bgColor);
                }

                updateHasUnappliedSettings(channel);
            }
        }
    }
};

public void loadHardwareSettings(File selection) {
    if (selection == null) {
        output("Hardware Settings file not selected.");
    } else {
        if (currentBoard instanceof ADS1299SettingsBoard) {
            if (((ADS1299SettingsBoard)currentBoard).getADS1299Settings().loadSettingsValues(selection.getAbsolutePath())) {
                outputSuccess("Hardware Settings Loaded!");
                for (int i = 0; i < nchan; i++) {
                    w_timeSeries.adsSettingsController.updateChanSettingsDropdowns(i, currentBoard.isEXGChannelActive(i));
                    w_timeSeries.adsSettingsController.updateHasUnappliedSettings(i);
                }
            } else {
                outputError("Failed to load Hardware Settings.");
            }
        }
    }
}

public void storeHardwareSettings(File selection) {
    if (selection == null) {
        output("Hardware Settings file not selected.");
    } else {
        if (currentBoard instanceof ADS1299SettingsBoard) {
            if (((ADS1299SettingsBoard)currentBoard).getADS1299Settings().saveToFile(selection.getAbsolutePath())) {
                outputSuccess("Hardware Settings Saved!");
            } else {
                outputError("Failed to save Hardware Settings.");
            }
        }
    }
}

interface AccelerometerCapableBoard {

    public boolean isAccelerometerActive();

    public void setAccelerometerActive(boolean active);

    public boolean canDeactivateAccelerometer();

    public int[] getAccelerometerChannels();

    public List<double[]> getDataWithAccel(int maxSamples);

    public int getAccelSampleRate();
};

interface AnalogCapableBoard {

    public boolean isAnalogActive();

    public void setAnalogActive(boolean active);

    public boolean canDeactivateAnalog();

    public int[] getAnalogChannels();

    public List<double[]> getDataWithAnalog(int maxSamples);

    public int getAnalogSampleRate();
};
//Used in the Focus Widget to provide auditory neurofeedback
//Adjust amplitude of calming audio samples using normalized band power data or predicted metric

Minim minim;
FilePlayer[] auditoryNfbFilePlayers;
ddf.minim.ugens.Gain[] auditoryNfbGains;
AudioOutput audioOutput;
boolean audioOutputIsAvailable;

//Pre-load audio files into memory in delayedSetup for best app performance and no waiting
public void asyncLoadAudioFiles() {
    final int _numSoundFiles = 5;
    minim = new Minim(this);
    auditoryNfbFilePlayers = new FilePlayer[_numSoundFiles];
    auditoryNfbGains = new ddf.minim.ugens.Gain[_numSoundFiles];
    audioOutput = minim.getLineOut();
    println("OpenBCI_GUI: AuditoryFeedback: Loading Audio...");
    for (int i = 0; i < _numSoundFiles; i++) {
        //Use large buffer size and cache files in memory
        try {
            auditoryNfbFilePlayers[i] = new FilePlayer( minim.loadFileStream("bp" + (i+1) + ".mp3", 2048, true) );
            auditoryNfbGains[i] = new ddf.minim.ugens.Gain(-15.0f);
            auditoryNfbFilePlayers[i].patch(auditoryNfbGains[i]).patch(audioOutput);
        } catch (Exception e) {
            outputError("AuditoryFeedback: Unable to load audio files. To enable this feature, please connect or turn on an audio device and restart the GUI.");
            audioOutputIsAvailable = false;
            return;
        }
    }
    println("OpenBCI_GUI: AuditoryFeedback: Done Loading Audio!");
    audioOutputIsAvailable = true;
}

class AuditoryNeurofeedback {

    private int x, y, w, h;
    private ControlP5 localCP5;
    public Button startStopButton;
    public Button modeButton;
    private boolean usingBandPowers = false;
    //There will always be 5 band powers, and 5 possible concurrent audio files for playback
    private final int NUM_SOUND_FILES = auditoryNfbFilePlayers.length;
    private final float MIN_GAIN = -42.0f;
    private final float MAX_GAIN = -7.0f;
    private final int MAX_BUTTON_W = 120;
    private int buttonW = 120;
    private int buttonH;

    AuditoryNeurofeedback(int _x, int _y, int _w, int _h) {
        localCP5 = new ControlP5(ourApplet);
        localCP5.setGraphics(ourApplet, 0,0);
        localCP5.setAutoDraw(false);
        buttonH = _h;
        createStartStopButton(_x, _y, buttonW, buttonH);
        createModeButton(_x, _y, buttonW, buttonH);
    }

    //Use band powers or prediction value to control volume of each sound file
    public void update(double[] bandPowers, float predictionVal) {
        if (usingBandPowers) {
            for (int i = 0; i < NUM_SOUND_FILES; i++) {
                float gain = map((float)bandPowers[i], 0.1f, .7f, MIN_GAIN + 20f, MAX_GAIN);
                auditoryNfbGains[i].setValue(gain);
            }
        } else {
            float gain = map(predictionVal, 0.0f, 1.0f, MIN_GAIN, MAX_GAIN);
            for (int i = 0; i < NUM_SOUND_FILES; i++) {
                auditoryNfbGains[i].setValue(gain);
            }
        }
    }

    public void draw() {
        localCP5.draw();
    }

    public void screenResized(int _x, int _y, int _w, int _h) {
        localCP5.setGraphics(ourApplet, 0, 0);
        buttonW = (_w - 6) / 2;
        buttonW = buttonW > MAX_BUTTON_W ? MAX_BUTTON_W : buttonW;
        startStopButton.setPosition(_x - buttonW - 3, _y);
        startStopButton.setSize(buttonW, _h);
        modeButton.setPosition(_x + 3, _y);
        modeButton.setSize(buttonW, _h);
    }

    public void killAudio() {
        for (int i = 0; i < NUM_SOUND_FILES; i++) {
            auditoryNfbFilePlayers[i].pause();
            auditoryNfbFilePlayers[i].rewind();
        }
    }

    private void createStartStopButton(int _x, int _y, int _w, int _h) {
        //This is a generalized createButton method that allows us to save code by using a few patterns and method overloading
        startStopButton = createButton(localCP5, "startStopButton", "Turn Audio On", _x, _y, _w, _h, p5, 12, colorNotPressed, OPENBCI_DARKBLUE);
        //Set the border color explicitely
        startStopButton.setBorderColor(OBJECT_BORDER_GREY);
        //For this button, only call the callback listener on mouse release
        startStopButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (!audioOutputIsAvailable) {
                    outputError("AuditoryFeedback: Unable to load audio files. To enable this feature, please connect or turn on an audio device and restart the GUI.");
                    return;
                }
                //If using a TopNav object, ignore interaction with widget object (ex. widgetTemplateButton)
                if (!topNav.configSelector.isVisible && !topNav.layoutSelector.isVisible) {
                    if (auditoryNfbFilePlayers[0].isPlaying()) {
                        killAudio();
                        startStopButton.getCaptionLabel().setText("Turn Audio On");
                    } else {
                        for (int i = 0; i < NUM_SOUND_FILES; i++) {
                            auditoryNfbFilePlayers[i].loop();
                        }
                        startStopButton.getCaptionLabel().setText("Turn Audio Off");
                    }
                }
            }
        });
        startStopButton.setDescription("Start and Stop Auditory Feedback.");
    }

    private void createModeButton(int _x, int _y, int _w, int _h) {
        //This is a generalized createButton method that allows us to save code by using a few patterns and method overloading
        modeButton = createButton(localCP5, "modeButton", "Use Band Powers", _x, _y, _w, _h, p5, 12, colorNotPressed, OPENBCI_DARKBLUE);
        //Set the border color explicitely
        modeButton.setBorderColor(OBJECT_BORDER_GREY);
        //For this button, only call the callback listener on mouse release
        modeButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                //If using a TopNav object, ignore interaction with widget object (ex. widgetTemplateButton)
                if (!topNav.configSelector.isVisible && !topNav.layoutSelector.isVisible) {
                    String s = !usingBandPowers ? "Use Metric" : "Use Band Powers";
                    modeButton.getCaptionLabel().setText(s);
                    usingBandPowers = !usingBandPowers;
                }
            }
        });
        modeButton.setDescription("Change Auditory Feedback mode. Use the Metric to control all notes at once, or use Band Powers to control certain notes of the chord.");
    }

}

interface AuxDataBoard {

    public List<double[]> getAuxData(int maxSamples);

    public String[] getAuxChannelNames();

    public double[][] getAuxFrameData();

    public int getAuxSampleRate();

    public int getNumAuxChannels();

    public int getAuxTimestampChannel();
};


abstract class Board implements DataSource {

    private FixedStack<double[]> accumulatedData = new FixedStack<double[]>();
    private double[][] dataThisFrame;
    protected PacketLossTracker packetLossTracker;

    // accessible by all boards, can be returned as valid empty data
    protected double[][] emptyData;

    @Override
    public boolean initialize() {
        boolean res = initializeInternal();

        double[] fillData = new double[getTotalChannelCount()];
        accumulatedData.setSize(getCurrentBoardBufferSize());
        accumulatedData.fill(fillData);

        emptyData = new double[getTotalChannelCount()][0];

        packetLossTracker = setupPacketLossTracker();

        return res;
    }

    @Override
    public void uninitialize() {
        uninitializeInternal();
    }

    @Override
    public void startStreaming() {
        packetLossTracker.onStreamStart();
    }

    @Override
    public void stopStreaming() {
        
        // empty
    }

    @Override
    public void update() {
        updateInternal();

        dataThisFrame = getNewDataInternal();

        for (int i = 0; i < dataThisFrame[0].length; i++) {
            double[] newEntry = new double[getTotalChannelCount()];
            for (int j = 0; j < getTotalChannelCount(); j++) {
                newEntry[j] = dataThisFrame[j][i];
            }

            accumulatedData.push(newEntry);
        }

        if( packetLossTracker != null) {
            //TODO: make all API including getNewDataInternal() return List<double[]> 
            // and we can just pass dataThisFrame here.
            packetLossTracker.addSamples(getData(dataThisFrame[0].length));
        }
    }

    @Override
    public int getNumEXGChannels() {
        return getEXGChannels().length;
    }

    // returns all the data this board has received in this frame
    @Override
    public double[][] getFrameData() {
        return dataThisFrame;
    }

    @Override
    public List<double[]> getData(int maxSamples) {
        int endIndex = accumulatedData.size();
        int startIndex = max(0, endIndex - maxSamples);

        return accumulatedData.subList(startIndex, endIndex);
    }

    public String[] getChannelNames() {
        String[] names = new String[getTotalChannelCount()];
        Arrays.fill(names, "Other");

        names[getTimestampChannel()] = "Timestamp";
        names[getSampleIndexChannel()] = "Sample Index";

        int[] exgChannels = getEXGChannels();
        for (int i=0; i<exgChannels.length; i++) {
            names[exgChannels[i]] = "EXG Channel " + i;
        }

        addChannelNamesInternal(names);
        return names;
    }

    public PacketLossTracker getPacketLossTracker() {
        return packetLossTracker;
    }

    public abstract boolean isConnected();

    public abstract boolean isStreaming();

    public abstract Pair <Boolean, String> sendCommand(String command);

    // ***************************************
    // protected methods implemented by board

    // implemented by each board class and used internally here to accumulate the FixedStack
    // and provide with public interfaces getFrameData() and getData(int)
    protected abstract double[][] getNewDataInternal();

    protected abstract boolean initializeInternal();

    protected abstract void uninitializeInternal();

    protected abstract void updateInternal();

    protected abstract void addChannelNamesInternal(String[] channelNames);

    protected abstract PacketLossTracker setupPacketLossTracker();
};




public enum BrainFlowStreaming_Boards
{
    CYTON("Cyton", BoardIds.CYTON_BOARD),
    CYTONDAISY("CytonDaisy", BoardIds.CYTON_DAISY_BOARD),
    GANGLION("Ganglion", BoardIds.GANGLION_BOARD),
    SYNTHETIC("Synthetic", BoardIds.SYNTHETIC_BOARD);

    private String name;
    private BoardIds boardId;
 
    BrainFlowStreaming_Boards(String _name, BoardIds _boardId) {
        this.name = _name;
        this.boardId = _boardId;
    }
 
    public String getName() {
        return name;
    }

    public BoardIds getBoardId() {
        return boardId;
    }
}

class BoardBrainFlowStreaming extends BoardBrainFlow {

    private BoardIds masterBoardId;
    private String ipAddress;
    private int ipPort;

    public BoardBrainFlowStreaming(BoardIds masterBoardId, String ipAddress, int ipPort) {
        super();
        this.masterBoardId = masterBoardId;
        this.ipAddress = ipAddress;
        this.ipPort = ipPort;
    }

    // implement mandatory abstract functions
    @Override
    protected BrainFlowInputParams getParams() {
        BrainFlowInputParams params = new BrainFlowInputParams();
        params.ip_address = ipAddress;
        params.ip_port = ipPort;
        params.master_board = masterBoardId.get_code();
        return params;
    }

    // for streaming board need to use master board id in function like  get_eeg_channels
    @Override
    public BoardIds getBoardId() {
        return masterBoardId;
    }

    @Override
    public boolean initializeInternal() {
        try {
            // here we need to provide board id of streaming board
            boardShim = new BoardShim (BoardIds.STREAMING_BOARD.get_code(), getParams());
            try {
                BoardShim.enable_dev_board_logger();
                BoardShim.set_log_file(directoryManager.getConsoleDataPath() + "Brainflow_" +
                    directoryManager.getFileNameDateTime() + ".txt");
            } catch (BrainFlowError e) {
                e.printStackTrace();
            }
            boardShim.prepare_session();
            return true; 

        } catch (Exception e) {
            boardShim = null;
            outputError("ERROR: " + e + " when initializing Brainflow board. Data will not stream.");
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public void setEXGChannelActive(int channelIndex, boolean active) {
        // do nothing here
    }

    @Override
    public boolean isEXGChannelActive(int channelIndex) {
        return true;
    }

    @Override
    protected void addChannelNamesInternal(String[] channelNames) {
        // do nothing here
    }

    @Override
    protected PacketLossTracker setupPacketLossTracker() {
        if (masterBoardId == BoardIds.CYTON_DAISY_BOARD) {
                return new PacketLossTrackerCytonSerialDaisy(getSampleIndexChannel(), getTimestampChannel());
        }
        final int minSampleIndex = 0;
        final int maxSampleIndex = 255;
        return new PacketLossTracker(getSampleIndexChannel(), getTimestampChannel(),
                                    minSampleIndex, maxSampleIndex);
    }

};




class BoardBrainFlowSynthetic extends BoardBrainFlow implements AccelerometerCapableBoard {

    private int[] accelChannelsCache = null;
    private int numChannels = 0;
    private volatile boolean[] activeChannels = null;

    public BoardBrainFlowSynthetic(int numChannels) {
        super();
        this.numChannels = numChannels;
        activeChannels = new boolean[numChannels];
        for (int i = 0; i < numChannels; i++) {
            activeChannels[i] = true;
        }
    }

    // implement mandatory abstract functions
    @Override
    protected BrainFlowInputParams getParams() {
        BrainFlowInputParams params = new BrainFlowInputParams();
        return params;
    }

    @Override
    public BoardIds getBoardId() {
        return BoardIds.SYNTHETIC_BOARD;
    }

    @Override
    public int[] getEXGChannels() {
        int[] channels = super.getEXGChannels();
        int[] res = new int[numChannels];
        for (int i = 0; i < numChannels; i++)
        {
            res[i] = channels[i];
        }
        return res;
    }

    @Override
    public void setEXGChannelActive(int channelIndex, boolean active) {
        activeChannels[channelIndex] = active;
    }

    @Override
    public boolean isEXGChannelActive(int channelIndex) {
        return activeChannels[channelIndex];
    }

    @Override
    protected double[][] getNewDataInternal() {
        double[][] data = super.getNewDataInternal();
        int[] exgChannels = getEXGChannels();
        for (int i = 0; i < numChannels; i++) {
            if (!activeChannels[i]) {
                for (int j = 0; j < data[exgChannels[i]].length; j++) {
                    data[exgChannels[i]][j] = 0.0f;
                }
            }
        }
        return data;
    }

    @Override
    public boolean isAccelerometerActive() {
        return true;
    }

    @Override
    public void setAccelerometerActive(boolean active) {
        outputWarn("Accelerometer is always active for BrainflowSyntheticBoard");
    }

    @Override
    public boolean canDeactivateAccelerometer() {
        return false;
    }

    @Override
    public int[] getAccelerometerChannels() {
        if (accelChannelsCache == null) {
            try {
                accelChannelsCache = BoardShim.get_accel_channels(getBoardIdInt());

            } catch (BrainFlowError e) {
                e.printStackTrace();
            }
        }

        return accelChannelsCache;
    }

    
    @Override
    protected void addChannelNamesInternal(String[] channelNames) {
        for (int i=0; i<getAccelerometerChannels().length; i++) {
            channelNames[getAccelerometerChannels()[i]] = "Accel Channel " + i;
        }
    }

    @Override
    protected PacketLossTracker setupPacketLossTracker() {
        final int minSampleIndex = 0;
        final int maxSampleIndex = 255;
        return new PacketLossTracker(getSampleIndexChannel(), getTimestampChannel(),
                                    minSampleIndex, maxSampleIndex);
    }

    @Override
    public List<double[]> getDataWithAccel(int maxSamples) {
        return getData(maxSamples);
    }

    @Override
    public int getAccelSampleRate() {
        return getSampleRate();
    }
};







abstract class BoardBrainFlow extends Board {

    protected BoardShim boardShim = null;
    protected int samplingRateCache = -1;
    protected int sampleIndexChannelCache = -1;
    protected int timeStampChannelCache = -1;
    protected int totalChannelsCache = -1;
    protected int[] exgChannelsCache = null;
    protected int[] otherChannelsCache = null;

    protected boolean streaming = false;
    protected double time_last_datapoint = -1.0f;
    protected boolean data_popup_displayed = false;

    /* Abstract Functions.
     * Implement these in your board.
     */
    abstract protected BrainFlowInputParams getParams();
    abstract public BoardIds getBoardId();
    
    @Override
    public boolean initializeInternal() {
        try {
            boardShim = new BoardShim (getBoardIdInt(), getParams());
            try {
                BoardShim.enable_dev_board_logger();
                BoardShim.set_log_file(directoryManager.getConsoleDataPath() + "Brainflow_" +
                    directoryManager.getFileNameDateTime() + ".txt");
            } catch (BrainFlowError e) {
                e.printStackTrace();
            }
            boardShim.prepare_session();
            if (brainflowStreamer != "")
                boardShim.add_streamer(brainflowStreamer);
            return true; 

        } catch (Exception e) {
            boardShim = null;
            outputError("ERROR: " + e + " when initializing Brainflow board. Data will not stream.");
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public void uninitializeInternal() {
        if(isConnected()) {
            try {
                boardShim.release_session();
            } catch (BrainFlowError e) {
                println("WARNING: could not release brainflow board.");
                e.printStackTrace();
            }
        }
    }

    @Override
    public void updateInternal() {
        // empty
    }

    @Override
    public void startStreaming() {
        super.startStreaming();

        println("Brainflow start streaming");
        if(streaming) {
            println("Already streaming, do nothing");
            return;
        }

        try {
            boardShim.start_stream (450000);
            streaming = true;
        }
        catch (BrainFlowError e) {
            println("ERROR: Exception when starting stream");
            e.printStackTrace();
            streaming = false;
        }
    }

    @Override
    public void stopStreaming() {
        super.stopStreaming();
        
        println("Brainflow stop streaming");
        if(!streaming) {
            println("Already stopped streaming, do nothing");
            return;
        }
        try {
            boardShim.stop_stream();
            streaming = false;
            time_last_datapoint = -1.0f;
        }
        catch (BrainFlowError e) {
            println("ERROR: Exception when stoppping stream");
            e.printStackTrace();
            streaming = true;
        }

        if (eegDataSource != DATASOURCE_PLAYBACKFILE && eegDataSource != DATASOURCE_STREAMING) {
            dataLogger.fileWriterBF.incrementBrainFlowStreamerFileNumber();
        }
    }

    @Override
    public boolean isConnected() {
        if (boardShim != null) {
            try {
                return boardShim.is_prepared();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return false;
    }

    @Override
    public boolean isStreaming() {
        return streaming;
    }

    @Override
    public int getSampleRate() {
        if(samplingRateCache < 0) {
            try {
                samplingRateCache = BoardShim.get_sampling_rate(getBoardIdInt());
            } catch (BrainFlowError e) {
                println("WARNING: failed to get sample rate from BoardShim");
                e.printStackTrace();
            }
        }

        return samplingRateCache;
    }

    @Override
    public int[] getEXGChannels() {
        if(exgChannelsCache == null) {
            int[] channels;
            // for some boards there can be duplicates
            SortedSet<Integer> set = new TreeSet<Integer>();
            // maybe it will be nice to add method like get_exg_channels to brainflow to avoid this ugly code?
            // but I doubt that smth else will need it and in python I know how to implement it better using existing API
            try {
                channels = BoardShim.get_eeg_channels(getBoardIdInt());
                for(int i = 0; i < channels.length; i++) {
                    set.add(channels[i]);
                }
            } catch (BrainFlowError e) {
                println("WARNING: failed to get eeg channels from BoardShim");
            }
            try {
                channels = BoardShim.get_emg_channels(getBoardIdInt());
                for(int i = 0; i < channels.length; i++) {
                    set.add(channels[i]);
                }
            } catch (BrainFlowError e) {
                println("WARNING: failed to get emg channels from BoardShim");
            }
            try {
                channels = BoardShim.get_ecg_channels(getBoardIdInt());
                for(int i = 0; i < channels.length; i++) {
                    set.add(channels[i]);
                }
            } catch (BrainFlowError e) {
                println("WARNING: failed to get ecg channels from BoardShim");
            }
            try {
                channels = BoardShim.get_eog_channels(getBoardIdInt());
                for(int i = 0; i < channels.length; i++) {
                    set.add(channels[i]);
                }
            } catch (BrainFlowError e) {
                println("WARNING: failed to get eog channels from BoardShim");
            }
            Integer[] toArray = set.toArray(new Integer[set.size()]);
            exgChannelsCache = new int[toArray.length];
            for (int i = 0; i < toArray.length; i++) {
                exgChannelsCache[i] = toArray[i].intValue();
            }
        }

        return exgChannelsCache;
    }

    @Override
    public int getTimestampChannel() {
        if(timeStampChannelCache < 0) {
            try {
                timeStampChannelCache = BoardShim.get_timestamp_channel(getBoardIdInt());
            } catch (BrainFlowError e) {
                println("WARNING: failed to get timestamp channel from BoardShim");
                e.printStackTrace();
            }
        }

        return timeStampChannelCache;
    }
    
    @Override
    public int getSampleIndexChannel() {
        if(sampleIndexChannelCache < 0) {
            try {
                sampleIndexChannelCache = BoardShim.get_package_num_channel(getBoardIdInt());
            } catch (BrainFlowError e) {
                println("WARNING: failed to get package num channel from BoardShim");
                e.printStackTrace();
            }
        }

        return sampleIndexChannelCache;
    }

    public int getBoardIdInt() {
        return getBoardId().get_code();
    }

    @Override
    public Pair<Boolean, String> sendCommand(String command) {
        if (command != null && isConnected()) {
            try {
                println("Sending config string to board: " + command);
                String resp = boardShim.config_board(command);
                return new ImmutablePair<Boolean, String>(Boolean.valueOf(true), resp);
            }
            catch (BrainFlowError e) {
                outputError("ERROR: " + e + " when sending command: " + command);
                e.printStackTrace();
                return new ImmutablePair<Boolean, String>(Boolean.valueOf(false), "");
            }
        }
        return new ImmutablePair<Boolean, String>(Boolean.valueOf(false), "");
    }
    
    @Override
    protected double[][] getNewDataInternal() {
        if(streaming) {
            try {
                double[][] data = boardShim.get_board_data();
                if ((data[0].length == 0) && (time_last_datapoint > 0)) {
                    double cur_time = System.currentTimeMillis() / 1000L;
                    double timeout = 5.0f;
                    if (cur_time - time_last_datapoint > timeout) {
                        if (data_popup_displayed == false) {
                            PopupMessage msg = new PopupMessage("Data Streaming Error",
                                "No new data received in " + timeout + " seconds. Please check your device and restart a GUI session.");
                        }
                        outputError("Data Streaming Error: No new data received in " + timeout + " seconds. Please check your device and restart a GUI session.");
                        data_popup_displayed = true;
                        stopRunning();
                        topNav.resetStartStopButton();
                    }
                } else {
                    time_last_datapoint = System.currentTimeMillis() / 1000L;
                    data_popup_displayed = false;
                }
                return data;
            } catch (BrainFlowError e) {
                println("WARNING: could not get board data.");
                e.printStackTrace();
            }
        }
    
        return emptyData;
    }

    @Override
    public int getTotalChannelCount() {
        if(totalChannelsCache < 0) {
            try {
                totalChannelsCache = BoardShim.get_num_rows(getBoardIdInt());
            } catch (BrainFlowError e) {
                println("WARNING: failed to get num rows from BoardShim");
                e.printStackTrace();
            }
        }

        return totalChannelsCache;
    }

    protected int[] getOtherChannels() {
        if (otherChannelsCache == null) {
            try {
                otherChannelsCache = BoardShim.get_other_channels(getBoardIdInt());
            } catch (BrainFlowError e) {
                e.printStackTrace();
            }
        }

        return otherChannelsCache;
    }
};



enum CytonBoardMode {
    DEFAULT(0),
    DEBUG(1),
    ANALOG(2),
    DIGITAL(3),
    MARKER(4);

    private final int value;
    CytonBoardMode(final int newValue) {
        value = newValue;
    }
    public int getValue() { return value; }
}

public enum CytonSDMode {
    NO_WRITE("Do not write to SD...", null),
    MAX_5MIN("5 minute maximum", "A"),
    MAX_15MIN("15 minute maximum", "S"),
    MAX_30MIN("30 minute maximum", "F"),
    MAX_1HR("1 hour maximum", "G"),
    MAX_2HR("2 hour maximum", "H"),
    MAX_4HR("4 hour maximum", "J"),
    MAX_12HR("12 hour maximum", "K"),
    MAX_24HR("24 hour maximum", "L");

    private String name;
    private String command;

    CytonSDMode(String _name, String _command) {
        this.name = _name;
        this.command = _command;
    }

    public String getName() {
        return name;
    }

    public String getCommand() {
        return command;
    }
}

static class BoardCytonConstants {
    static final float series_resistor_ohms = 2200; // Ohms. There is a series resistor on the 32 bit board.
    static final float ADS1299_Vref = 4.5f;  //reference voltage for ADC in ADS1299.  set by its hardware
    static final float ADS1299_gain = 24.f;  //assumed gain setting for ADS1299.  set by its Arduino code
    static final float scale_fac_uVolts_per_count = ADS1299_Vref / ((float)(pow(2, 23)-1)) / ADS1299_gain  * 1000000.f; //ADS1299 datasheet Table 7, confirmed through experiment
    static final float leadOffDrive_amps = 6.0e-9f;  //6 nA, set by its Arduino code
    static final float accelScale = 0.002f / (pow (2, 4));
}

class BoardCytonSerial extends BoardCytonSerialBase {
    public BoardCytonSerial() {
        super();
    }

    public BoardCytonSerial(String serialPort) {
        super();
        this.serialPort = serialPort;
    }

    @Override
    public BoardIds getBoardId() {
        return BoardIds.CYTON_BOARD;
    }

    @Override
    protected PacketLossTracker setupPacketLossTracker() {
        final int minSampleIndex = 0;
        final int maxSampleIndex = 255;
        return new PacketLossTracker(getSampleIndexChannel(), getTimestampChannel(),
                                    minSampleIndex, maxSampleIndex);
    }
};

class BoardCytonSerialDaisy extends BoardCytonSerialBase {
    public BoardCytonSerialDaisy() {
        super();
    }

    public BoardCytonSerialDaisy(String serialPort) {
        super();
        this.serialPort = serialPort;
    }

    @Override
    public BoardIds getBoardId() {
        return BoardIds.CYTON_DAISY_BOARD;
    }

    @Override
    protected PacketLossTracker setupPacketLossTracker() {
        return new PacketLossTrackerCytonSerialDaisy(getSampleIndexChannel(), getTimestampChannel());
    }
};

abstract class BoardCytonSerialBase extends BoardCyton implements SmoothingCapableBoard{

    private Buffer<double[]> buffer = null;
    private volatile boolean smoothData;

    public BoardCytonSerialBase() {
        super();
        setSmoothingActive(true);
    }

    // synchronized is important to ensure that we dont free buffers during getting data
    @Override
    public synchronized void setSmoothingActive(boolean active) {
        if (smoothData == active) {
            return;
        }
        // dont touch accumulatedData buffer to dont pause streaming
        if (active) {
            buffer = new Buffer<double[]>(getSampleRate());
        } else {
            buffer = null;
        }
        smoothData = active;
    }

    @Override
    public boolean getSmoothingActive() {
        return smoothData;
    }

    @Override
    protected synchronized double[][] getNewDataInternal() {
        double[][] data = super.getNewDataInternal();
        if (!smoothData) {
            return data;
        }
        // transpose to push to buffer
        for (int i = 0; i < data[0].length; i++) {
            double[] newEntry = new double[getTotalChannelCount()];
            for (int j = 0; j < getTotalChannelCount(); j++) {
                newEntry[j] = data[j][i];
            }
            buffer.addNewEntry(newEntry);
        }
        int numData = buffer.getDataCount();
        if (numData == 0) {
            return emptyData;
        }
        // transpose back
        double[][] res = new double[getTotalChannelCount()][numData];
        for (int i = 0; i < numData; i++) {
            double[] curData = buffer.popFirstEntry();
            for (int j = 0; j < getTotalChannelCount(); j++) {
                res[j][i] = curData[j];
            }
        }
        return res;
    }

};

class BoardCytonWifi extends BoardCytonWifiBase {
    public BoardCytonWifi() {
        super();
    }
    public BoardCytonWifi(String ipAddress, int samplingRate) {
        super(samplingRate);
        this.ipAddress = ipAddress;
    }

    @Override
    public BoardIds getBoardId() {
        return BoardIds.CYTON_WIFI_BOARD;
    }
};

class BoardCytonWifiDaisy extends BoardCytonWifiBase {
    public BoardCytonWifiDaisy() {
        super();
    }
    public BoardCytonWifiDaisy(String ipAddress, int samplingRate) {
        super(samplingRate);
        this.ipAddress = ipAddress;
    }

    @Override
    public BoardIds getBoardId() {
        return BoardIds.CYTON_DAISY_WIFI_BOARD;
    }
};

abstract class BoardCytonWifiBase extends BoardCyton {
    // https://docs.openbci.com/docs/02Cyton/CytonSDK#sample-rate
    private Map<Integer, String> samplingRateCommands = new HashMap<Integer, String>() {{
        put(16000, "~0");
        put(8000, "~1");
        put(4000, "~2");
        put(2000, "~3");
        put(1000, "~4");
        put(500, "~5");
        put(250, "~6");
    }};

    public BoardCytonWifiBase() {
        super();
    }

    public BoardCytonWifiBase(int samplingRate) {
        super();
        samplingRateCache = samplingRate;
    }

    @Override
    public boolean initializeInternal() {
        boolean res = super.initializeInternal();

        if ((res) && (samplingRateCache > 0)){
            String command = samplingRateCommands.get(samplingRateCache);
            sendCommand(command);
        }
        return res;
    }

    @Override
    protected PacketLossTracker setupPacketLossTracker() {
        final int minSampleIndex = 0;
        final int maxSampleIndex = 255;
        return new PacketLossTracker(getSampleIndexChannel(), getTimestampChannel(),
                                    minSampleIndex, maxSampleIndex);
    }
};

class CytonDefaultSettings extends ADS1299Settings {
    CytonDefaultSettings(Board theBoard) {
        super(theBoard);

        // the 'd' command is automatically sent by brainflow on prepare_session
        Arrays.fill(values.powerDown, PowerDown.ON);
        Arrays.fill(values.gain, Gain.X24);
        Arrays.fill(values.inputType, InputType.NORMAL);
        Arrays.fill(values.bias, Bias.INCLUDE);
        Arrays.fill(values.srb2, Srb2.CONNECT);
        Arrays.fill(values.srb1, Srb1.DISCONNECT);
    }
}

abstract class BoardCyton extends BoardBrainFlow
implements ImpedanceSettingsBoard, AccelerometerCapableBoard, AnalogCapableBoard, DigitalCapableBoard, ADS1299SettingsBoard {
    private final char[] channelSelectForSettings = {'1', '2', '3', '4', '5', '6', '7', '8', 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I'};

    private ADS1299Settings currentADS1299Settings;
    private boolean[] isCheckingImpedance;
    protected boolean[] isCheckingImpedanceN;
    protected boolean[] isCheckingImpedanceP;

    private int[] accelChannelsCache = null;
    private int[] analogChannelsCache = null;

    protected String serialPort = "";
    protected String ipAddress = "";
    private CytonBoardMode currentBoardMode = CytonBoardMode.DEFAULT;

    public BoardCyton() {
        super();

        isCheckingImpedance = new boolean[getNumEXGChannels()];
        Arrays.fill(isCheckingImpedance, false);

        isCheckingImpedanceN= new boolean[getNumEXGChannels()];
        isCheckingImpedanceP= new boolean[getNumEXGChannels()];
        Arrays.fill(isCheckingImpedanceN, false);
        Arrays.fill(isCheckingImpedanceP, false);

        // The command 'd' is automatically sent by brainflow on prepare_session
        currentADS1299Settings = new CytonDefaultSettings(this);
    }

    // implement mandatory abstract functions
    @Override
    protected BrainFlowInputParams getParams() {
        BrainFlowInputParams params = new BrainFlowInputParams();
        params.serial_port = serialPort;
        params.ip_address = ipAddress;
        params.ip_port = 6677;
        return params;
    }

    @Override
    public boolean initializeInternal() {
        return super.initializeInternal();
    }

    @Override
    public void uninitializeInternal() {
        closeSDFile();
        super.uninitializeInternal();
    }

    @Override
    public void setEXGChannelActive(int channelIndex, boolean active) {
        currentADS1299Settings.setChannelActive(channelIndex, active);
    }
    
    @Override
    public boolean isEXGChannelActive(int channelIndex) {
        return currentADS1299Settings.isChannelActive(channelIndex);
    }

    @Override
    public int getAccelSampleRate() {
        return getSampleRate();
    }

    @Override
    public int getAnalogSampleRate() {
        return getSampleRate();
    }

    @Override
    public int getDigitalSampleRate() {
        return getSampleRate();
    }

    @Override
    public boolean isAccelerometerActive() {
        return getBoardMode() == CytonBoardMode.DEFAULT;
    }

    @Override
    public void setAccelerometerActive(boolean active) {
        if(active) {
            setBoardMode(CytonBoardMode.DEFAULT);
        }
        // no way of turning off accel.
    }

    @Override
    public boolean canDeactivateAccelerometer() {
        //Accelerometer is on by default for Cyton, and can not be disabled using a command.
        //Disabling another Cyton Aux mode (ex. Analog Read) will default the board back to Accelerometer mode.
        return false;
    }

    @Override
    public int[] getAccelerometerChannels() {
        if (accelChannelsCache == null) {
            try {
                accelChannelsCache = BoardShim.get_accel_channels(getBoardIdInt());
            } catch (BrainFlowError e) {
                e.printStackTrace();
            }
        }

        return accelChannelsCache;
    }

    @Override
    public boolean isAnalogActive() {
        return getBoardMode() == CytonBoardMode.ANALOG;
    }

    @Override
    public void setAnalogActive(boolean active) {
        if(active) {
            setBoardMode(CytonBoardMode.ANALOG);
        }
    }

    @Override
    public boolean canDeactivateAnalog() {
        //For Cyton in the GUI, you can switch to another board mode and essentially deactivate analog read mode
        return true;
    }

    @Override
    public int[] getAnalogChannels() {
        if (analogChannelsCache == null) {
            try {
                analogChannelsCache = BoardShim.get_analog_channels(getBoardIdInt());
            } catch (BrainFlowError e) {
                e.printStackTrace();
            }
        }

        return analogChannelsCache;
    }

    @Override
    public boolean isDigitalActive() {
        return getBoardMode() == CytonBoardMode.DIGITAL;
    }

    @Override
    public void setDigitalActive(boolean active) {
        if(active) {
            setBoardMode(CytonBoardMode.DIGITAL);
        }
    }

    @Override
    public boolean canDeactivateDigital() {
        //For Cyton in the GUI, you can switch to another board mode and essentially deactivate digital read mode
        return true;
    }

    @Override
    public int[] getDigitalChannels() {
        // the removeAll function will remove array indices 0 and 5.
        // remove other_channel[0] because it's the end byte
        // remove other_channels[5] because it does not contain digital data
        int[] digitalChannels = ArrayUtils.removeAll(getOtherChannels(), 0, 5); // remove non-digital channels
        return digitalChannels;
    }

    @Override
    public void setCheckingImpedance(int channel, boolean active) {
        char p = '0';
        char n = '0';

        if (active) {
            Srb2 srb2sSetting = currentADS1299Settings.values.srb2[channel];
            if (srb2sSetting == Srb2.CONNECT) {
                n = '1';
            }
            else {
                p = '1';
            }
        }

        // for example: z 4 1 0 Z
        String command = String.format("z%c%c%cZ", channelSelectForSettings[channel], p, n);
        sendCommand(command);

        isCheckingImpedance[channel] = active;
    }

    //Use this method instead of the one above!
    public Pair<Boolean, String> setCheckingImpedanceCyton(final int channel, final boolean active, final boolean _isN) {

        char p = '0';
        char n = '0';
        //Build a command string so we can send 1 command to Cyton instead of 2!
        //Hopefully, this lowers the chance of confusing the board with multiple commands sent quickly
        StringBuilder fullCommand = new StringBuilder();

        //println("CYTON_IMP_CHECK -- Attempting to change channel== " + channel + " || isActive == " + active);

        if (active) {
            
            currentADS1299Settings.saveLastValues(channel);

            currentADS1299Settings.values.gain[channel] = Gain.X1;
            currentADS1299Settings.values.inputType[channel] = InputType.NORMAL;
            currentADS1299Settings.values.bias[channel] = Bias.INCLUDE;
            currentADS1299Settings.values.srb2[channel] = Srb2.DISCONNECT;
            currentADS1299Settings.values.srb1[channel] = Srb1.DISCONNECT;

            fullCommand.append(currentADS1299Settings.getValuesString(channel, currentADS1299Settings.values));
            
            if (_isN) {
                n = '1';
            } else {
                p = '1';
            }

        } else {
            //Revert ADS channel settings to what user had before checking impedance on this channel
            currentADS1299Settings.revertToLastValues(channel);
            fullCommand.append(currentADS1299Settings.getValuesString(channel, currentADS1299Settings.values));
            //println("CYTON REVERTING TO PREVIOUS ADS SETTINGS");
        }
        
        // Format the impedance command string. Example: z 4 1 0 Z
        String impedanceCommandString = String.format("z%c%c%cZ", channelSelectForSettings[channel], p, n);
        fullCommand.append(impedanceCommandString);
        final String commandToSend = fullCommand.toString();

        final Pair<Boolean, String> fullResponse = sendCommand(commandToSend);
        boolean response = fullResponse.getKey().booleanValue();
        if (!response) {
            outputWarn("Cyton Impedance Check - Error sending impedance command to board.");
            if (active) {
                currentADS1299Settings.revertToLastValues(channel);
                return new ImmutablePair<Boolean, String>(false, "Error");
            }
        }

        if (_isN) {
            isCheckingImpedanceN[channel] = active;
        } else {
            isCheckingImpedanceP[channel] = active;
        }

        return fullResponse;
    }

    @Override
    //General check that is a method for all impedance boards
    public boolean isCheckingImpedance(int channel) {
        return isCheckingImpedanceN[channel] || isCheckingImpedanceP[channel];
    }

    //Specifically check the status of N or P pins
    public boolean isCheckingImpedanceNorP(int channel, boolean _isN) {
        if (_isN) {
            return isCheckingImpedanceN[channel];
        }
        return isCheckingImpedanceP[channel];
    }

    //Returns <pin, channel> if found
    //Return <null,null> if not checking on any channels
    public Pair<Boolean, Integer> isCheckingImpedanceOnAnyChannelsNorP() {
        Boolean is_n_pin = true;
        for (int i = 0; i < isCheckingImpedanceN.length; i++) {
            if (isCheckingImpedanceN[i]) {
                return new ImmutablePair<Boolean, Integer>(is_n_pin, Integer.valueOf(i));
            }
            if (isCheckingImpedanceP[i]) {
                is_n_pin = false;
                return new ImmutablePair<Boolean, Integer>(is_n_pin, Integer.valueOf(i));
            }
        }
        return new ImmutablePair<Boolean, Integer>(null, null);
    }

    //Returns the channel number where impedance check is currently active, otherwise return null
    //Less detailed than the previous method
    @Override
    public Integer isCheckingImpedanceOnChannel() {
        //printArray(isCheckingImpedance);
        for (int i = 0; i < isCheckingImpedance.length; i++) {
            if (isCheckingImpedance(i)) {
                return i;
            }
        }
        return null;
    }

    public void forceStopImpedanceFrontEnd(Integer channel, Boolean _isN) {
        if (channel == null || _isN == null) {
            outputError("OOPS! Are you sure you know what you are doing with this method? Please pass non-null values.");
            return;
        }

        if (_isN) {
            isCheckingImpedanceN[channel] = false;
        } else {
            isCheckingImpedanceP[channel] = false;
        }
    }

    @Override
    public ADS1299Settings getADS1299Settings() {
        return currentADS1299Settings;
    }

    @Override
    public char getChannelSelector(int channel) {
        return channelSelectForSettings[channel];
    }

    public CytonBoardMode getBoardMode() {
        return currentBoardMode;
    }

    private void setBoardMode(CytonBoardMode boardMode) {
        sendCommand("/" + boardMode.getValue());
        currentBoardMode = boardMode;
    }

    @Override
    public void startStreaming() {
        openSDFile();
        super.startStreaming();
    }

    @Override
    public void stopStreaming() {
        closeSDFile();
        super.stopStreaming();
    }

    public void openSDFile() {
        //If selected, send command to Cyton to enabled SD file recording for selected duration
        if (cyton_sdSetting != CytonSDMode.NO_WRITE) {
            println("Opening SD file. Writing " + cyton_sdSetting.getCommand() + " to Cyton.");
            sendCommand(cyton_sdSetting.getCommand());
        }
    }

    public void closeSDFile() {
        if (cyton_sdSetting != CytonSDMode.NO_WRITE) {
            println("Closing any open SD file. Writing 'j' to Cyton.");
            sendCommand("j"); // tell the SD file to close if one is open...
        }
    }

    public void printRegisters() {
        println("Cyton: printRegisters(): Writing ? to OpenBCI...");
        sendCommand("?");
    }
    
    @Override
    protected void addChannelNamesInternal(String[] channelNames) {
        for (int i=0; i<getAccelerometerChannels().length; i++) {
            channelNames[getAccelerometerChannels()[i]] = "Accel Channel " + i;
        }
        for (int i=0; i<getAnalogChannels().length; i++) {
            channelNames[getAnalogChannels()[i]] = "Analog Channel " + i;
        }
    }

    @Override
    public double getGain(int channel) {
        return getADS1299Settings().values.gain[channel].getScalar();
    }

    @Override
    public List<double[]> getDataWithAccel(int maxSamples) {
        return getData(maxSamples);
    }

    @Override
    public List<double[]> getDataWithAnalog(int maxSamples) {
        return getData(maxSamples);
    }

    @Override
    public List<double[]> getDataWithDigital(int maxSamples) {
        return getData(maxSamples);
    }
};
class BoardGanglionNative extends BoardGanglion {

    private PacketLossTrackerGanglionBLE packetLossTrackerGanglionNative;
    private String boardName;

    public BoardGanglionNative() {
        super();
    }

    public BoardGanglionNative(String name) {
        super();
        this.boardName = name;
    }

    @Override
    protected BrainFlowInputParams getParams() {
        BrainFlowInputParams params = new BrainFlowInputParams();
        params.serial_number = boardName;
        return params;
    }

    @Override
    public BoardIds getBoardId() {
        return BoardIds.GANGLION_NATIVE_BOARD;
    }

    @Override
    public void setAccelerometerActive(boolean active) {
        super.setAccelerometerActive(active);

        if (packetLossTrackerGanglionNative != null) {
            // notify the packet loss tracker, because the sample indices change based
            // on whether accel is active or not
            packetLossTrackerGanglionNative.setAccelerometerActive(active);
        }
    }

    @Override
    protected PacketLossTracker setupPacketLossTracker() {
        packetLossTrackerGanglionNative = new PacketLossTrackerGanglionBLE(getSampleIndexChannel(), getTimestampChannel());
        packetLossTrackerGanglionNative.setAccelerometerActive(isAccelerometerActive());
        return packetLossTrackerGanglionNative;
    }
};

class BoardGanglionBLE extends BoardGanglion {

    private PacketLossTrackerGanglionBLE packetLossTrackerGanglionBLE;

    public BoardGanglionBLE() {
        super();
    }

    public BoardGanglionBLE(String serialPort, String macAddress) {
        super();
        this.serialPort = serialPort;
        this.macAddress = macAddress;
    }

    @Override
    public BoardIds getBoardId() {
        return BoardIds.GANGLION_BOARD;
    }

    @Override
    public void setAccelerometerActive(boolean active) {
        super.setAccelerometerActive(active);

        if (packetLossTrackerGanglionBLE != null) {
            // notify the packet loss tracker, because the sample indices change based
            // on whether accel is active or not
            packetLossTrackerGanglionBLE.setAccelerometerActive(active);
        }
    }

    @Override
    protected PacketLossTracker setupPacketLossTracker() {
        packetLossTrackerGanglionBLE = new PacketLossTrackerGanglionBLE(getSampleIndexChannel(), getTimestampChannel());
        packetLossTrackerGanglionBLE.setAccelerometerActive(isAccelerometerActive());
        return packetLossTrackerGanglionBLE;
    }
};

class BoardGanglionWifi extends BoardGanglion {
    // https://docs.openbci.com/docs/03Ganglion/GanglionSDK
    private Map<Integer, String> samplingRateCommands = new HashMap<Integer, String>() {{
        put(25600, "~0");
        put(12800, "~1");
        put(6400, "~2");
        put(3200, "~3");
        put(1600, "~4");
        put(800, "~5");
        put(400, "~6");
        put(200, "~7");
    }};

    public BoardGanglionWifi(String ipAddress, int samplingRate) {
        super();
        this.ipAddress = ipAddress;
        samplingRateCache = samplingRate;
    }
    
    @Override
    public boolean initializeInternal()
    {
        // turn on accel by default, or is it handled somewhere else?
        boolean res = super.initializeInternal();
        
        if ((res) && (samplingRateCache > 0)){
            String command = samplingRateCommands.get(samplingRateCache);
            sendCommand(command);
        }

        return res;
    }

    @Override
    public BoardIds getBoardId() {
        return BoardIds.GANGLION_WIFI_BOARD;
    }

    @Override
    protected PacketLossTracker setupPacketLossTracker() {
        final int minSampleIndex = 0;
        final int maxSampleIndex = 200;
        return new PacketLossTracker(getSampleIndexChannel(), getTimestampChannel(),
                                    minSampleIndex, maxSampleIndex);
    }
};

abstract class BoardGanglion extends BoardBrainFlow implements AccelerometerCapableBoard {

    private final char[] deactivateChannelChars = {'1', '2', '3', '4', '5', '6', '7', '8', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i'};
    private final char[] activateChannelChars =  {'!', '@', '#', '$', '%', '^', '&', '*', 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I'};
    
    private int[] accelChannelsCache = null;
    private int[] resistanceChannelsCache = null;

    private boolean[] exgChannelActive;

    protected String serialPort = "";
    protected String macAddress = "";
    protected String ipAddress = "";
    private boolean isCheckingImpedance = false;
    private boolean isGettingAccel = false;

    // implement mandatory abstract functions
    @Override
    protected BrainFlowInputParams getParams() {
        BrainFlowInputParams params = new BrainFlowInputParams();
        params.serial_port = serialPort;
        params.mac_address = macAddress;
        params.ip_address = ipAddress;
        params.ip_port = 6677;
        return params;
    }

    @Override
    public void setEXGChannelActive(int channelIndex, boolean active) {
        char[] charsToUse = active ? activateChannelChars : deactivateChannelChars;
        sendCommand(str(charsToUse[channelIndex]));
        exgChannelActive[channelIndex] = active;
    }
    
    @Override
    public boolean isEXGChannelActive(int channelIndex) {
        return exgChannelActive[channelIndex];
    }

    @Override
    public boolean initializeInternal()
    {
        // turn on accel by default, or is it handled somewhere else?
        boolean res = super.initializeInternal();
        
        setAccelerometerActive(true);
        exgChannelActive = new boolean[getNumEXGChannels()];
        Arrays.fill(exgChannelActive, true);

        return res;
    }

    @Override
    public boolean isAccelerometerActive() {
        return isGettingAccel;
    }

    @Override
    public void setAccelerometerActive(boolean active) {
        sendCommand(active ? "n" : "N");
        isGettingAccel = active;
    }

    @Override
    public boolean canDeactivateAccelerometer() {
        return true;
    }

    @Override
    public int[] getAccelerometerChannels() {
        if (accelChannelsCache == null) {
            try {
                accelChannelsCache = BoardShim.get_accel_channels(getBoardIdInt());
            } catch (BrainFlowError e) {
                e.printStackTrace();
            }
        }
        
        return accelChannelsCache;
    }

    public int[] getResistanceChannels() {
        if (resistanceChannelsCache == null) {
            try {
                resistanceChannelsCache = BoardShim.get_resistance_channels(getBoardIdInt());
            } catch (BrainFlowError e) {
                e.printStackTrace();
            }
        }

        return resistanceChannelsCache;
    }

    public void setCheckingImpedance(boolean checkImpedance) {
        if (checkImpedance) {
            if (isCheckingImpedance) {
                println("Already checking impedance.");
                return;
            }
            if (streaming) {
                stopRunning();
            }
            sendCommand("z");
            startStreaming();
            packetLossTracker = null;
        }
        else {
            if (!isCheckingImpedance) {
                println ("Impedance is not running.");
                return;
            }
            if (streaming) {
                stopStreaming();
            }
            sendCommand("Z");
            packetLossTracker = setupPacketLossTracker();
        }
        isCheckingImpedance = checkImpedance;
    }
    
    public boolean isCheckingImpedance() {
        return isCheckingImpedance;
    }
    
    @Override
    protected void addChannelNamesInternal(String[] channelNames) {
        for (int i=0; i<getAccelerometerChannels().length; i++) {
            channelNames[getAccelerometerChannels()[i]] = "Accel Channel " + i;
        }
    }

    @Override
    public List<double[]> getDataWithAccel(int maxSamples) {
        return getData(maxSamples);
    }

    @Override
    public int getAccelSampleRate() {
        return getSampleRate();
    }
};



/* This class does nothing, it serves as a signal that the board we are using
 * is null, but does not crash if we use it.
 */
class BoardNull extends Board {

    @Override
    public boolean initializeInternal() {
        return true;
    }

    @Override
    public void uninitializeInternal() {
        // empty
    }

    @Override
    public void updateInternal() {
        // empty
    }

    @Override
    public boolean isConnected() {
        return false;
    }

    @Override
    public boolean isStreaming() {
        return false;
    }

    @Override
    public int getSampleRate() {
        return 0;
    }

    @Override
    public int[] getEXGChannels() {
        return new int[0];
    }

    @Override
    public int getTimestampChannel() {
        return 0;
    }
    
    @Override
    public int getSampleIndexChannel() {
        return 0;
    }

    @Override
    public void setEXGChannelActive(int channelIndex, boolean active) {
        // empty
    }
    
    @Override
    public boolean isEXGChannelActive(int channelIndex) {
        return false;
    }

    @Override
    public Pair<Boolean, String> sendCommand(String command) {
        return new ImmutablePair<Boolean, String>(Boolean.valueOf(true), "");
    }

    protected double[][] getNewDataInternal() {
        return new double[1][0];
    }

    @Override
    public int getTotalChannelCount() {
        return 0;
    }

    protected void addChannelNamesInternal(String[] channelNames) {
        // nothing
    }
    
    @Override
    protected PacketLossTracker setupPacketLossTracker() {
        return null;
    }
};



public class Buffer<T> extends LinkedList<T> {

    private int samplingRate;
    private int maxSize;
    private Long timeOfLastCallMS;

    Buffer(int samplingRate, int maxSize) {
        this.samplingRate = samplingRate;
        this.maxSize = maxSize;
        timeOfLastCallMS = null;
    }

    Buffer(int samplingRate) {
        // max delay 1 second
        this(samplingRate, samplingRate /*max size*/);
    }

    public void addNewEntry(T object) {
        this.add(object);
    }

    public T popFirstEntry() {
        return this.poll();
    }

    public int getDataCount() {
        long currentTime = millis();
        int numSamples = 0;
        // skip first call to set time
        if (timeOfLastCallMS != null) {
            float deltaTimeSeconds = (currentTime - timeOfLastCallMS.longValue()) / 1000.0f;
            // for safety, err on the side of delivering more samples (hence the use of ceil())
            numSamples = ceil(samplingRate * deltaTimeSeconds);
        }
        timeOfLastCallMS = currentTime;
        // ensure that buffer is not bigger than maxSize
        if (this.size() > maxSize) {
            numSamples += this.size() - maxSize;
        }
        return Math.min(numSamples, this.size());
    }
}
////////////////////////////////////////////////////////////
//                 ConsoleLog.pde                         //
//  This is an example of how to print console messages:  //
//      -- to console                                     //
//      -- to a file                                      //
//      -- to the screen with scrolling                   //
//                                                        //
////////////////////////////////////////////////////////////








static class ConsoleWindow extends PApplet implements Runnable {
    private static ConsoleWindow instance = null;

    PApplet logApplet;

    private ControlP5 cp5;
    private Textarea consoleTextArea;
    private ClipHelper clipboardCopy;

    private final int headerHeight = 42;
    private final int defaultWidth = 620;
    private final int defaultHeight = 500;
    private final int buttonWidth = 142;
    private final int buttonHeight = 34;

    //for screen resizing
    private boolean screenHasBeenResized = false;
    private float timeOfLastScreenResize = 0;
    private int widthOfLastScreen = defaultWidth;
    private int heightOfLastScreen = defaultHeight;

    public static void display() {        // enforce only one Console Window
        if (instance == null) {
            instance = new ConsoleWindow();
            Thread t = new Thread(instance);
            t.start();
        }
    }

    @Override
    public void run() {
        PApplet.runSketch(new String[] {instance.getClass().getSimpleName()}, instance);
    }

    private ConsoleWindow() {
        super();
    }

    public void settings() {
        size(defaultWidth, defaultHeight);
    }

    public void setup() {

        logApplet = this;

        surface.setAlwaysOnTop(false);
        surface.setResizable(true);

        Frame frame = ( (PSurfaceAWT.SmoothCanvas) ((PSurfaceAWT)surface).getNative()).getFrame();
        frame.toFront();
        frame.requestFocus();

        clipboardCopy = new ClipHelper();
        cp5 = new ControlP5(this);
        PFont textAreaFont = createFont("Arial", 12, true);
        consoleTextArea = cp5.addTextarea("ConsoleWindow")
            .setPosition(0, headerHeight)
            .setSize(width, height - headerHeight)
            .setFont(textAreaFont)
            .setLineHeight(18)
            .setColor(color(242))
            .setColorBackground(color(42, 100))
            .setColorForeground(color(42, 100))
            .setScrollBackground(color(70, 100))
            .setScrollForeground(color(144, 100))
        ;

        // register this console's Textarea with the output stream object
        outputStream.registerTextArea(consoleTextArea);

        int cW = PApplet.parseInt(width/4);
        int bX = PApplet.parseInt((cW - buttonWidth) / 2);
        createConsoleLogButton("openLogFileAsText", "Open Log as Text (F)", bX);
        bX += cW;
        createConsoleLogButton("copyFullTextToClipboard", "Copy Full Text (C)", bX);
        bX += cW;
        createConsoleLogButton("copyLastLineToClipboard", "Copy Last Line (L)", bX);
        bX += cW;
        createConsoleLogButton("jumpToLastLine", "Jump to Last Line (J)", bX);
    }

    public void createConsoleLogButton (String bName, String bText, int x) {
        int y = 4;  // vertical position for button
        PFont buttonFont = createFont("Arial", 14, true);
        cp5.addButton(bName)
                .setPosition(x, y)
                .setSize(buttonWidth, buttonHeight)
                .setColorLabel(color(255))
                .setColorForeground(color(31, 69, 110)) //openbci blue
                .setColorBackground(color(144, 100));
        cp5.getController(bName)
                .getCaptionLabel()
                .setFont(buttonFont)
                .toUpperCase(false)
                .setText(bText);
    }

    public void draw() {
        clear();
        scene();
        cp5.draw();
        //checks if the screen is resized, similar to main GUI window
        screenResized();
    }

    public void screenResized() {
        if (this.widthOfLastScreen != width || this.heightOfLastScreen != height) {
            //println("ConsoleLog: RESIZED");
            this.screenHasBeenResized = true;
            this.timeOfLastScreenResize = millis();
            this.widthOfLastScreen = width;
            this.heightOfLastScreen = height;
        }
        if (this.screenHasBeenResized) {
            //setGraphics() is very important, it lets the cp5 elements know where the origin is.
            //Without this, cp5 elements won't work after screen is resized.
            //This also happens in most widgets when the main GUI window is resized.
            logApplet = this;
            cp5.setGraphics(logApplet, 0, 0);

            imposeMinConsoleLogDimensions();
            // dynamically resize text area to fit widget
            consoleTextArea.setSize(width, height - headerHeight);
            // update button positions when screen width changes
            updateButtonPositions();
        }
        //re-initialize console log if screen has been resized and it's been more than 1 seccond (to prevent reinitialization happening too often)
        if (this.screenHasBeenResized == true && (millis() - this.timeOfLastScreenResize) > 1000) {
            this.screenHasBeenResized = false;
        }
    }

    public void scene() {
        background(42);
        fill(42);
        rect(0, 0, width, headerHeight);
    }

    public void keyReleased() {
        if (key == 'c') {
            copyFullTextToClipboard();
        } else if (key == 'f') {
            openLogFileAsText();
        } else if (key == 'l') {
            copyLastLineToClipboard();
        } else if (key == 'j' ) {
            jumpToLastLine();
        }
        
    }

    public void keyPressed() {
        if (key == CODED) {
            if (keyCode == UP) {
                consoleTextArea.scrolled(-5);
            } else if (keyCode == DOWN) {
                consoleTextArea.scrolled(5);
            }
        }
    }

    public void mousePressed() {

    }

    public void mouseReleased() {

    }

    public void openLogFileAsText() {
        try {
            println("ConsoleLog: Opening console log as text file!");
            File file = new File (outputStream.getFilePath());
            Desktop desktop = Desktop.getDesktop();
            if (file.exists()) {
                desktop.open(file);
            } else {
                println("ConsoleLog: ERROR - Unable to open console log as text file...");
            }
        } catch (IOException e) {}
    }

    public void copyFullTextToClipboard() {
        println("ConsoleLog: Copying console log to clipboard!");
        String stringToCopy = outputStream.getFullLog();
        String formattedCodeBlock = "```\n" + stringToCopy + "\n```";
        clipboardCopy.copyString(formattedCodeBlock);
    }

    public void copyLastLineToClipboard() {
        clipboardCopy.copyString(outputStream.getLastLine());
        println("ConsoleLog: Previous line copied to clipboard.");
    }

    public void jumpToLastLine() {
        consoleTextArea.scroll(1.0f);
    }

    public void updateButtonPositions() {
        int cW = width / 4;
        int bX = (cW - buttonWidth) / 2;
        int bY = 4;
        cp5.getController("openLogFileAsText").setPosition(bX, bY);
        bX += cW;
        cp5.getController("copyFullTextToClipboard").setPosition(bX, bY);
        bX += cW;
        cp5.getController("copyLastLineToClipboard").setPosition(bX, bY);
        bX += cW;
        cp5.getController("jumpToLastLine").setPosition(bX, bY);
    }

    public void imposeMinConsoleLogDimensions() {
        //impose minimum gui dimensions
        int minHeight = PApplet.parseInt(defaultHeight/2);
        if (width < defaultWidth || height < minHeight) {
            int _w = (width < defaultWidth) ? defaultWidth : width;
            int _h = (height < minHeight) ? minHeight : height;
            surface.setSize(_w, _h);
        }
    }

    public void exit() {
        println("ConsoleLog: Console closed!");
        instance = null;
        dispose();
    }

    // ===============================================================
    // CLIPHELPER OBJECT CLASS
    class ClipHelper {
        Clipboard clipboard;

        ClipHelper() {
            getClipboard();
        }

        public void getClipboard () {
            // this is our simple thread that grabs the clipboard
            Thread clipThread = new Thread() {
                public void run() {
                    clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
                }
            };

            // start the thread as a daemon thread and wait for it to die
            if (clipboard == null) {
                try {
                    clipThread.setDaemon(true);
                    clipThread.start();
                    clipThread.join();
                }
                catch (Exception e) {}
            }
        }

        public void copyString (String data) {
            copyTransferableObject(new StringSelection(data));
        }

        public void copyTransferableObject (Transferable contents) {
            getClipboard();
            clipboard.setContents(contents, null);
        }

        public String pasteString () {
            String data = null;
            try {
                data = (String)pasteObject(DataFlavor.stringFlavor);
            }
            catch (Exception e) {
                println("ConsoleLog: Error getting String from clipboard: " + e);
            }
            return data;
        }

        public Object pasteObject (DataFlavor flavor)
        throws UnsupportedFlavorException, IOException
        {
            Object obj = null;
            getClipboard();

            Transferable content = clipboard.getContents(null);
            if (content != null)
            obj = content.getTransferData(flavor);

            return obj;
        }
    }//end class
}//end class

// --------------------------------------------------------------

class CustomOutputStream extends PrintStream {

    private StringList data;
    private PrintWriter fileOutput;
    private Textarea textArea;
    private final String filePath = directoryManager.getConsoleDataPath()+"Console_"+directoryManager.getFileNameDateTime()+".txt";

    public CustomOutputStream(OutputStream out) {
        super(out);
        data = new StringList();
        // initialize the printwriter just in case the file open fails
        fileOutput = new PrintWriter(out);

        // create log file
        try {
            fileOutput = createWriter(filePath);
        }
        catch (RuntimeException e) {
            println("Error! Failed to open " + filePath + " for write.");
            println(e);
        }
    }

    public void println(String string) {
        string += "\n";
        super.print(string);  // don't call super.println() here, you'll get double prints

        // add to array
        data.append(string);

        // print to file
        fileOutput.print(string);
        fileOutput.flush();

        // add to text area, if registered
        if (textArea != null) {
            textArea.append(string);
        }
    }

    public void print(String string) {
        super.print(string);
        string += "\n"; // TODO: shouldn't have to do this, but exceptions were printing on one line. investigate?

        // add to array
        data.append(string);

        // print to file
        fileOutput.print(string);
        fileOutput.flush();

        // add to text area, if registered
        if (textArea != null) {
            textArea.append(string);
        }
    }

    public void registerTextArea(Textarea area) {
        textArea = area;
        textArea.setText(getFullLog());
    }

    public String getFilePath() {
        return filePath;
    }

    public String getLastLine() {
        return data.get(data.size()-1);
    }

    public String getFullLog() {
        return join(data.array(), "");
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//   This code is used for GUI-wide spacing. It defines the GUI layout as a grid
//   with the following design:
//
//   The #s shown below fall at the center of their corresponding container[].
//   Ex: container[1] is the upper left corner of the large rectangle between [0] & [10]
//   Ex 2: container[6] is the entire right half of the same rectangle.
//
//   ------------------------------------------------
//   |                      [0]                     |
//   ------------------------------------------------
//   |                       |         [11]         |
//   |         [1]          [2]---[15]--[3]---[16]--|
//   |                       |         [12]         |
//   |---------[4]----------[5]---------[6]---------|
//   |                       |         [13]         |
//   |         [7]          [8]---[17]--[9]---[18]--|
//   |                       |         [14]         |
//   ------------------------------------------------
//   |                      [10]                    |
//   ------------------------------------------------
//
//   Created by: Conor Russomanno (May 2016)
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

boolean drawContainers = false;
Container[] container = new Container[19];

//Viz extends container (example below)
//Viz viz1;
//Viz viz2;

int widthOfLastScreen_C = 0;
int heightOfLastScreen_C = 0;

int topNav_h = 64; //tie this to a global variable or one attached to GUI_Manager
int bottomNav_h = 28; //same

public void setupContainers() {

    widthOfLastScreen_C = width;
    heightOfLastScreen_C = height;

    container[0] = new Container(0, 0, width, topNav_h, 0);
    container[5] = new Container(0, topNav_h, width, height - (topNav_h + bottomNav_h), 1);
    container[1] = new Container(container[5], "TOP_LEFT");
    container[2] = new Container(container[5], "TOP");
    container[3] = new Container(container[5], "TOP_RIGHT");
    container[4] = new Container(container[5], "LEFT");
    container[6] = new Container(container[5], "RIGHT");
    container[7] = new Container(container[5], "BOTTOM_LEFT");
    container[8] = new Container(container[5], "BOTTOM");
    container[9] = new Container(container[5], "BOTTOM_RIGHT");
    container[10] = new Container(0, height - bottomNav_h, width, 50, 0);
    container[11] = new Container(container[3], "TOP");
    container[12] = new Container(container[3], "BOTTOM");
    container[13] = new Container(container[9], "TOP");
    container[14] = new Container(container[9], "BOTTOM");
    container[15] = new Container(container[6], "TOP_LEFT");
    container[16] = new Container(container[6], "TOP_RIGHT");
    container[17] = new Container(container[6], "BOTTOM_LEFT");
    container[18] = new Container(container[6], "BOTTOM_RIGHT");

    //setup viz objects... example of container extension (more below)
    //setupVizs();
}

public void drawContainers() {
    for(int i = 0; i < container.length; i++){
        container[i].draw();
    }

    //Draw viz objects.. example extension of container class (more below)
    //viz1.draw();
    //viz2.draw();

    //alternative component listener function (line 177 - 187 frame.addComponentListener) for processing 3,
    if (widthOfLastScreen_C != width || heightOfLastScreen_C != height) {
        setupContainers();
        //setupVizs(); //container extension example (more below)
        settings.widthOfLastScreen = width;
        settings.heightOfLastScreen = height;
    }
}

public class Container {

    //key Container Variables
    public float x0, y0, w0, h0; //true dimensions.. without margins
    public float x, y, w, h; //dimensions with margins
    public float margin; //margin

    //constructor 1 -- comprehensive
    public Container(float _x0, float _y0, float _w0, float _h0, float _margin) {

        margin = _margin;

        x0 = _x0;
        y0 = _y0;
        w0 = _w0;
        h0 = _h0;

        x = x0 + margin;
        y = y0 + margin;
        w = w0 - margin*2;
        h = h0 - margin*2;
    }

    //constructor 2 -- recursive constructor -- for quickly building sub-containers based on a super container (aka master)
    public Container(Container master, String _type) {

        margin = master.margin;

        if(_type == "WHOLE"){
            x0 = master.x0;
            y0 = master.y0;
            w0 = master.w0;
            h0 = master.h0;
            w = master.w;
            h = master.h;
            x = master.x;
            y = master.y;
        } else if (_type == "LEFT") {
            x0 = master.x0;
            y0 = master.y0;
            w0 = master.w0/2;
            h0 = master.h0;
            w = (master.w - margin)/2;
            h = master.h;
            x = master.x;
            y = master.y;
        } else if (_type == "RIGHT") {
            x0 = master.x0 + master.w0/2;
            y0 = master.y0;
            w0 = master.w0/2;
            h0 = master.h0;
            w = (master.w - margin)/2;
            h = master.h;
            x = master.x + w + margin;
            y = master.y;
        } else if (_type == "TOP") {
            x0 = master.x0;
            y0 = master.y0;
            w0 = master.w0;
            h0 = master.h0/2;
            w = master.w;
            h = (master.h - margin)/2;
            x = master.x;
            y = master.y;
        } else if (_type == "BOTTOM") {
            x0 = master.x0;
            y0 = master.y0 + master.h0/2;
            w0 = master.w0;
            h0 = master.h0/2;
            w = master.w;
            h = (master.h - margin)/2;
            x = master.x;
            y = master.y + h + margin;
        } else if (_type == "TOP_LEFT") {
            x0 = master.x0;
            y0 = master.y0;
            w0 = master.w0/2;
            h0 = master.h0/2;
            w = (master.w - margin)/2;
            h = (master.h - margin)/2;
            x = master.x;
            y = master.y;
        } else if (_type == "TOP_RIGHT") {
            x0 = master.x0 + master.w0/2;
            y0 = master.y0;
            w0 = master.w0/2;
            h0 = master.h0/2;
            w = (master.w - margin)/2;
            h = (master.h - margin)/2;
            x = master.x + w + margin;
            y = master.y;
        } else if (_type == "BOTTOM_LEFT") {
            x0 = master.x0;
            y0 = master.y0 + master.h0/2;
            w0 = master.w0/2;
            h0 = master.h0/2;
            w = (master.w - margin)/2;
            h = (master.h - margin)/2;
            x = master.x;
            y = master.y + h + margin;
        } else if (_type == "BOTTOM_RIGHT") {
            x0 = master.x0 + master.w0/2;
            y0 = master.y0 + master.h0/2;
            w0 = master.w0/2;
            h0 = master.h0/2;
            w = (master.w - margin)/2;
            h = (master.h - margin)/2;
            x = master.x + w + margin;
            y = master.y + h + margin;
        }
    }

    public void draw() {
        if(drawContainers){
            pushStyle();

            //draw margin area
            fill(102, 255, 71, 100);
            noStroke();
            rect(x0, y0, w0, h0);

            //noFill();
            //stroke(255, 0, 0);
            //rect(x0, y0, w0, h0);

            fill(OPENBCI_BLUE_ALPHA100);
            noStroke();
            rect(x, y, w, h);

            popStyle();
        }
    }
};

// --- EXAMPLE OF EXTENDING THE CONTAINER --- //

//public class Viz extends Container {
//  public float abc;

//  public Viz(float _abc, Container master) {
//    super(master, "WHOLE");
//    abc = _abc;
//  }

//  void draw() {
//    pushStyle();
//    noStroke();
//    fill(255, 0, 0, 50);
//    rect(x, y, w, h);
//    popStyle();
//  }
//};

//void setupVizs() {
//  viz1 = new Viz (10f, container2);
//  viz2 = new Viz (10f, container4);
//}

// --- END OF EXAMPLE OF EXTENDING THE CONTAINER --- //
//////////////////////////////////////////////////////////////////////////
//
//    System Control Panel
//    - Select serial port from dropdown
//        - Select default configuration (EEG, EKG, EMG)
//        - Select Electrode Count (8 vs 16)
//        - Select data mode (synthetic, playback file, real-time)
//        - Record data? (y/n)
//            - select output location
//        - link to help guide
//        - buttons to start/stop/reset application
//
//        Written by: Conor Russomanno (Oct. 2014)
//        Refactored by: Richard Waltman (Nov. 2020)
//
//////////////////////////////////////////////////////////////////////////












//------------------------------------------------------------------------//
//                      Main Control Panel Class                          //
//------------------------------------------------------------------------//

class ControlPanel {

    public int x, y, w, h;
    public boolean isOpen;

    PlotFontInfo fontInfo;

    //various control panel elements that are unique to specific datasources
    DataSourceBox dataSourceBox;
    SerialBox serialBox;
    ComPortBox comPortBox;
    public SessionDataBox dataLogBoxCyton;
    ChannelCountBox channelCountBox;
    InitBox initBox;
    SyntheticChannelCountBox synthChannelCountBox;
    RecentPlaybackBox recentPlaybackBox;
    PlaybackFileBox playbackFileBox;
    StreamingBoardBox streamingBoardBox;
    BLEBox bleBox;
    public SessionDataBox dataLogBoxGanglion;
    WifiBox wifiBox;
    InterfaceBoxCyton interfaceBoxCyton;
    InterfaceBoxGanglion interfaceBoxGanglion;
    SampleRateCytonBox sampleRateCytonBox;
    SampleRateGanglionBox sampleRateGanglionBox;
    SDBox sdBox;
    BrainFlowStreamerBox bfStreamerBoxCyton;
    BrainFlowStreamerBox bfStreamerBoxGanglion;
    BrainFlowStreamerBox bfStreamerBoxSynthetic;

    ChannelPopup channelPopup;
    RadioConfigBox rcBox;

    //Track Dynamic and Static WiFi mode in Control Panel
    final public String WIFI_DYNAMIC = "dynamic";
    final public String WIFI_STATIC = "static";
    private String wifiSearchStyle = WIFI_DYNAMIC;

    boolean drawStopInstructions;
    int globalPadding; //design feature: passed through to all box classes as the global spacing .. in pixels .. for all elements/subelements
    boolean convertingSD = false;
    private final int PAD_3 = 3;

    ControlPanel(OpenBCI_GUI mainClass) {

        x = PAD_3;
        y = PAD_3 + topNav.controlPanelCollapser.getHeight();
        w = topNav.controlPanelCollapser.getWidth();
        h = height - PApplet.parseInt(helpWidget.h);

        isOpen = false;
        fontInfo = new PlotFontInfo();

        globalPadding = 10;  //controls the padding of all elements on the control panel

        //boxes active when eegDataSource = Normal (OpenBCI)
        dataSourceBox = new DataSourceBox(x, y, w, h, globalPadding);
        interfaceBoxCyton = new InterfaceBoxCyton(x + w, dataSourceBox.y, w, h, globalPadding);
        interfaceBoxGanglion = new InterfaceBoxGanglion(x + w, dataSourceBox.y, w, h, globalPadding);
        
        comPortBox = new ComPortBox(x+w*2, y, w, h, globalPadding);
        rcBox = new RadioConfigBox(x+w, y + comPortBox.h, w, h, globalPadding);

        serialBox = new SerialBox(x + w, interfaceBoxCyton.y + interfaceBoxCyton.h, w, h, globalPadding);
        wifiBox = new WifiBox(x + w + x + w - 3, interfaceBoxCyton.y, w, h, globalPadding);

        channelCountBox = new ChannelCountBox(x + w, (serialBox.y + serialBox.h), w, h, globalPadding);
        dataLogBoxCyton = new SessionDataBox(x + w, (channelCountBox.y + channelCountBox.h), w, h, globalPadding, DATASOURCE_CYTON, dataLogger.getDataLoggerOutputFormat(), "sessionNameCyton");
        bfStreamerBoxCyton = new BrainFlowStreamerBox(x + w, (dataLogBoxCyton.y + dataLogBoxCyton.h), w, h, globalPadding, "bfStreamerCyton");
        sdBox = new SDBox(x + w, (bfStreamerBoxCyton.y + bfStreamerBoxCyton.h), w, h, globalPadding);
        
        //Draw this to the right of the other cyton boxes
        sampleRateCytonBox = new SampleRateCytonBox(wifiBox.x, wifiBox.y + wifiBox.h, w, h, globalPadding);
        
        //boxes active when eegDataSource = Playback
        int playbackWidth = PApplet.parseInt(w * 1.35f);
        playbackFileBox = new PlaybackFileBox(x + w, dataSourceBox.y, playbackWidth, h, globalPadding);
        recentPlaybackBox = new RecentPlaybackBox(x + w, (playbackFileBox.y + playbackFileBox.h), playbackWidth, h, globalPadding);

        synthChannelCountBox = new SyntheticChannelCountBox(x + w, dataSourceBox.y, w, h, globalPadding);
        bfStreamerBoxSynthetic = new BrainFlowStreamerBox(x + w, (synthChannelCountBox.y + synthChannelCountBox.h), w, h, globalPadding, "bfStreamerSynthetic");
        
        streamingBoardBox = new StreamingBoardBox(x + w, dataSourceBox.y, w, h, globalPadding);

        channelPopup = new ChannelPopup(x+w, y, w, h, globalPadding);

        initBox = new InitBox(x, (dataSourceBox.y + dataSourceBox.h), w, h, globalPadding);

        // Ganglion
        bleBox = new BLEBox(x + w, interfaceBoxGanglion.y + interfaceBoxGanglion.h, w, h, globalPadding);
        dataLogBoxGanglion = new SessionDataBox(x + w, (bleBox.y + bleBox.h), w, h, globalPadding, DATASOURCE_GANGLION, dataLogger.getDataLoggerOutputFormat(), "sessionNameGanglion");
        bfStreamerBoxGanglion = new BrainFlowStreamerBox(x + w, (dataLogBoxGanglion.y + dataLogBoxGanglion.h), w, h, globalPadding, "bfStreamerGanglion");
        sampleRateGanglionBox = new SampleRateGanglionBox(x + w, (bfStreamerBoxGanglion.y + bfStreamerBoxGanglion.h), w, h, globalPadding);

    }

    public void resetListItems(){
        comPortBox.serialList.activeItem = -1;
        bleBox.bleList.activeItem = -1;
        wifiBox.wifiList.activeItem = -1;
    }

    public void open(){
        isOpen = true;
        topNav.controlPanelCollapser.setOn();
        topNav.setDropdownMenuIsOpen(true);
    }

    public void close(){
        isOpen = false;
        topNav.controlPanelCollapser.setOff();
        topNav.setDropdownMenuIsOpen(false);
    }

    public String getWifiSearchStyle() {
        return wifiSearchStyle;
    }

    private void setWiFiSearchStyle(String s) {
        wifiSearchStyle = s;
    }

    public void update() {
        //update all boxes if they need to be
        dataSourceBox.update();
        serialBox.update();
        bleBox.update();
        dataLogBoxCyton.update();
        channelCountBox.update();
        synthChannelCountBox.update();

        //update playback box sizes when dropdown is selected
        recentPlaybackBox.update();
        playbackFileBox.update();

        streamingBoardBox.update();

        bfStreamerBoxCyton.update();
        bfStreamerBoxGanglion.update();
        bfStreamerBoxSynthetic.update();

        sdBox.update();
        rcBox.update();
        comPortBox.update();
        initBox.update();

        channelPopup.update();

        dataLogBoxGanglion.update();

        wifiBox.update();
        interfaceBoxCyton.update();
        interfaceBoxGanglion.update();
    }

    public void draw() {

        initBox.draw();

        if (systemMode == 10) {
            drawStopInstructions = true;
        }

        if (systemMode != 10) { // only draw control panel boxes if system running is false
            dataSourceBox.draw();
            drawStopInstructions = false;

            //Carefully draw certain boxes based on UI/UX flow... let each box handle what is drawn inside with localCp5 instances
            if (eegDataSource == DATASOURCE_CYTON) {	//when data source is from OpenBCI
                interfaceBoxCyton.draw();
                if (selectedProtocol != BoardProtocol.NONE) {
                    if (selectedProtocol == BoardProtocol.SERIAL) {
                        serialBox.y = interfaceBoxCyton.y + interfaceBoxCyton.h;
                        serialBox.draw();
                        channelCountBox.y = serialBox.y + serialBox.h;
                        if (rcBox.isShowing) {
                            comPortBox.draw();
                            rcBox.draw();
                            comPortBox.serialList.setVisible(true);
                            if (channelPopup.wasClicked()) {
                                channelPopup.draw();
                            }
                        }
                    } else if (selectedProtocol == BoardProtocol.WIFI) {
                        wifiBox.y = interfaceBoxCyton.y;
                        wifiBox.x = interfaceBoxCyton.x + interfaceBoxCyton.w;
                        sampleRateCytonBox.y = wifiBox.y + wifiBox.h;
                        channelCountBox.y = interfaceBoxCyton.y + interfaceBoxCyton.h;
                        wifiBox.draw();
                        sampleRateCytonBox.draw();
                    }
                    dataLogBoxCyton.y = channelCountBox.y + channelCountBox.h;
                    bfStreamerBoxCyton.y = dataLogBoxCyton.y + dataLogBoxCyton.h;
                    sdBox.y = bfStreamerBoxCyton.y + bfStreamerBoxCyton.h;
                    channelCountBox.draw();
                    sdBox.draw();
                    bfStreamerBoxCyton.draw();
                    dataLogBoxCyton.draw(); //Drawing here allows max file size dropdown to be drawn on top
                }
            } else if (eegDataSource == DATASOURCE_PLAYBACKFILE) { //when data source is from playback file
                recentPlaybackBox.draw();
                playbackFileBox.draw();
            } else if (eegDataSource == DATASOURCE_SYNTHETIC) {  //synthetic
                synthChannelCountBox.draw();
                bfStreamerBoxSynthetic.draw();
            } else if (eegDataSource == DATASOURCE_GANGLION) {
                if (selectedProtocol == BoardProtocol.NONE) {
                    interfaceBoxGanglion.draw();
                } else {
                    interfaceBoxGanglion.draw();
                    if (selectedProtocol == BoardProtocol.BLED112 || selectedProtocol == BoardProtocol.NATIVE_BLE) {
                        bleBox.y = interfaceBoxGanglion.y + interfaceBoxGanglion.h;
                        dataLogBoxGanglion.y = bleBox.y + bleBox.h;
                        bleBox.draw();
                    } else if (selectedProtocol == BoardProtocol.WIFI) {
                        wifiBox.y = interfaceBoxGanglion.y;
                        wifiBox.x = interfaceBoxGanglion.x + interfaceBoxGanglion.w;
                        sampleRateGanglionBox.y = wifiBox.y + wifiBox.h;
                        sampleRateGanglionBox.x = wifiBox.x;
                        dataLogBoxGanglion.y = interfaceBoxGanglion.y + interfaceBoxGanglion.h;
                        wifiBox.draw();
                        sampleRateGanglionBox.draw();
                    }
                    bfStreamerBoxGanglion.y = dataLogBoxGanglion.y + dataLogBoxGanglion.h;
                    bfStreamerBoxGanglion.draw();
                    dataLogBoxGanglion.draw(); //Drawing here allows max file size dropdown to be drawn on top
                }
            } else if (eegDataSource == DATASOURCE_STREAMING) {
                streamingBoardBox.draw();
            }
        }

        //draw the box that tells you to stop the system in order to edit control settings
        if (drawStopInstructions) {
            pushStyle();
            fill(boxColor);
            strokeWeight(1);
            stroke(boxStrokeColor);
            rect(x, y, w, dataSourceBox.h); //draw background of box
            String stopInstructions = "Press the \"STOP SESSION\" button to change your data source or edit system settings.";
            textAlign(CENTER, TOP);
            textFont(p4, 14);
            fill(OPENBCI_DARKBLUE);
            text(stopInstructions, x + globalPadding*2, y + globalPadding*3, w - globalPadding*4, dataSourceBox.h - globalPadding*4);
            popStyle();
        }
    }

    public void hideRadioPopoutBox() {
        rcBox.isShowing = false;
        comPortBox.isShowing = false;
        serialBox.popOutRadioConfigButton.getCaptionLabel().setText("Manual >");
        rcBox.closeSerialPort();
    }

    private void hideChannelListCP() {
        channelPopup.setClicked(false);
    }

    public void fetchSessionNameTextfieldAllBoards() {
        String s = "";
        if (eegDataSource == DATASOURCE_CYTON) {
            // Store the current text field value of "Session Name" to be passed along to dataFiles
            s = dataLogBoxCyton.getSessionTextfieldString();
        } else if (eegDataSource == DATASOURCE_GANGLION) {
            s = dataLogBoxGanglion.getSessionTextfieldString();
        } else {
            s = directoryManager.getFileNameDateTime();
        }
        dataLogger.setSessionName(s);
        StringBuilder sb = new StringBuilder(directoryManager.getRecordingsPath());
        sb.append("OpenBCISession_");
        sb.append(dataLogger.getSessionName());
        sb.append(File.separator);
        settings.setSessionPath(sb.toString());
    }

    public void setDataLoggerOutputs() {
        if (eegDataSource == DATASOURCE_CYTON) {
            // Store the current text field value of "Session Name" to be passed along to dataFiles
            dataLogger.setSessionName(controlPanel.dataLogBoxCyton.getSessionTextfieldString());
        } else if (eegDataSource == DATASOURCE_GANGLION) {
            dataLogger.setSessionName(controlPanel.dataLogBoxGanglion.getSessionTextfieldString());
        } else if (eegDataSource == DATASOURCE_SYNTHETIC) {
            dataLogger.setSessionName(directoryManager.getFileNameDateTime());
        }
    }

    public void setBrainFlowStreamerOutput() {
        if (getIsBrainFlowSteamerDefaultFileOutput()) {
            dataLogger.setBfWriterDefaultFolder();
        }

        if (eegDataSource == DATASOURCE_CYTON) {
            brainflowStreamer = bfStreamerBoxCyton.getBrainFlowStreamerString();
        } else if (eegDataSource == DATASOURCE_GANGLION) {
            brainflowStreamer = bfStreamerBoxGanglion.getBrainFlowStreamerString();
        } else if (eegDataSource == DATASOURCE_SYNTHETIC) {
            brainflowStreamer = bfStreamerBoxSynthetic.getBrainFlowStreamerString();
        }
    }

    private boolean getIsBrainFlowSteamerDefaultFileOutput() {
        boolean b = false;
        if (eegDataSource == DATASOURCE_CYTON) {
            b = bfStreamerBoxCyton.getIsBrainFlowStreamerDefaultLocation();
        } else if (eegDataSource == DATASOURCE_GANGLION) {
            b = bfStreamerBoxGanglion.getIsBrainFlowStreamerDefaultLocation();
        } else if (eegDataSource == DATASOURCE_SYNTHETIC) {
            b = bfStreamerBoxSynthetic.getIsBrainFlowStreamerDefaultLocation();
        }
        return b;
    }

}; //end of ControlPanel class

//==============================================================================//
//                	BELOW ARE THE CLASSES FOR THE VARIOUS                       //
//                	CONTROL PANEL BOXES (control widgets)                       //
//==============================================================================//

class DataSourceBox {
    public int x, y, w, h, padding; //size and position
    private int numItems;
    private int boxHeight = 24;
    private int spacing = 43;
    private ControlP5 datasource_cp5;
    private MenuList sourceList;

    DataSourceBox(int _x, int _y, int _w, int _h, int _padding) {
        numItems = 5;
        x = _x;
        y = _y;
        w = _w;
        h = spacing + (numItems * boxHeight);
        padding = _padding;

        //Instantiate local cp5 for this box
        datasource_cp5 = new ControlP5(ourApplet);
        datasource_cp5.setGraphics(ourApplet, 0,0);
        datasource_cp5.setAutoDraw(false);
        createDatasourceList(datasource_cp5, "sourceList", x + padding, y + padding*2 + 13, w - padding*2, numItems * boxHeight, p3);
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("DATA SOURCE", x + padding, y + padding);
        popStyle();
        
        datasource_cp5.draw();
    }

    private void createDatasourceList(ControlP5 _cp5, String name, int _x, int _y, int _w, int _h, PFont font) {
        sourceList = new MenuList(_cp5, name, _w, _h, font);
        sourceList.setPosition(_x, _y);
        // sourceList.itemHeight = 28;
        // sourceList.padding = 9;
        sourceList.addItem("CYTON (live)", DATASOURCE_CYTON);
        sourceList.addItem("GANGLION (live)", DATASOURCE_GANGLION);
        sourceList.addItem("PLAYBACK (from file)", DATASOURCE_PLAYBACKFILE);
        sourceList.addItem("SYNTHETIC (algorithmic)", DATASOURCE_SYNTHETIC);
        sourceList.addItem("STREAMING (from external)", DATASOURCE_STREAMING);
        sourceList.scrollerLength = 10;
        sourceList.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                    Map bob = sourceList.getItem(PApplet.parseInt(sourceList.getValue()));
                    String str = (String)bob.get("headline"); // Get the text displayed in the MenuList
                    int newDataSource = (int)bob.get("value");
                    settings.controlEventDataSource = str; //Used for output message on system start
                    eegDataSource = newDataSource;

                    //Reset protocol
                    selectedProtocol = BoardProtocol.NONE;

                    //Perform this check in a way that ignores order of items in the menulist
                    if (eegDataSource == DATASOURCE_CYTON) {
                        controlPanel.channelCountBox.set8ChanButtonActive();
                        controlPanel.interfaceBoxCyton.resetCytonSelectedProtocol();
                        controlPanel.wifiBox.setDefaultToDynamicIP();
                    } else if (eegDataSource == DATASOURCE_GANGLION) {
                        updateToNChan(4);
                        controlPanel.interfaceBoxGanglion.resetGanglionSelectedProtocol();
                        controlPanel.wifiBox.setDefaultToDynamicIP();
                    } else if (eegDataSource == DATASOURCE_PLAYBACKFILE) {
                        //GUI auto detects number of channels for playback when file is selected
                    } else if (eegDataSource == DATASOURCE_STREAMING) {
                        //do nothing for now
                    } else if (eegDataSource == DATASOURCE_SYNTHETIC) {
                        controlPanel.synthChannelCountBox.set8ChanButtonActive();
                    }
                }
            }
        });
    }
};

class SerialBox {
    public int x, y, w, h, padding; //size and position
    private ControlP5 cytonsb_cp5;
    private Button autoConnectButton;
    private Button popOutRadioConfigButton;

    SerialBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 70;
        padding = _padding;

        //Instantiate local cp5 for this box
        cytonsb_cp5 = new ControlP5(ourApplet);
        cytonsb_cp5.setGraphics(ourApplet, 0,0);
        cytonsb_cp5.setAutoDraw(false);

        createAutoConnectButton("cytonAutoConnectButton", "AUTO-CONNECT", x + padding, y + padding*3 + 4, w - padding*3 - 70, 24);
        createRadioConfigButton("cytonRadioConfigButton", "Manual >", x + w - 70 - padding, y + padding*3 + 4, 70, 24);
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("SERIAL CONNECT", x + padding, y + padding);
        popStyle();

        if (selectedProtocol == BoardProtocol.SERIAL) {
            cytonsb_cp5.draw();
        }
    }

    private Button createSBButton(String name, String text, int _x, int _y, int _w, int _h) {
        return createButton(cytonsb_cp5, name, text, _x, _y, _w, _h, 0, p5, 12, colorNotPressed, OPENBCI_DARKBLUE, BUTTON_HOVER, BUTTON_PRESSED, OPENBCI_DARKBLUE, 0);
    }

    private void createAutoConnectButton(String name, String text, int _x, int _y, int _w, int _h) {
        autoConnectButton = createSBButton(name, text, _x, _y, _w, _h);
        autoConnectButton.setColorBackground(TURN_ON_GREEN);
        autoConnectButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                controlPanel.comPortBox.attemptAutoConnectCyton();
            }
        });
        autoConnectButton.setDescription("Attempt to auto-connect to Cyton. Try \"Manual\" if this does not work.");
    }

    private void createRadioConfigButton(String name, String text, int _x, int _y, int _w, int _h) {
        popOutRadioConfigButton = createSBButton(name, text, _x, _y, _w, _h);
        popOutRadioConfigButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (selectedProtocol == BoardProtocol.SERIAL) {
                    if (controlPanel.rcBox.isShowing) {
                        controlPanel.hideRadioPopoutBox();
                    } else {
                        controlPanel.rcBox.isShowing = true;
                        controlPanel.rcBox.print_onscreen(controlPanel.rcBox.initial_message);
                        popOutRadioConfigButton.getCaptionLabel().setText("Manual <");
                    }
                }
            }
        });
        popOutRadioConfigButton.setDescription("Having trouble connecting to Cyton? Click here to access Radio Configuration tools.");
    }
};

class ComPortBox {
    public int x, y, w, h, padding; //size and position
    public boolean isShowing;
    private ControlP5 cytoncpb_cp5;
    private Button refreshCytonDongles;
    public MenuList serialList;
    public RadioConfig cytonRadioCfg;
    private boolean midAutoScan = false;
    private boolean midAutoScanCheck2 = false;

    ComPortBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w + 10;
        h = 140 + _padding;
        padding = _padding;
        isShowing = false;
        cytonRadioCfg = new RadioConfig();

        //Instantiate local cp5 for this box
        cytoncpb_cp5 = new ControlP5(ourApplet);
        cytoncpb_cp5.setGraphics(ourApplet, 0,0);
        cytoncpb_cp5.setAutoDraw(false);

        createRefreshCytonDonglesButton("refreshCytonDonglesButton", "REFRESH LIST", x + padding, y + padding*4 + 72 + 8, w - padding*2, 24);
        createCytonDongleList(cytoncpb_cp5, "cytonDongleList", x + padding, y + padding*3 + 8,  w - padding*2, 72, p3);
    }

    public void update() {
        serialList.updateMenu();
        //Allow two drawing/update cycles to pass so that overlay can be drawn
        //This lets users know that auto-scan is working and GUI is not frozen
        if (midAutoScan) {
            if (midAutoScanCheck2) {
                cytonAutoConnect_AutoScan();
                midAutoScanCheck2 = false;
                midAutoScan = midAutoScanCheck2;
            }
            midAutoScanCheck2 = midAutoScan;
        }
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("SERIAL/COM PORT", x + padding, y + padding);
        popStyle();

        cytoncpb_cp5.draw();
    }

    private void createRefreshCytonDonglesButton(String name, String text, int _x, int _y, int _w, int _h) {
        refreshCytonDongles = createButton(cytoncpb_cp5, name, text, _x, _y, _w, _h);
        refreshCytonDongles.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                refreshPortListCyton();
            }
        });
    }

    private void createCytonDongleList(ControlP5 _cp5, String name, int _x, int _y, int _w, int _h, PFont font) {
        serialList = new MenuList(_cp5, name, _w, _h, font);
        serialList.setPosition(_x, _y);
        serialList.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                    Map bob = serialList.getItem(PApplet.parseInt(serialList.getValue()));
                    openBCI_portName = (String)bob.get("subline");
                    output("ControlPanel: Selected OpenBCI Port " + openBCI_portName);
                }
            }
        });
    }

    //This is called when the Auto-Connect button is pressed in another Control Panel Box
    public void attemptAutoConnectCyton() {
        println("\n-------------------------------------------------\nControlPanel: Attempting to Auto-Connect to Cyton\n-------------------------------------------------\n");
        LinkedList<String> comPorts = getCytonComPorts();
        if (!comPorts.isEmpty()) {
            openBCI_portName = comPorts.getFirst();
            if (cytonRadioCfg.get_channel()) {
                controlPanel.initBox.initButtonPressed();
            } else {                
                outputWarn("Found a Cyton dongle, but could not connect to the board. Auto-Scanning now...");
                midAutoScan = true;
            }
        } else {
            outputWarn("No Cyton dongles were found.");
        }
    }

    //If Cyton dongle exists, and fails to connect, try to Auto-Scan in the background to align Cyton/Dongle Channel
    //This is called after overlay has a chance to draw on top to inform users the GUI is working and not crashed
    private void cytonAutoConnect_AutoScan() {
        if (cytonRadioCfg.scan_channels()) {
            println("Successfully connected to Cyton using " + openBCI_portName);
            controlPanel.initBox.initButtonPressed();
        } else {
            outputError("Unable to connect to Cyton. Please check hardware and power source.");
        }
    }

    //Refresh the Cyton Dongle list
    public void refreshPortListCyton(){
        serialList.items.clear();

        Thread thread = new Thread(){
            public void run(){
                refreshCytonDongles.getCaptionLabel().setText("SEARCHING...");

                LinkedList<String> comPorts = getCytonComPorts();
                for (String comPort : comPorts) {
                    serialList.addItem("(Cyton) " + comPort, comPort, "");
                }
                serialList.updateMenu();
                refreshCytonDongles.getCaptionLabel().setText("REFRESH LIST");
            }
        };

        thread.start();
    }

    private LinkedList<String> getCytonComPorts() {
        final String[] names = {"FT231X USB UART", "VCP"};
        final SerialPort[] comPorts = SerialPort.getCommPorts();
        LinkedList<String> results = new LinkedList<String>();
        for (SerialPort comPort : comPorts) {
            for (String name : names) {
                if (comPort.toString().startsWith(name)) {
                    // on macos need to drop tty ports
                    if (isMac() && comPort.getSystemPortName().startsWith("tty")) {
                        continue;
                    }
                    String found = "";
                    if (isMac() || isLinux()) found += "/dev/";
                    found += comPort.getSystemPortName();
                    println("ControlPanel: Found Cyton Dongle on COM port: " + found);
                    results.add(found);
                }
            }
        }

        return results;
    }

    public boolean isAutoScanningForCytonSerial() {
        return midAutoScan;
    }
};

class BLEBox {
    public int x, y, w, h, padding; //size and position
    private volatile boolean bleIsRefreshing = false;
    private ControlP5 bleBox_cp5;
    private MenuList bleList;
    private Button refreshBLE;
    Map<String, String> bleMACAddrMap = new HashMap<String, String>();

    BLEBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 140 + _padding;
        padding = _padding;

        //Instantiate local cp5 for this box
        bleBox_cp5 = new ControlP5(ourApplet);
        bleBox_cp5.setGraphics(ourApplet, 0,0);
        bleBox_cp5.setAutoDraw(false);

        createRefreshBLEButton("refreshGanglionBLEButton", "START SEARCH", x + padding, y + padding*4 + 72 + 8, w - padding*5, 24);
        createGanglionBLEMenuList(bleBox_cp5, "bleList", x + padding, y + padding*3 + 8, w - padding*2, 72, p3);
    }

    public void update() {
        bleList.updateMenu();
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("BLE DEVICES", x + padding, y + padding);
        popStyle();

        if (bleIsRefreshing) {
            //Display spinning cog gif
            image(loadingGIF_blue, w + 225,  refreshBLE.getPosition()[1] + 4, 20, 20);
        } else {
            //Draw small grey circle
            pushStyle();
            fill(0xFF999999);
            ellipseMode(CENTER);
            ellipse(w + 225 + 10, refreshBLE.getPosition()[1] + 12, 12, 12);
            popStyle();
        }

        bleBox_cp5.draw();
    }

    private void refreshGanglionNativeList() {
        if (bleIsRefreshing) {
            output("Search for Ganglions using Native Bluetooth is in progress.");
            return;
        }
        output("Refreshing available Ganglions using Native Bluetooth...");
        bleList.items.clear();
        
        Thread thread = new Thread(){
            public void run(){
                refreshBLE.getCaptionLabel().setText("SEARCHING...");
                bleIsRefreshing = true;

                try {
                    bleMACAddrMap = GUIHelper.scan_for_ganglions (3);
                    for (Map.Entry<String, String> entry : bleMACAddrMap.entrySet ())
                    {
                        bleList.addItem(entry.getKey(),  entry.getValue(), "");
                        bleList.updateMenu();
                        println("Found Ganglion Board: " + entry.getKey() + " " + entry.getValue());
                    }
                } catch (GanglionError e)
                {
                    e.printStackTrace();
                }

                refreshBLE.getCaptionLabel().setText("START SEARCH");
                bleIsRefreshing = false;
            }
        };

        thread.start();
    }

    private void refreshGanglionBLEList() {
        if (bleIsRefreshing) {
            output("Search for Ganglions using BLED112 Dongle is in progress.");
            return;
        }
        output("Refreshing available Ganglions using BLED112 Dongle...");
        bleList.items.clear();
        
        Thread thread = new Thread(){
            public void run(){
                refreshBLE.getCaptionLabel().setText("SEARCHING...");
                bleIsRefreshing = true;
                final String comPort = getBLED112Port();
                if (comPort != null) {
                    try {
                        bleMACAddrMap = GUIHelper.scan_for_ganglions (comPort, 3);
                        for (Map.Entry<String, String> entry : bleMACAddrMap.entrySet ())
                        {
                            bleList.addItem(entry.getKey(), comPort, "");
                            bleList.updateMenu();
                        }
                    } catch (GanglionError e)
                    {
                        e.printStackTrace();
                    }
                } else {
                    outputError("No BLED112 Dongle Found");
                }
                refreshBLE.getCaptionLabel().setText("START SEARCH");
                bleIsRefreshing = false;
            }
        };

        thread.start();
    }

    public String getBLED112Port() {
        String name = "Low Energy Dongle";
        SerialPort[] comPorts = SerialPort.getCommPorts();
        for (int i = 0; i < comPorts.length; i++) {
            if (comPorts[i].toString().equals(name)) {
                String found = "";
                if (isMac() || isLinux()) found += "/dev/";
                found += comPorts[i].getSystemPortName().toString();
                println("ControlPanel: Found BLED112 Dongle on COM port: " + found);
                return found;
            }
        }
        return null;
    }

    private void createRefreshBLEButton(String name, String text, int _x, int _y, int _w, int _h) {
        refreshBLE = createButton(bleBox_cp5, name, text, _x, _y, _w, _h);
        refreshBLE.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (selectedProtocol == BoardProtocol.BLED112) {
                    refreshGanglionBLEList();
                } else {
                    refreshGanglionNativeList();
                } 
            }
        });
    }

    private void createGanglionBLEMenuList(ControlP5 _cp5, String name, int _x, int _y, int _w, int _h, PFont font) {
        bleList = new MenuList(_cp5, name, _w, _h, font);
        bleList.setPosition(_x, _y);
        bleList.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                    Map bob = bleList.getItem(PApplet.parseInt(bleList.getValue()));
                    ganglion_portName = (String)bob.get("headline");
                    output("Ganglion Device Name = " + ganglion_portName);
                }
            }
        });
    }
};

class WifiBox {
    public int x, y, w, h, padding; //size and position
    private boolean wifiIsRefreshing = false;
    private ControlP5 wifiBox_cp5;
    private MenuList wifiList;
    private Button refreshWifi;
    private Button wifiIPAddressDynamic;
    private Button wifiIPAddressStatic;
    private Textfield staticIPAddressTF;
    private int wifiDynamic_x;
    private int wifiStatic_x;
    private int wifiButtons_y;
    private int refreshWifi_x;
    private int refreshWifi_y;

    WifiBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 184 + _padding + 14;
        padding = _padding;

        //Instantiate local cp5 for this box
        wifiBox_cp5 = new ControlP5(ourApplet);
        wifiBox_cp5.setGraphics(ourApplet, 0,0);
        wifiBox_cp5.setAutoDraw(false);

        wifiDynamic_x = x + padding;
        wifiStatic_x = x + padding*2 + (w-padding*3)/2;
        wifiButtons_y = y + padding*2 + 16;
        createDynamicIPAddressButton("wifiIPAddressDynamicButton", "DYNAMIC IP", wifiDynamic_x, wifiButtons_y, (w-padding*3)/2, 24);
        createStaticIPAddressButton("wifiIPAddressStaticButton", "STATIC IP", wifiStatic_x, wifiButtons_y, (w-padding*3)/2, 24);

        refreshWifi_x = x + padding;
        refreshWifi_y = y + padding*5 + 72 + 8 + 24;
        createRefreshWifiButton("refreshWifiButton", "START SEARCH", refreshWifi_x, refreshWifi_y, w - padding*5, 24);
        createWifiList(wifiBox_cp5, "wifiList", x + padding, y + padding*4 + 8 + 24, w - padding*2, 72 + 8, p3);
        createStaticIPAddressTextfield();
    }

    public void update() {
        wifiList.updateMenu();
        copyPaste.checkForCopyPaste(staticIPAddressTF);
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("WIFI SHIELDS", x + padding, y + padding);
        popStyle();

        wifiDynamic_x = x + padding;
        wifiStatic_x = x + padding*2 + (w-padding*3)/2;
        wifiButtons_y = y + padding*2 + 16;
        wifiIPAddressDynamic.setPosition(wifiDynamic_x, wifiButtons_y);
        wifiIPAddressStatic.setPosition(wifiStatic_x, wifiButtons_y);

        if (controlPanel.getWifiSearchStyle() == controlPanel.WIFI_STATIC) {
            pushStyle();
            fill(OPENBCI_DARKBLUE);
            textFont(h3, 16);
            textAlign(LEFT, TOP);
            text("ENTER IP ADDRESS", x + padding, y + h - 24 - 12 - padding*2);
            popStyle();
            staticIPAddressTF.setPosition(x + padding, y + h - 24 - padding);
        } else {
            wifiList.setPosition(x + padding, wifiButtons_y + 24 + padding);

            refreshWifi_x = x + padding;
            refreshWifi_y = y + padding*5 + 72 + 8 + 24;
            refreshWifi.setPosition(refreshWifi_x, refreshWifi_y);

            String boardIpInfo = "BOARD IP: ";
            if (wifi_portName != "N/A") { // If user has selected a board from the menulist...
                boardIpInfo += wifi_ipAddress;
            }
            pushStyle();
            fill(OPENBCI_DARKBLUE);
            textFont(h3, 16);
            textAlign(LEFT, TOP);
            text(boardIpInfo, x + w/2 - textWidth(boardIpInfo)/2, y + h - padding - 15);
            popStyle();

            if (wifiIsRefreshing){
                //Display spinning cog gif
                image(loadingGIF_blue, x + 225,  refreshWifi_y + 4, 20, 20);
            } else {
                //Draw small grey circle
                pushStyle();
                fill(0xFF999999);
                ellipseMode(CENTER);
                ellipse(x + 225 + 10, refreshWifi_y + 12, 12, 12);
                popStyle();
            }
        }

        wifiBox_cp5.draw();
    }

    public void refreshWifiList() {
        output("Wifi Devices Refreshing");
        wifiList.items.clear();
        Thread thread = new Thread(){
            public void run() {
                refreshWifi.getCaptionLabel().setText("SEARCHING...");
                wifiIsRefreshing = true;
                try {
                    List<Device> devices = SSDPClient.discover (3000, "urn:schemas-upnp-org:device:Basic:1");
                    if (devices.isEmpty ()) {
                        println("No WIFI Shields found");
                    }
                    for (int i = 0; i < devices.size(); i++) {
                        wifiList.addItem(devices.get(i).getName(), devices.get(i).getIPAddress(), "");
                    }
                    wifiList.updateMenu();
                } catch (Exception e) {
                    println("Exception in wifi shield scanning");
                    e.printStackTrace ();
                }
                refreshWifi.getCaptionLabel().setText("START SEARCH");
                wifiIsRefreshing = false;
            }
        };
        thread.start();
    }

    private void createDynamicIPAddressButton(String name, String text, int _x, int _y, int _w, int _h) {
        wifiIPAddressDynamic = createButton(wifiBox_cp5, name, text, _x, _y, _w, _h);
        wifiIPAddressDynamic.setSwitch(true);
        wifiIPAddressDynamic.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                h = 208;
                controlPanel.setWiFiSearchStyle(controlPanel.WIFI_DYNAMIC);
                println("ControlPanel: Using Dynamic IP address of the WiFi Shield!");
                wifiIPAddressDynamic.setOn();
                wifiIPAddressStatic.setOff();
                staticIPAddressTF.setVisible(false);
                wifiList.setVisible(true);
            }
        });
        wifiIPAddressDynamic.setOn();
    }

    private void createStaticIPAddressButton(String name, String text, int _x, int _y, int _w, int _h) {
        wifiIPAddressStatic = createButton(wifiBox_cp5, name, text, _x, _y, _w, _h);
        wifiIPAddressStatic.setSwitch(true);
        wifiIPAddressStatic.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                h = 120;
                controlPanel.setWiFiSearchStyle(controlPanel.WIFI_STATIC);
                println("ControlPanel: Using Static IP address of the WiFi Shield!");
                wifiIPAddressDynamic.setOff();
                wifiIPAddressStatic.setOn();
                staticIPAddressTF.setVisible(true);
                wifiList.setVisible(false);
            }
        });
    }

    private void createRefreshWifiButton(String name, String text, int _x, int _y, int _w, int _h) {
        refreshWifi = createButton(wifiBox_cp5, name, text, _x, _y, _w, _h);
        refreshWifi.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                refreshWifiList();
            }
        });
    }

    private void createWifiList(ControlP5 _cp5, String name, int _x, int _y, int _w, int _h, PFont font) {
        wifiList = new MenuList(_cp5, name, _w, _h, font);
        wifiList.setPosition(_x, _y);
        wifiList.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                    Map bob = wifiList.getItem(PApplet.parseInt(wifiList.getValue()));
                    wifi_portName = (String)bob.get("headline");
                    wifi_ipAddress = (String)bob.get("subline");
                    output("Selected WiFi Board: " + wifi_portName+ ", WiFi IP Address: " + wifi_ipAddress );
                }
            }
        });
    }

    private void createStaticIPAddressTextfield() {
        staticIPAddressTF = wifiBox_cp5.addTextfield("staticIPAddress")
            .setPosition(x + 90, y + 100)
            .setCaptionLabel("")
            .setSize(w - padding*2, 26)
            .setFont(f2)
            .setFocus(false)
            .setColor(color(26, 26, 26))
            .setColorBackground(color(255, 255, 255)) // text field bg color
            .setColorValueLabel(OPENBCI_DARKBLUE)  // text color
            .setColorForeground(OPENBCI_DARKBLUE)  // border color when not selected
            .setColorActive(isSelected_color)  // border color when selected
            .setColorCursor(color(26, 26, 26))
            .setText(wifi_ipAddress)
            .align(5, 10, 20, 40)
            .setAutoClear(true)
            .setVisible(false);
        //Clear textfield on double click
        staticIPAddressTF.onDoublePress(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                output("WiFi Static IP: Enter your custom IP address for WiFi shield.");
                staticIPAddressTF.clear();
            }
        });
    }

    public void setDefaultToDynamicIP() {
        h = 208;
        controlPanel.setWiFiSearchStyle(controlPanel.WIFI_DYNAMIC);
        wifiIPAddressDynamic.setOn();
        wifiIPAddressStatic.setOff();
        staticIPAddressTF.setVisible(false);
        wifiList.setVisible(true);
    }

    private void setStaticIPTextfield(String text) {
        staticIPAddressTF.setText(text);
    }
};

class InterfaceBoxCyton {
    public int x, y, w, h, padding; //size and position
    private ControlP5 ifbc_cp5;
    private Button protocolSerialCyton;
    private Button protocolWifiCyton;

    InterfaceBoxCyton(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = (24 + _padding) * 3;
        padding = _padding;

        //Instantiate local cp5 for this box
        ifbc_cp5 = new ControlP5(ourApplet);
        ifbc_cp5.setGraphics(ourApplet, 0,0);
        ifbc_cp5.setAutoDraw(false);

        //Disabled both toggles by default for this box
        createSerialCytonButton("protocolSerialCyton", "Serial (from Dongle)", false, x + padding, y + padding * 3 + 4, w - padding * 2, 24);
        createWifiCytonButton("protocolWifiCyton", "Wifi (from Wifi Shield)", false, x + padding, y + padding * 4 + 24 + 4, w - padding * 2, 24);
    }

    public void update() {}

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("PICK TRANSFER PROTOCOL", x + padding, y + padding);
        popStyle();

        ifbc_cp5.draw();
    }

    private Button createIFBCButton(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        final Button b = createButton(ifbc_cp5, name, text, _x, _y, _w, _h);
        b.setSwitch(true); //This turns the button into a switch
        if (isToggled) {
            b.setOn();
        }
        return b;
    }

    private void createSerialCytonButton(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        protocolSerialCyton = createIFBCButton(name, text, isToggled, _x, _y, _w, _h);
        protocolSerialCyton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                controlPanel.wifiBox.wifiList.items.clear();
                controlPanel.bleBox.bleList.items.clear();
                selectedProtocol = BoardProtocol.SERIAL;
                controlPanel.comPortBox.refreshPortListCyton();
                protocolSerialCyton.setOn();
                protocolWifiCyton.setOff();
            }
        });
    }

    private void createWifiCytonButton(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        protocolWifiCyton = createIFBCButton(name, text, isToggled, _x, _y, _w, _h);
        protocolWifiCyton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                controlPanel.wifiBox.wifiList.items.clear();
                controlPanel.bleBox.bleList.items.clear();
                selectedProtocol = BoardProtocol.WIFI;
                protocolSerialCyton.setOff();
                protocolWifiCyton.setOn();
            }
        });
    }

    public void resetCytonSelectedProtocol() {
        protocolSerialCyton.setOff();
        protocolWifiCyton.setOff();
        selectedProtocol = BoardProtocol.NONE;
    }
};

class InterfaceBoxGanglion {
    public int x, y, w, h, padding; //size and position
    private ControlP5 ifbg_cp5;
    private Button protocolGanglionNativeBLE;
    private Button protocolBLED112Ganglion;
    private Button protocolWifiGanglion;

    InterfaceBoxGanglion(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        padding = _padding;
        h = (24 + _padding) * 4;
        int buttonHeight = 24;

            //Instantiate local cp5 for this box
        ifbg_cp5 = new ControlP5(ourApplet);
        ifbg_cp5.setGraphics(ourApplet, 0,0);
        ifbg_cp5.setAutoDraw(false);

        createGanglionNativeBLEButton("protocolNativeBLEGanglion", "Bluetooth (Native)", false, x + padding, y + padding * 3 + 4, w - padding * 2, 24);
        createBLED112Button("protocolBLED112Ganglion", "Bluetooth (BLED112 Dongle)", false, x + padding, y + (padding * 4) + 24 + 4, w - padding * 2, 24);
        createGanglionWifiButton("protocolWifiGanglion", "Wifi (from Wifi Shield)", false, x + padding, y + (padding * 5) + (24 * 2) + 4, w - padding * 2, 24);
    }

    public void update() {}

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("PICK TRANSFER PROTOCOL", x + padding, y + padding);
        popStyle();
        
        ifbg_cp5.draw();
    }


    private Button createIFBGButton(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        final Button b = createButton(ifbg_cp5, name, text, _x, _y, _w, _h);
        b.setSwitch(true); //This turns the button into a switch
        if (isToggled) {
            b.setOn();
        }
        return b;
    }

    private void createGanglionNativeBLEButton(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        protocolGanglionNativeBLE = createIFBGButton(name, text, isToggled, _x, _y, _w, _h);
        protocolGanglionNativeBLE.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                controlPanel.wifiBox.wifiList.items.clear();
                controlPanel.bleBox.bleList.items.clear();
                selectedProtocol = BoardProtocol.NATIVE_BLE;
                controlPanel.bleBox.refreshGanglionNativeList();
                protocolGanglionNativeBLE.setOn();
                protocolBLED112Ganglion.setOff();
                protocolWifiGanglion.setOff();
            }
        });
    }

    private void createBLED112Button(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        protocolBLED112Ganglion = createIFBGButton(name, text, isToggled, _x, _y, _w, _h);
        protocolBLED112Ganglion.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                controlPanel.wifiBox.wifiList.items.clear();
                controlPanel.bleBox.bleList.items.clear();
                selectedProtocol = BoardProtocol.BLED112;
                controlPanel.bleBox.refreshGanglionBLEList();
                protocolGanglionNativeBLE.setOff();
                protocolBLED112Ganglion.setOn();
                protocolWifiGanglion.setOff();
            }
        });
    }

    private void createGanglionWifiButton(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        protocolWifiGanglion = createIFBGButton(name, text, isToggled, _x, _y, _w, _h);
        protocolWifiGanglion.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                controlPanel.wifiBox.wifiList.items.clear();
                controlPanel.bleBox.bleList.items.clear();
                selectedProtocol = BoardProtocol.WIFI;
                protocolGanglionNativeBLE.setOff();
                protocolBLED112Ganglion.setOff();
                protocolWifiGanglion.setOn();
            }
        });
    }

    public void resetGanglionSelectedProtocol() {
        protocolGanglionNativeBLE.setOff();
        protocolBLED112Ganglion.setOff();
        protocolWifiGanglion.setOff();
        selectedProtocol = BoardProtocol.NONE;
    }
};

class SessionDataBox {
    public int x, y, w, h, padding; //size and position
    private int datasource;
    private final int bdfModeHeight = 127;
    private int odfModeHeight;

    private ControlP5 sessionData_cp5;
    private int maxDurTextWidth = 82;
    private int maxDurText_x = 0;
    private Textfield sessionNameTextfield;
    private Button autoSessionName;
    private Button outputODF;
    private Button outputBDF;
    private ScrollableList maxDurationDropdown;
    private String odfMessage = "Output has been set to OpenBCI Data Format (CSV).";
    private String bdfMessage = "Output has been set to BioSemi Data Format (BDF+).";

    SessionDataBox (int _x, int _y, int _w, int _h, int _padding, int _dataSource, int output, String textfieldName) {
        datasource = _dataSource;
        odfModeHeight = bdfModeHeight + 24 + _padding;
        x = _x;
        y = _y;
        w = _w;
        h = odfModeHeight;
        padding = _padding;
        maxDurText_x = x + padding;
        maxDurTextWidth += padding*5 + 1;

        //Instantiate local cp5 for this box
        sessionData_cp5 = new ControlP5(ourApplet);
        sessionData_cp5.setGraphics(ourApplet, 0,0);
        sessionData_cp5.setAutoDraw(false);

        createSessionNameTextfield(textfieldName);

        //button to autogenerate file name based on time/date
        createAutoSessionNameButton("autoSessionName", "GENERATE SESSION NAME", x + padding, y + 66, w-(padding*2), 24);
        createODFButton("odfButton", "OpenBCI", dataLogger.getDataLoggerOutputFormat(), x + padding, y + padding*2 + 18 + 58, (w-padding*3)/2, 24);
        createBDFButton("bdfButton", "BDF+", dataLogger.getDataLoggerOutputFormat(), x + padding*2 + (w-padding*3)/2, y + padding*2 + 18 + 58, (w-padding*3)/2, 24);

        createMaxDurationDropdown("maxFileDuration", Arrays.asList(settings.fileDurations));
        
    }

    public void update() {
        copyPaste.checkForCopyPaste(sessionNameTextfield);
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("SESSION DATA", x + padding, y + padding);
        textFont(p4, 14);
        text("Name", x + padding, y + padding*2 + 14);
        popStyle();
        
        //Update the position of UI elements here, as this changes when user selects WiFi mode
        sessionNameTextfield.setPosition(x + 60, y + 32);
        autoSessionName.setPosition(x + padding, y + 66);
        outputODF.setPosition(x + padding, y + padding*2 + 18 + 58);
        outputBDF.setPosition(x + padding*2 + (w-padding*3)/2, y + padding*2 + 18 + 58);
        maxDurationDropdown.setPosition(x + maxDurTextWidth, PApplet.parseInt(outputODF.getPosition()[1]) + 24 + padding);
        
        boolean odfIsSelected = dataLogger.getDataLoggerOutputFormat() == dataLogger.OUTPUT_SOURCE_ODF;
        maxDurationDropdown.setVisible(odfIsSelected);
        
        if (odfIsSelected) {
            pushStyle();
            //draw backgrounds to dropdown scrollableLists ... unfortunately ControlP5 doesn't have this by default, so we have to hack it to make it look nice...
            //Dropdown is drawn at the end of ControlPanel.draw()
            fill(OPENBCI_DARKBLUE);
            maxDurationDropdown.setPosition(x + maxDurTextWidth, PApplet.parseInt(outputODF.getPosition()[1]) + 24 + padding);
            //Carefully draw some text to the left of above dropdown, otherwise this text moves when changing WiFi mode
            int extraPadding = 20;
            fill(OPENBCI_DARKBLUE);
            textFont(p4, 14);
            text("Max File Duration", maxDurText_x, y + h - 24 - padding + extraPadding);
            popStyle();
        }
        sessionData_cp5.draw();
    }

    private void createSessionNameTextfield(String name) {
        //Create textfield to allow user to type custom session folder name
        sessionNameTextfield = sessionData_cp5.addTextfield(name)
            .setPosition(x + 60, y + 32)
            .setCaptionLabel("")
            .setSize(187, 26)
            .setFont(f2)
            .setFocus(false)
            .setColor(color(26, 26, 26))
            .setColorBackground(color(255, 255, 255)) // text field bg color
            .setColorValueLabel(OPENBCI_DARKBLUE)  // text color
            .setColorForeground(OPENBCI_DARKBLUE)  // border color when not selected
            .setColorActive(isSelected_color)  // border color when selected
            .setColorCursor(color(26, 26, 26))
            .setText(directoryManager.getFileNameDateTime())
            .align(5, 10, 20, 40)
            .setAutoClear(false); //Don't clear textfield when pressing Enter key
        //Clear textfield on double click
        sessionNameTextfield.onDoublePress(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                output("SessionData: Enter your custom session name.");
                sessionNameTextfield.clear();
            }
        });
        //Autogenerate session name if user presses Enter key and textfield value is null
        sessionNameTextfield.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST && sessionNameTextfield.getText().equals("")) {
                    autogenerateSessionName();
                }
            }
        });
        //Autogenerate session name if user leaves textfield and value is null
        sessionNameTextfield.onReleaseOutside(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (!sessionNameTextfield.isActive() && sessionNameTextfield.getText().equals("")) {
                    autogenerateSessionName();
                }
            }
        });
    }

    private void createMaxDurationDropdown(String name, List<String> _items){
        maxDurationDropdown = sessionData_cp5.addScrollableList(name)
            .setOpen(false)
            .setColor(settings.dropdownColors)
            .setOutlineColor(150)
            //.setColorBackground(OPENBCI_BLUE) // text field bg color
            .setColorValueLabel(OPENBCI_DARKBLUE)       // text color
            //.setColorCaptionLabel(color(255))
            //.setColorForeground(color(125))    // border color when not selected
            //.setColorActive(BUTTON_PRESSED)       // border color when selected
            // .setColorCursor(color(26,26,26))
            .setPosition(x + maxDurTextWidth, PApplet.parseInt(outputODF.getPosition()[1]) + 24 + padding)
            .setSize((w-padding*3)/2, (_items.size() + 1) * 24)// + maxFreqList.size())
            .setBarHeight(24) //height of top/primary bar
            .setItemHeight(24) //height of all item/dropdown bars
            .addItems(_items) // used to be .addItems(maxFreqList)
            .setVisible(false)
            ;
        maxDurationDropdown
            .getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(settings.fileDurations[settings.defaultOBCIMaxFileSize])
            .setFont(p4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        maxDurationDropdown
            .getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(settings.fileDurations[settings.defaultOBCIMaxFileSize])
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
        maxDurationDropdown.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {    
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                    int n = (int)(theEvent.getController()).getValue();
                    settings.setLogFileDurationChoice(n);
                    println("ControlPanel: Chosen Recording Duration: " + n);
                } else if (theEvent.getAction() == ControlP5.ACTION_ENTER) {
                    lockOutsideElements(true);
                } else if (theEvent.getAction() == ControlP5.ACTION_LEAVE) {
                    ScrollableList theList = (ScrollableList)(theEvent.getController());
                    lockOutsideElements(theList.isOpen());
                }
            }
        });
    }

    private Button createGUIOutputToggle(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        final Button b = createButton(sessionData_cp5, name, text, _x, _y, _w, _h);
        b.setSwitch(true); //This turns the button into a switch
        if (isToggled) {
            b.setOn();
        }
        return b;
    }

    private void createAutoSessionNameButton(String name, String text, int _x, int _y, int _w, int _h) {
        autoSessionName = createButton(sessionData_cp5, name, text, _x, _y, _w, _h);
        autoSessionName.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                autogenerateSessionName();
            }
        });
        autoSessionName.setDescription("Autogenerate a session name based on the date and time.");
    }

    private void createODFButton(String name, String text, int dataLoggerFormat, int _x, int _y, int _w, int _h) {
        boolean formatIsODF = dataLoggerFormat == dataLogger.OUTPUT_SOURCE_ODF;
        outputODF = createGUIOutputToggle(name, text, formatIsODF, _x, _y, _w, _h);
        outputODF.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                output(odfMessage);
                dataLogger.setDataLoggerOutputFormat(dataLogger.OUTPUT_SOURCE_ODF);
                outputODF.setOn();
                outputBDF.setOff();
                setToODFHeight();
            }
        });
        outputODF.setDescription("Set GUI data output to OpenBCI Data Format (.txt). A new file will be made in the session folder when the data stream is paused or max file duration is reached.");
    }

    private void createBDFButton(String name, String text, int dataLoggerFormat, int _x, int _y, int _w, int _h) {
        boolean formatIsBDF = dataLoggerFormat == dataLogger.OUTPUT_SOURCE_BDF;
        outputBDF = createGUIOutputToggle(name, text, formatIsBDF, _x, _y, _w, _h);
        outputBDF.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                output(bdfMessage);
                dataLogger.setDataLoggerOutputFormat(dataLogger.OUTPUT_SOURCE_BDF);
                outputBDF.setOn();
                outputODF.setOff();
                setToBDFHeight();
            }
        });
        outputBDF.setDescription("Set GUI data output to BioSemi Data Format (.bdf). All session data is contained in one .bdf file. View using an EDF/BDF browser.");
    }

    private void autogenerateSessionName() {
        output("Autogenerated Session Name based on current date & time.");
        sessionNameTextfield.setText(directoryManager.getFileNameDateTime());
    }

    public void setToODFHeight() {
        h = odfModeHeight;
    }

    public void setToBDFHeight() {
        h = bdfModeHeight;
    }

    public String getSessionTextfieldString() {
        return sessionNameTextfield.getText();
    }

    public void setSessionTextfieldText(String s) {
        sessionNameTextfield.setText(s);
    }

    // True locks elements, False unlocks elements
    private void lockOutsideElements (boolean _toggle) {
        if (eegDataSource == DATASOURCE_CYTON) {
            //Cyton for Serial and WiFi (WiFi details are drawn to the right, so no need to lock)
            controlPanel.channelCountBox.lockCp5Objects(_toggle);
            if (_toggle) {
                controlPanel.sdBox.cp5_sdBox.get(ScrollableList.class, controlPanel.sdBox.sdBoxDropdownName).lock();
            } else {
                controlPanel.sdBox.cp5_sdBox.get(ScrollableList.class, controlPanel.sdBox.sdBoxDropdownName).unlock();
            }
            controlPanel.sdBox.cp5_sdBox.get(ScrollableList.class, controlPanel.sdBox.sdBoxDropdownName).setUpdate(!_toggle);
        } else {
            controlPanel.sampleRateGanglionBox.lockCp5Objects(_toggle);
        }
    }

    public void lockSessionDataBoxCp5Elements(boolean b) {
        sessionNameTextfield.setLock(b);
        autoSessionName.setLock(b);
        outputODF.setLock(b);
        outputBDF.setLock(b);
    }
};

class ChannelCountBox {
    public int x, y, w, h, padding; //size and position
    private ControlP5 ccc_cp5;
    private Button chanButton8;
    private Button chanButton16;
    private int cb8_butX;
    private int cb16_butX;
    private int cb_butY;

    ChannelCountBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        //Instantiate local cp5 for this box
        ccc_cp5 = new ControlP5(ourApplet);
        ccc_cp5.setGraphics(ourApplet, 0,0);
        ccc_cp5.setAutoDraw(false);

        cb8_butX = x + padding;
        cb16_butX = x + padding*2 + (w-padding*3)/2;
        cb_butY = y + padding*2 + 18;
        boolean is8Channels = (nchan == 8) ? true : false;
        createChan8Button("cyton8ChanButton", "8 CHANNELS", is8Channels, cb8_butX, cb_butY, (w-padding*3)/2, 24);
        createChan16Button("cyton16ChanButton", "16 CHANNELS", is8Channels, cb16_butX, cb_butY, (w-padding*3)/2, 24);
    }

    public void update() {
    }

    public void draw() {
        cb_butY = y + padding*2 + 18;
        chanButton8.setPosition(cb8_butX, cb_butY);
        chanButton16.setPosition(cb16_butX, cb_butY);

        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("CHANNEL COUNT ", x + padding, y + padding);
        fill(OPENBCI_DARKBLUE); //set color to green
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("  (" + str(nchan) + ")", x + padding + 142, y + padding); // print the channel count in green next to the box title
        popStyle();

        ccc_cp5.draw();
    }

    private Button createCCCButton(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        final Button b = createButton(ccc_cp5, name, text, _x, _y, _w, _h);
        b.setSwitch(true); //This turns the button into a switch
        if (isToggled) {
            b.setOn();
        }
        return b;
    }

    private void createChan8Button(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        chanButton8 = createCCCButton(name, text, isToggled, _x, _y, _w, _h);
        chanButton8.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                updateToNChan(8);
                chanButton8.setOn();
                chanButton16.setOff();
            }
        });
    }

    private void createChan16Button(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        chanButton16 = createCCCButton(name, text, isToggled, _x, _y, _w, _h);
        chanButton16.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                updateToNChan(16);
                chanButton8.setOff();
                chanButton16.setOn();
            }
        });
    }

    public void lockCp5Objects(boolean flag) {
        chanButton8.setLock(flag);
        chanButton16.setLock(flag);
    }

    public void set8ChanButtonActive() {
        updateToNChan(8);
        chanButton8.setOn();
        chanButton16.setOff();
    }
};

class SampleRateGanglionBox {
    public int x, y, w, h, padding; //size and position
    private ControlP5 srgb_cp5;
    private Button sampleRate200;
    private Button sampleRate1600;
    private int sr200_butX;
    private int sr1600_butX;
    private int srButton_butY;

    SampleRateGanglionBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        //Instantiate local cp5 for this box
        srgb_cp5 = new ControlP5(ourApplet);
        srgb_cp5.setGraphics(ourApplet, 0,0);
        srgb_cp5.setAutoDraw(false);

        sr200_butX = x + padding;
        sr1600_butX = x + padding*2 + (w-padding*3)/2;
        srButton_butY =  y + padding*2 + 18;
        createSR200Button("cytonSR200", "200Hz", false, sr200_butX, srButton_butY, (w-padding*3)/2, 24);
        createSR1600Button("cytonSR1600", "1600Hz", true, sr1600_butX, srButton_butY, (w-padding*3)/2, 24);
    }

    public void update() {
    }

    public void draw() {
        sr200_butX = x + padding;
        sr1600_butX = x + padding*2 + (w-padding*3)/2;
        srButton_butY =  y + padding*2 + 18;
        sampleRate200.setPosition(sr200_butX, srButton_butY);
        sampleRate1600.setPosition(sr1600_butX, srButton_butY);

        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("SAMPLE RATE ", x + padding, y + padding);
        fill(OPENBCI_DARKBLUE); //set color to green
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        popStyle();

        srgb_cp5.draw();
    }

    private Button createSRGBButton(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        final Button b = createButton(srgb_cp5, name, text, _x, _y, _w, _h);
        b.setSwitch(true); //This turns the button into a switch
        if (isToggled) {
            b.setOn();
        }
        return b;
    }

    private void createSR200Button(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        sampleRate200 = createSRGBButton(name, text, isToggled, _x, _y, _w, _h);
        sampleRate200.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                selectedSamplingRate = 200;
                println("ControlPanel: User selected Ganglion+WiFi 200Hz");
                sampleRate200.setOn();
                sampleRate1600.setOff();
            }
        });
    }

    private void createSR1600Button(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        sampleRate1600 = createSRGBButton(name, text, isToggled, _x, _y, _w, _h);
        sampleRate1600.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                selectedSamplingRate = 1600;
                println("ControlPanel: User selected Ganglion+WiFi 1600Hz");
                sampleRate200.setOff();
                sampleRate1600.setOn();
            }
        });
    }

    public void lockCp5Objects(boolean flag) {
        sampleRate200.setLock(flag);
        sampleRate1600.setLock(flag);
    }
};

class SampleRateCytonBox {
    public int x, y, w, h, padding; //size and position
    private ControlP5 srcb_cp5;
    private Button sampleRate250;
    private Button sampleRate500;
    private Button sampleRate1000;
    private int sr250_butX;
    private int sr500_butX;
    private int sr1000_butX;
    private int srButton_butY;

    SampleRateCytonBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        //Instantiate local cp5 for this box
        srcb_cp5 = new ControlP5(ourApplet);
        srcb_cp5.setGraphics(ourApplet, 0,0);
        srcb_cp5.setAutoDraw(false);

        sr250_butX = x + padding;
        sr500_butX = x + padding*2 + (w-padding*4)/3;
        sr1000_butX = x + padding*3 + ((w-padding*4)/3)*2;
        srButton_butY =  y + padding*2 + 18;
        createSR250Button("cytonSR250", "250Hz", false, sr250_butX, srButton_butY, (w-padding*4)/3, 24);
        createSR500Button("cytonSR500", "500Hz", false, sr500_butX, srButton_butY, (w-padding*4)/3, 24);
        //Make 1000Hz option selected by default
        createSR1000Button("cytonSR1000", "1000Hz", true, sr1000_butX, srButton_butY, (w-padding*4)/3, 24);
    }

    public void update() {

    }

    public void draw() {

        srButton_butY =  y + padding*2 + 18;
        sampleRate250.setPosition(sr250_butX, srButton_butY);
        sampleRate500.setPosition(sr500_butX, srButton_butY);
        sampleRate1000.setPosition(sr1000_butX, srButton_butY);

        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("SAMPLE RATE ", x + padding, y + padding);
        fill(OPENBCI_DARKBLUE); //set color to green
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        popStyle();

        srcb_cp5.draw();
    }

    private Button createSRCBButton(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        final Button b = createButton(srcb_cp5, name, text, _x, _y, _w, _h);
        b.setSwitch(true); //This turns the button into a switch
        if (isToggled) {
            b.setOn();
        }
        return b;
    }

    private void createSR250Button(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        sampleRate250 = createSRCBButton(name, text, isToggled, _x, _y, _w, _h);
        sampleRate250.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                selectedSamplingRate = 250;
                println("ControlPanel: User selected Cyton+WiFi 250Hz");
                sampleRate250.setOn();
                sampleRate500.setOff();
                sampleRate1000.setOff();
            }
        });
    }

    private void createSR500Button(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        sampleRate500 = createSRCBButton(name, text, isToggled, _x, _y, _w, _h);
        sampleRate500.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                selectedSamplingRate = 500;
                println("ControlPanel: User selected Cyton+WiFi 500Hz");
                sampleRate250.setOff();
                sampleRate500.setOn();
                sampleRate1000.setOff();
            }
        });
    }

    private void createSR1000Button(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        sampleRate1000 = createSRCBButton(name, text, isToggled, _x, _y, _w, _h);
        sampleRate1000.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                selectedSamplingRate = 1000;
                println("ControlPanel: User selected Cyton+WiFi 1000Hz");
                sampleRate250.setOff();
                sampleRate500.setOff();
                sampleRate1000.setOn();
            }
        });
    }
};

class SyntheticChannelCountBox {
    public int x, y, w, h, padding; //size and position
    private ControlP5 sccb_cp5;
    private Button synthChanButton4;
    private Button synthChanButton8;
    private Button synthChanButton16;

    SyntheticChannelCountBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        //Instantiate local cp5 for this box
        sccb_cp5 = new ControlP5(ourApplet);
        sccb_cp5.setGraphics(ourApplet, 0,0);
        sccb_cp5.setAutoDraw(false);

        createSynthChan4Button("synthChan4Button", "4 chan", x + padding, y + padding*2 + 18, (w-padding*4)/3, 24);
        createSynthChan8Button("synthChan8Button", "8 chan", x + padding*2 + (w-padding*4)/3, y + padding*2 + 18, (w-padding*4)/3, 24);
        createSynthChan16Button("synthChan16Button", "16 chan", x + padding*3 + ((w-padding*4)/3)*2, y + padding*2 + 18, (w-padding*4)/3, 24);
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("CHANNEL COUNT", x + padding, y + padding);
        fill(OPENBCI_DARKBLUE); //set color to green
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("  (" + str(nchan) + ")", x + padding + 142, y + padding); // print the channel count in green next to the box title
        popStyle();

        sccb_cp5.draw();
    }

    private Button createSCCBButton(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        final Button b = createButton(sccb_cp5, name, text, _x, _y, _w, _h);
        b.setSwitch(true); //This turns the button into a switch
        if (isToggled) {
            b.setOn();
        }
        return b;
    }

    private void createSynthChan4Button(String name, String text, int _x, int _y, int _w, int _h) {
        synthChanButton4 = createSCCBButton(name, text, false,_x, _y, _w, _h);
        synthChanButton4.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                updateToNChan(4);
                synthChanButton4.setOn();
                synthChanButton8.setOff();
                synthChanButton16.setOff();
            }
        });
    }

    private void createSynthChan8Button(String name, String text, int _x, int _y, int _w, int _h) {
        //Default is 8 channels when app starts
        synthChanButton8 = createSCCBButton(name, text, true, _x, _y, _w, _h);
        synthChanButton8.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                updateToNChan(8);
                synthChanButton4.setOff();
                synthChanButton8.setOn();
                synthChanButton16.setOff();
            }
        });
    }

    private void createSynthChan16Button(String name, String text, int _x, int _y, int _w, int _h) {
        synthChanButton16 = createSCCBButton(name, text, false, _x, _y, _w, _h);
        synthChanButton16.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                updateToNChan(16);
                synthChanButton4.setOff();
                synthChanButton8.setOff();
                synthChanButton16.setOn();
            }
        });
    }

    public void set8ChanButtonActive() {
        updateToNChan(8);
        synthChanButton4.setOff();
        synthChanButton8.setOn();
        synthChanButton16.setOff();
    }
};

class RecentPlaybackBox {
    public int x, y, w, h, padding; //size and position
    private StringList shortFileNames = new StringList();
    private StringList longFilePaths = new StringList();
    private String filePickedShort = "Select Recent Playback File";
    private ControlP5 rpb_cp5;
    private ScrollableList recentPlaybackSL;
    private int titleH = 14;
    private int buttonH = 24;

    RecentPlaybackBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = titleH + buttonH + _padding*3;
        padding = _padding;

        rpb_cp5 = new ControlP5(ourApplet);
        rpb_cp5.setGraphics(ourApplet, 0,0);
        rpb_cp5.setAutoDraw(false);

        getRecentPlaybackFiles();

        String[] temp = shortFileNames.array();
        createRecentPlaybackFilesDropdown("recentPlaybackFilesCP", Arrays.asList(temp));
    }

    public void update() {
        //Update the dropdown list if it has not already been done
        if (!recentPlaybackFilesHaveUpdated) {
            recentPlaybackSL.clear();
            getRecentPlaybackFiles();
            String[] temp = shortFileNames.array();
            recentPlaybackSL.addItems(temp);
            recentPlaybackSL.setSize(w - padding*2, (temp.length + 1) * buttonH);
        }
    }

    public String getFilePickedShort() {
        return filePickedShort;
    }

    public void setFilePickedShort(String _fileName) {
        filePickedShort = _fileName;
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h + recentPlaybackSL.getHeight() - padding*2.5f);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("PLAYBACK HISTORY", x + padding, y + padding);
        popStyle();
        recentPlaybackSL.setVisible(true);
        rpb_cp5.draw();
    }

    private void getRecentPlaybackFiles() {
        int numFilesToShow = 10;

        File f = new File(userPlaybackHistoryFile);
        if (!f.exists()) {
            println("OpenBCI_GUI::Control Panel: Playback history file not found.");
            recentPlaybackFilesHaveUpdated = true;
            playbackHistoryFileExists = false;
            return;
        }

        try {
            JSONObject playbackHistory = loadJSONObject(userPlaybackHistoryFile);
            JSONArray recentFilesArray = playbackHistory.getJSONArray("playbackFileHistory");
            if (recentFilesArray.size() < 10) {
                println("CP: Playback History Size = " + recentFilesArray.size());
                numFilesToShow = recentFilesArray.size();
            }
            shortFileNames.clear();
            longFilePaths.clear();
            for (int i = 0; i < numFilesToShow; i++) {
                JSONObject playbackFile = recentFilesArray.getJSONObject(recentFilesArray.size()-i-1);
                String shortFileName = playbackFile.getString("id");
                String longFilePath = playbackFile.getString("filePath");
                //truncate display name, if needed
                shortFileName = shortenString(shortFileName, w-padding*2.f, h3);
                //store to arrays to set recent playback buttons text and function
                shortFileNames.append(shortFileName);
                longFilePaths.append(longFilePath);
                //println(shortFileName + " " + longFilePath);
            }

            playbackHistoryFileExists = true;
        } catch (Exception e) {
            println("OpenBCI_GUI::Control Panel: Other error! Please submit an issue on Github and share this console log.");
            println(e.getMessage());
            playbackHistoryFileExists = false;
        }
        recentPlaybackFilesHaveUpdated = true;
    }

    public void createRecentPlaybackFilesDropdown(String name, List<String> _items){
        recentPlaybackSL = rpb_cp5.addScrollableList(name)
            .setOpen(false)
            .setColorBackground(OPENBCI_BLUE) // text field bg color
            .setColorValueLabel(color(255))       // text color
            .setColorCaptionLabel(color(255))
            .setColorForeground(color(125))    // border color when not selected
            .setColorActive(BUTTON_PRESSED)       // border color when selected
            // .setColorCursor(color(26,26,26))

            .setSize(w - padding*2,(_items.size()+1)*24)// + maxFreqList.size())
            .setBarHeight(24) //height of top/primary bar
            .setItemHeight(24) //height of all item/dropdown bars
            .addItems(_items) // used to be .addItems(maxFreqList)
            .setVisible(true)
            ;
        recentPlaybackSL
            .getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(filePickedShort)
            .setFont(h4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        recentPlaybackSL
            .getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(filePickedShort)
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
        recentPlaybackSL.setPosition(x + padding, y + padding*2 + 13);
        recentPlaybackSL.setSize(w - padding*2, (_items.size() + 1) * buttonH);
        recentPlaybackSL.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                    int s = (int)recentPlaybackSL.getValue();
                    //println("got a menu event from item " + s);
                    String filePath = longFilePaths.get(s);
                    if (new File(filePath).isFile()) {
                        playbackFileFromList(filePath, s);
                    } else {
                        verbosePrint("Playback History: " + filePath);
                        outputError("Playback History: Selected file does not exist. Try another file or clear settings to remove this entry.");
                    }
                }
            }
        });
    }
};

class BrainFlowStreamerBox {
    public int x, y, w, h, padding; //size and position
    private ControlP5 bfStreamerCp5;
    private int maxDurTextWidth = 82;
    private int maxDurText_x = 0;
    private Textfield ipAddress;
    private Textfield port;
    private Button autoSessionName;
    private Button outputToNetwork;
    private Button outputToFile;
    private ScrollableList bfFileSaveOption;
    private DataWriterBFEnum dataWriterBfEnum = DataWriterBFEnum.DEFAULT;
    private final int HEADER_H = 14;
    private final int OBJECT_H = 24;
    private final String DEFAULT_IP_ADDRESS = "225.1.1.1";
    private final String DEFAULT_PORT = "6677";

    BrainFlowStreamerBox (int _x, int _y, int _w, int _h, int _padding, String textfieldName) {
        x = _x;
        y = _y;
        w = _w;
        h = HEADER_H + OBJECT_H*2 + _padding*4;
        padding = _padding;

        //Instantiate local cp5 for this box
        bfStreamerCp5 = new ControlP5(ourApplet);
        bfStreamerCp5.setGraphics(ourApplet, 0,0);
        bfStreamerCp5.setAutoDraw(false);

        createDropdown("bfFileSaveOption");
        createNetworkTextfields();

        //button to autogenerate file name based on time/date
        createStreamNetworkButton("networkButton", "Network", x + padding, y + 32, (w-padding*3)/2, OBJECT_H);
        createStreamFileButton("fileButton", "File", x + padding*2 + (w-padding*3)/2, y + 32, (w-padding*3)/2, OBJECT_H);
    }

    public void update() {
        copyPaste.checkForCopyPaste(ipAddress);
        copyPaste.checkForCopyPaste(port);
    }

        public void draw() {
        int streamerTextfieldY = y + padding*3 + HEADER_H + OBJECT_H;

        bfFileSaveOption.setVisible(outputToFile.isOn());
        ipAddress.setVisible(outputToNetwork.isOn());
        port.setVisible(outputToNetwork.isOn());

        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("BRAINFLOW STREAMER", x + padding, y + padding);
        textFont(p4, 14);
        if (outputToFile.isOn()) {
            text("Location", x + padding, streamerTextfieldY + 2);
        } else if (outputToNetwork.isOn()) {
            text("IP", x + padding, streamerTextfieldY + 2);
            text("Port", x + w - padding*2 - port.getWidth() - 14 - padding, streamerTextfieldY + 2);
        }
        popStyle();
        
        //Update the position of UI elements here
        outputToNetwork.setPosition(x + padding, y + HEADER_H + padding*2);
        outputToFile.setPosition(x + padding*2 + (w-padding*3)/2, y + HEADER_H + padding*2);
        bfFileSaveOption.setPosition(x + 80, streamerTextfieldY);
        ipAddress.setPosition(x + padding * 3, streamerTextfieldY);
        port.setPosition(x + w - padding - port.getWidth(), streamerTextfieldY);
        
        bfStreamerCp5.draw();
    }

    private void createNetworkTextfields() {
        ipAddress = bfStreamerCp5.addTextfield("ipAddress")
            .setPosition(x + padding * 3, y + HEADER_H + padding*2)
            .setCaptionLabel("")
            .setSize(120, OBJECT_H)
            .setFont(f2)
            .setFocus(false)
            .setColor(color(26, 26, 26))
            .setColorBackground(color(255, 255, 255)) // text field bg color
            .setColorValueLabel(OPENBCI_DARKBLUE)  // text color
            .setColorForeground(OPENBCI_DARKBLUE)  // border color when not selected
            .setColorActive(isSelected_color)  // border color when selected
            .setColorCursor(color(26, 26, 26))
            .setText(DEFAULT_IP_ADDRESS) //default ipAddress == ""
            .align(5, 10, 20, 40)
            //.onDoublePress(cb)
            .addCallback(new CallbackListener() {
                    public void controlEvent(CallbackEvent theEvent) {
                        if (theEvent.getAction() == ControlP5.ACTION_BROADCAST && ipAddress.getText().equals("")) {
                            ipAddress.setText(DEFAULT_IP_ADDRESS);
                        }
                    }
                })
            .onReleaseOutside(new CallbackListener() {
                    public void controlEvent(CallbackEvent theEvent) {
                        if (!ipAddress.isActive() && ipAddress.getText().equals("")) {
                            ipAddress.setText(DEFAULT_IP_ADDRESS);
                        }
                    }
                })
            .onDoublePress(cb);
        
        port = bfStreamerCp5.addTextfield("port")
            .setPosition(x + padding*5 + w/2, y + HEADER_H + padding*2)
            .setCaptionLabel("")
            .setSize(50, OBJECT_H)
            .setFont(f2)
            .setFocus(false)
            .setColor(color(26, 26, 26))
            .setColorBackground(color(255, 255, 255)) // text field bg color
            .setColorValueLabel(OPENBCI_DARKBLUE)  // text color
            .setColorForeground(OPENBCI_DARKBLUE)  // border color when not selected
            .setColorActive(isSelected_color)  // border color when selected
            .setColorCursor(color(26, 26, 26))
            .setText(DEFAULT_PORT) //default port == 0
            .align(5, 10, 20, 40)
            //.onDoublePress(cb)
            .addCallback(new CallbackListener() {
                    public void controlEvent(CallbackEvent theEvent) {
                        if (theEvent.getAction() == ControlP5.ACTION_BROADCAST && port.getText().equals("")) {
                            port.setText(DEFAULT_PORT);
                        }
                    }
                })
            .onReleaseOutside(new CallbackListener() {
                    public void controlEvent(CallbackEvent theEvent) {
                        if (!port.isActive() && port.getText().equals("")) {
                            port.setText(DEFAULT_PORT);
                        }
                    }
                })
            .onDoublePress(cb);
    }

    private Button createBrainFlowOutputToggle(String name, String text, boolean isToggled, int _x, int _y, int _w, int _h) {
        final Button b = createButton(bfStreamerCp5, name, text, _x, _y, _w, _h);
        b.setSwitch(true); //This turns the button into a switch
        if (isToggled) {
            b.setOn();
        }
        return b;
    }

    private void createStreamNetworkButton(String name, String text, int _x, int _y, int _w, int _h) {
        outputToNetwork = createBrainFlowOutputToggle(name, text, false, _x, _y, _w, _h);
        outputToNetwork.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                //output(odfMessage);
                //dataLogger.setDataLoggerOutputFormat(dataLogger.OUTPUT_SOURCE_ODF);
                outputToNetwork.setOn();
                outputToFile.setOff();
                //setToODFHeight();
            }
        });
        outputToNetwork.setDescription("Use BrainFlow Streamer to output to network address. You can accept this data stream using a separate process which utilizes any BrainFlow binding. This is a helpful feature for developers.");
    }

    private void createStreamFileButton(String name, String text, int _x, int _y, int _w, int _h) {
        outputToFile = createBrainFlowOutputToggle(name, text, true, _x, _y, _w, _h);
        outputToFile.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                //output(bdfMessage);
                //dataLogger.setDataLoggerOutputFormat(dataLogger.OUTPUT_SOURCE_BDF);
                outputToNetwork.setOff();
                outputToFile.setOn();
                //setToBDFHeight();
            }
        });
        outputToFile.setDescription("Set BrainFlow Streamer output to stream over network. A new file will be made in the session folder when the data stream is paused or max file duration is reached.");
    }

    private void createDropdown(String name){
        bfFileSaveOption = bfStreamerCp5.addScrollableList(name)
            .setOpen(false)
            .setColor(settings.dropdownColors)
            .setOutlineColor(150)
            .setSize(167, (dataWriterBfEnum.values().length + 1) * 24)
            .setBarHeight(24) //height of top/primary bar
            .setItemHeight(24) //height of all item/dropdown bars
            .setVisible(true)
            ;
        for (DataWriterBFEnum value : dataWriterBfEnum.values()) {
            // this will store the *actual* enum object inside the dropdown!
            bfFileSaveOption.addItem(value.getString(), value);
        }
        bfFileSaveOption.getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(dataWriterBfEnum.getString())
            .setFont(p4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        bfFileSaveOption.getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(dataWriterBfEnum.getString())
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
        bfFileSaveOption.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                    int val = (int)(theEvent.getController()).getValue();
                    Map bob = ((ScrollableList)theEvent.getController()).getItem(val);
                    dataWriterBfEnum = (DataWriterBFEnum)bob.get("value");
                    StringBuilder sb = new StringBuilder("BrainFlow File Streamer: User selected ");
                    sb.append(dataWriterBfEnum.getString());
                    sb.append(" file location.");
                    output(sb.toString());
                    if (dataWriterBfEnum.getIsCustomLocation()) {
                        selectOutput("Select a folder to save BrainFlow CSV files to:", 
                                "bfSelectedFolder",
                                new File(directoryManager.getRecordingsPath())
                        );
                    }
                } else if (theEvent.getAction() == ControlP5.ACTION_ENTER) {
                    lockOutsideElements(true);
                } else if (theEvent.getAction() == ControlP5.ACTION_LEAVE) {
                    lockOutsideElements(false);
                }
            }
        });
        bfFileSaveOption.setPosition(x + 10, y + 10); //Set arbitrary position to start, gets reset on every draw
    }

    private String getBFNetworkTextfieldsAsString() {
        StringBuilder sb = new StringBuilder("streaming_board://");
        sb.append(ipAddress.getText());
        sb.append(":");
        sb.append(port.getText());
        return sb.toString();
    }

    private String getBFFileLocationAsString() {
        if (dataLogger.getBfWriterFilePath() == null || dataWriterBfEnum.getIsTurnedOff()) {
            return null;
        }
        return dataLogger.getBfWriterFilePath();
    }

    public String getBrainFlowStreamerString() {
        String s = outputToNetwork.isOn() ? getBFNetworkTextfieldsAsString() : getBFFileLocationAsString();
        return s;
    }

    public boolean getIsBrainFlowStreamerDefaultLocation() {
        return outputToFile.isOn() && dataWriterBfEnum.getIsDefaultLocation();
    }

    // True locks elements, False unlocks elements
    private void lockOutsideElements (boolean _toggle) {
        if (eegDataSource == DATASOURCE_CYTON) {
            //Cyton for Serial and WiFi (WiFi details are drawn to the right, so no need to lock)
            controlPanel.channelCountBox.lockCp5Objects(_toggle);
            if (_toggle) {
                controlPanel.sdBox.cp5_sdBox.get(ScrollableList.class, controlPanel.sdBox.sdBoxDropdownName).lock();
            } else {
                controlPanel.sdBox.cp5_sdBox.get(ScrollableList.class, controlPanel.sdBox.sdBoxDropdownName).unlock();
            }
            controlPanel.sdBox.cp5_sdBox.get(ScrollableList.class, controlPanel.sdBox.sdBoxDropdownName).setUpdate(!_toggle);
        }
    }

    public void lockSessionDataBoxCp5Elements(boolean b) {
        ipAddress.setLock(b);
        port.setLock(b);
    }

    //Clear text field on double-click
    CallbackListener cb = new CallbackListener() { 
        public void controlEvent(CallbackEvent theEvent) {
            Textfield tf = ((Textfield)theEvent.getController());
            tf.clear();
        }
    };
};

class StreamingBoardBox {
    public int x, y, w, h, padding; //size and position
    private final String boxLabel = "STREAMING BOARD CONFIG";
    private final String ipLabel = "IP";
    private final String portLabel = "PORT";
    private final String boardLabel = "BOARD";
    private ControlP5 localCP5;
    private ScrollableList boardIdList;
    private Textfield ipAddress;
    private Textfield port;
    private final int headerH = 14;
    private final int objectH = 24;

    StreamingBoardBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w - _padding;
        h = headerH + objectH*2 + _padding*4;
        padding = _padding;
        localCP5 = new ControlP5(ourApplet);
        localCP5.setGraphics(ourApplet, 0,0);
        localCP5.setAutoDraw(false); //Setting this saves code as cp5 elements will only be drawn/visible when [cp5].draw() is called

        ipAddress = localCP5.addTextfield("ipAddress")
            .setPosition(x + padding * 3, y + headerH + padding*2)
            .setCaptionLabel("")
            .setSize(w / 3, objectH)
            .setFont(f2)
            .setFocus(false)
            .setColor(color(26, 26, 26))
            .setColorBackground(color(255, 255, 255)) // text field bg color
            .setColorValueLabel(OPENBCI_DARKBLUE)  // text color
            .setColorForeground(OPENBCI_DARKBLUE)  // border color when not selected
            .setColorActive(isSelected_color)  // border color when selected
            .setColorCursor(color(26, 26, 26))
            .setText("") //default ipAddress == ""
            .align(5, 10, 20, 40)
            .onDoublePress(cb)
            .setAutoClear(true);
        
        port = localCP5.addTextfield("port")
            .setPosition(x + padding*5 + w/2, y + headerH + padding*2)
            .setCaptionLabel("")
            .setSize(w / 5 + padding, objectH)
            .setFont(f2)
            .setFocus(false)
            .setColor(color(26, 26, 26))
            .setColorBackground(color(255, 255, 255)) // text field bg color
            .setColorValueLabel(OPENBCI_DARKBLUE)  // text color
            .setColorForeground(OPENBCI_DARKBLUE)  // border color when not selected
            .setColorActive(isSelected_color)  // border color when selected
            .setColorCursor(color(26, 26, 26))
            .setText(Integer.toString(0)) //default port == 0
            .align(5, 10, 20, 40)
            .onDoublePress(cb)
            .setAutoClear(true);
        
        boardIdList = createDropdown("streamingBoard_IDs", BrainFlowStreaming_Boards.values());
        boardIdList.setPosition(x + 48 + padding*2, y + headerH + padding*3 + objectH);
        boardIdList.setSize(170, (boardIdList.getItems().size()+1)*objectH);
    }

    public void update() {
        copyPaste.checkForCopyPaste(ipAddress);
        copyPaste.checkForCopyPaste(port);
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        popStyle();

        pushStyle();
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        //draw text labels
        text(boxLabel, x + padding, y + padding);
        textAlign(LEFT, TOP);
        textFont(p4, 14);
        text(ipLabel, x + padding, y + padding*2 + headerH + 4);
        text(portLabel, x + w/2, y + padding*2 + headerH + 4);
        text(boardLabel, x + padding, y + padding*3 + objectH + headerH + 4);
        popStyle();
        
        //draw cp5 last, on top of everything in this box
        localCP5.draw();
    }

    private ScrollableList createDropdown(String name, BrainFlowStreaming_Boards[] enumValues){
        ScrollableList list = localCP5.addScrollableList(name)
            .setOpen(false)
            .setColorBackground(OPENBCI_BLUE) // text field bg color
            .setColorValueLabel(color(255))       // text color
            .setColorCaptionLabel(color(255))
            .setColorForeground(color(125))    // border color when not selected
            .setColorActive(BUTTON_PRESSED)       // border color when selected
            .setOutlineColor(150)
            .setSize(w - padding*2, objectH)//temporary size
            .setBarHeight(objectH) //height of top/primary bar
            .setItemHeight(objectH) //height of all item/dropdown bars
            .setVisible(true)
            ;
        // for each entry in the enum, add it to the dropdown.
        for (BrainFlowStreaming_Boards value : enumValues) {
            // this will store the *actual* enum object inside the dropdown!
            list.addItem(value.getName(), value);
        }
        //Style the text in the ScrollableList
        list.getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(enumValues[0].getName())
            .setFont(h4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        list.getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(enumValues[0].getName())
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
        return list;
    }
    
    public BrainFlowStreaming_Boards getBoard() {
        int val = (int)boardIdList.getValue();
        Map bob = boardIdList.getItem(val);
        // this will retrieve the enum object stored in the dropdown!
        return (BrainFlowStreaming_Boards)bob.get("value");
    }

    public String getIP() {
        return ipAddress.getText();
    }

    public int getPort() {
        return Integer.parseInt(port.getText());
    }

    //Clear text field on double-click
    CallbackListener cb = new CallbackListener() { 
        public void controlEvent(CallbackEvent theEvent) {
            ((Textfield)(theEvent.getController())).clear();
        }
    };
};

class PlaybackFileBox {
    public int x, y, w, h, padding; //size and position
    private ControlP5 pbfb_cp5;
    private Button sampleDataButton;
    private Button selectPlaybackFile;
    private int sampleDataButton_w = 100;
    private int sampleDataButton_h = 20;
    private int titleH = 14;
    private int buttonH = 24;

    PlaybackFileBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = buttonH + (_padding * 3) + titleH;
        padding = _padding;

        //Instantiate local cp5 for this box
        pbfb_cp5 = new ControlP5(ourApplet);
        pbfb_cp5.setGraphics(ourApplet, 0,0);
        pbfb_cp5.setAutoDraw(false);

        createSelectPlaybackFileButton("selectPlaybackFileControlPanel", "SELECT OPENBCI PLAYBACK FILE", x + padding, y + padding*2 + titleH, w - padding*2, buttonH);
        createSampleDataButton("selectSampleDataControlPanel", "Sample Data", x + w - sampleDataButton_w - padding, y + padding - 2, sampleDataButton_w, sampleDataButton_h);
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("PLAYBACK FILE", x + padding, y + padding);
        popStyle();

        pbfb_cp5.draw();
    }

    private void createSelectPlaybackFileButton(String name, String text, int _x, int _y, int _w, int _h) {
        selectPlaybackFile = createButton(pbfb_cp5, name, text, _x, _y, _w, _h);
        selectPlaybackFile.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                output("Select a file for playback");
                selectInput("Select a pre-recorded file for playback:", 
                            "playbackFileSelected",
                            new File(directoryManager.getGuiDataPath() + "Recordings")
                );
            }
        });
        selectPlaybackFile.setDescription("Click to open a dialog box to select an OpenBCI playback file (.txt or .csv).");
    }

    private void createSampleDataButton(String name, String text, int _x, int _y, int _w, int _h) {
        sampleDataButton = createButton(pbfb_cp5, name, text, _x, _y, _w, _h, p5, 12, buttonsLightBlue, color(255));
        sampleDataButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                output("Select a file for playback");
                selectInput("Select a pre-recorded file for playback:", 
                            "playbackFileSelected", 
                            new File(directoryManager.getGuiDataPath() + "Sample_Data" + System.getProperty("file.separator") + "OpenBCI-sampleData-2-meditation.txt")
                );
            }
        });
        //sampleDataButton.setCornerRoundness((int)(sampleDataButton_h));
        sampleDataButton.setDescription("Click to open the folder containing OpenBCI GUI Sample Data.");
    }
};

class SDBox {
    final private String sdBoxDropdownName = "sdCardTimes";
    public int x, y, w, h, padding; //size and position
    private ControlP5 cp5_sdBox;
    private ScrollableList sdList;
    private int prevY;

    SDBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;
        prevY = y;

        cp5_sdBox = new ControlP5(ourApplet);
        cp5_sdBox.setGraphics(ourApplet, 0,0);
        cp5_sdBox.setAutoDraw(false);

        createDropdown(sdBoxDropdownName);

        updatePosition();
        sdList.setSize(w - padding*2, (PApplet.parseInt((sdList.getItems().size()+1)/1.5f)) * 24);
    }

    public void update() {
        if (y != prevY) { //When box's absolute y position changes, update cp5
            updatePosition();
            prevY = y;
        }
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("WRITE TO SD CARD?", x + padding, y + padding);
        //draw backgrounds to dropdown scrollableLists ... unfortunately ControlP5 doesn't have this by default, so we have to hack it to make it look nice...
        popStyle();

        pushStyle();
        fill(150);
        popStyle();
        cp5_sdBox.draw();
    }

    private void createDropdown(String name){

        sdList = cp5_sdBox.addScrollableList(name)
            .setOpen(false)
            .setColor(settings.dropdownColors)
            .setOutlineColor(150)
            .setSize(w - padding*2, 2*24)//temporary size
            .setBarHeight(24) //height of top/primary bar
            .setItemHeight(24) //height of all item/dropdown bars
            .setVisible(true)
            ;
         // for each entry in the enum, add it to the dropdown.
        for (CytonSDMode mode : CytonSDMode.values()) {
            // this will store the *actual* enum object inside the dropdown!
            sdList.addItem(mode.getName(), mode);
        }
        sdList.getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(CytonSDMode.NO_WRITE.getName())
            .setFont(p4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        sdList.getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(CytonSDMode.NO_WRITE.getName())
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
        sdList.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                    int val = (int)sdList.getValue();
                    Map bob = sdList.getItem(val);
                    cyton_sdSetting = (CytonSDMode)bob.get("value");
                    String outputString = "OpenBCI microSD Setting = " + cyton_sdSetting.getName();
                    if (cyton_sdSetting != CytonSDMode.NO_WRITE) {
                        outputString += " recording time";
                    }
                    output(outputString);
                    verbosePrint("SD Command = " + cyton_sdSetting.getCommand());
                }
            }
        });
    }

    public void updatePosition() {
        sdList.setPosition(x + padding, y + padding*2 + 14);
    }
};


class RadioConfigBox {
    public int x, y, w, h, padding; //size and position
    private String initial_message = "Having trouble connecting to your Cyton? Try Auto-Scan!\n\nUse this tool to get Cyton status or change settings.";
    private String last_message = initial_message;
    public boolean isShowing;
    private RadioConfig cytonRadioCfg;
    private int headerH = 15;
    private int autoscanH = 45;
    private int buttonH = 24;
    private int statusWindowH = 115;
    private ControlP5 rcb_cp5;
    private Button autoscanButton;
    private Button systemStatusButton;
    private Button setChannelButton;
    private Button ovrChannelButton;

    RadioConfigBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x + _w;
        y = _y;
        w = _w + 10;
        h = (_padding*6) + headerH + (buttonH*2) + autoscanH + statusWindowH;
        padding = _padding;
        isShowing = false;
        cytonRadioCfg = new RadioConfig();

        //Instantiate local cp5 for this box
        rcb_cp5 = new ControlP5(ourApplet);
        rcb_cp5.setGraphics(ourApplet, 0,0);
        rcb_cp5.setAutoDraw(false);

        createAutoscanButton("CytonRadioAutoscan", "AUTO-SCAN",x + padding, y + padding*2 + headerH, w-(padding*2), autoscanH);
        createSystemStatusButton("CytonSystemStatus", "SYSTEM STATUS", x + padding, y + padding*3 + headerH + autoscanH, w-(padding*2), buttonH);
        createSetChannelButton("CytonSetRadioChannel", "CHANGE CHAN.",x + padding, y + padding*4 + headerH + buttonH + autoscanH, (w-padding*3)/2, 24);
        createOverrideChannelButton("CytonOverrideDongleChannel", "OVERRIDE DONGLE", x + 2*padding + (w-padding*3)/2, y + padding*4 + headerH + buttonH + autoscanH, (w-padding*3)/2, buttonH);
    }
    public void update() {}

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("RADIO CONFIGURATION", x + padding, y + padding);
        popStyle();

        rcb_cp5.draw();
        this.print_onscreen(last_message);
    }

    public void print_onscreen(String localstring){
        pushStyle();
        textAlign(LEFT);
        fill(OPENBCI_DARKBLUE);
        rect(x + padding, y + padding*5 + headerH + buttonH*2 + autoscanH, w-(padding*2), statusWindowH);
        fill(255);
        textFont(h3, 15);
        text(localstring, x + padding + 5, y + padding*6 + headerH + buttonH*2 + autoscanH, w - padding*3, statusWindowH - padding);
        popStyle();
        this.last_message = localstring;
    }

    public void getChannel() {
        cytonRadioCfg.get_channel(RadioConfigBox.this);
    }

    public void setChannel(int val) {
        cytonRadioCfg.set_channel(RadioConfigBox.this, val);
    }

    public void setChannelOverride(int val) {
        cytonRadioCfg.set_channel_over(RadioConfigBox.this, val);
    }

    public void scanChannels() {
        cytonRadioCfg.scan_channels(RadioConfigBox.this);
    }

    public void getSystemStatus() {
        cytonRadioCfg.system_status(RadioConfigBox.this);
    }

    public void closeSerialPort() {
        print_onscreen("");
        cytonRadioCfg.closeSerialPort();
    }

    private void createAutoscanButton(String name, String text, int _x, int _y, int _w, int _h) {
        autoscanButton = createButton(rcb_cp5, name, text, _x, _y, _w, _h);
        autoscanButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                scanChannels();
                controlPanel.hideChannelListCP();
            }
        });
        autoscanButton.setDescription("Scan through channels and connect to a nearby Cyton. This button solves most connection issues!");
    }

    private void createSystemStatusButton(String name, String text, int _x, int _y, int _w, int _h) {
        systemStatusButton = createButton(rcb_cp5, name, text, _x, _y, _w, _h);
        systemStatusButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                getChannel();
                controlPanel.hideChannelListCP();
            }
        });
        systemStatusButton.setDescription("Get connection status and the current channel of your Cyton and USB Dongle.");
    }

    private void createSetChannelButton(String name, String text, int _x, int _y, int _w, int _h) {
        setChannelButton = createButton(rcb_cp5, name, text, _x, _y, _w, _h);
        setChannelButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                controlPanel.channelPopup.setClicked(true);
                controlPanel.channelPopup.setTitleChangeChannel();
            }
        });
        setChannelButton.setDescription("Change the channel of your Cyton and USB Dongle.");
    }

    private void createOverrideChannelButton(String name, String text, int _x, int _y, int _w, int _h) {
        ovrChannelButton = createButton(rcb_cp5, name, text, _x, _y, _w, _h);
        ovrChannelButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                controlPanel.channelPopup.setClicked(true);
                controlPanel.channelPopup.setTitlteOvrDongle();
            }
        });
        ovrChannelButton.setDescription("Change the channel of the USB Dongle only.");
    }
};

class ChannelPopup {
    public int x, y, w, h, padding; //size and position
    private boolean clicked;
    private final String CHANGE_CHAN = "Change Channel";
    private final String OVR_DONGLE = "Override Dongle";
    private String title = "";
    private ControlP5 cp_cp5;
    private MenuList channelList;

    ChannelPopup(int _x, int _y, int _w, int _h, int _padding) {
        x = _x + _w * 2;
        y = _y;
        w = _w;
        h = 171 + _padding;
        padding = _padding;
        clicked = false;

        //Instantiate local cp5 for this box
        cp_cp5 = new ControlP5(ourApplet);
        cp_cp5.setGraphics(ourApplet, 0,0);
        cp_cp5.setAutoDraw(false);

        channelList = new MenuList(cp_cp5, "channelListCP", w - padding*2, 140, p3);
        channelList.setPosition(x+padding, y+padding*3);
        for (int i = 1; i < 26; i++) {
            channelList.addItem(String.valueOf(i));
        }
        channelList.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                    int setChannelInt = (int)(theEvent.getController()).getValue() + 1;
                    setClicked(false);
                    if (title.equals(CHANGE_CHAN)) {
                        controlPanel.rcBox.setChannel(setChannelInt);
                    } else if (title.equals(OVR_DONGLE)) {
                        controlPanel.rcBox.setChannelOverride(setChannelInt);
                    }
                }
            }
        });
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text(title, x + padding, y + padding);
        popStyle();
        cp_cp5.draw();
    }

    public void setClicked(boolean click) { this.clicked = click; }
    public boolean wasClicked() { return this.clicked; }
    public void setTitleChangeChannel() { title = CHANGE_CHAN; }
    public void setTitlteOvrDongle() { title = OVR_DONGLE; }
};

//This class holds the "Start Session" button
class InitBox {
    public int x, y, w, h, padding; //size and position
    private ControlP5 initBox_cp5;
    public Button initSystemButton;

    InitBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 50;
        padding = _padding;

        //Instantiate local cp5 for this box
        initBox_cp5 = new ControlP5(ourApplet);
        initBox_cp5.setGraphics(ourApplet, 0,0);
        initBox_cp5.setAutoDraw(false);

        createStartSessionButton("startSessionButton", "START SESSION", x + padding, y + padding, w-padding*2, h - padding*2);
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        popStyle();
        
        initBox_cp5.draw();
    }

    private void createStartSessionButton(String name, String text, int _x, int _y, int _w, int _h) {
        initSystemButton = createButton(initBox_cp5, name, text, _x, _y, _w, _h);
        initSystemButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (controlPanel.rcBox.isShowing) {
                    controlPanel.hideRadioPopoutBox();
                }
                //If session is not active, start session and flip button state
                initButtonPressed();
            }
        });
    }

    //This is the primary method called when Start/Stop Session Button is pressed in Control Panel
    public void initButtonPressed() {
        if (getInitSessionButtonText().equals("START SESSION")) {
            if ((eegDataSource == DATASOURCE_CYTON && selectedProtocol == BoardProtocol.NONE) || (eegDataSource == DATASOURCE_GANGLION && selectedProtocol == BoardProtocol.NONE)) {
                outputWarn("No Transfer Protocol selected. Please select your Transfer Protocol and retry system initiation.");
                return;
            } else if (eegDataSource == DATASOURCE_CYTON && selectedProtocol == BoardProtocol.SERIAL && openBCI_portName == "N/A") { //if data source == normal && if no serial port selected OR no SD setting selected
                outputWarn("No Serial/COM port selected. Attempting to AUTO-CONNECT to Cyton.");
                controlPanel.comPortBox.attemptAutoConnectCyton();   
                return;
            } else if (eegDataSource == DATASOURCE_CYTON && selectedProtocol == BoardProtocol.WIFI && wifi_portName == "N/A" && controlPanel.getWifiSearchStyle() == controlPanel.WIFI_DYNAMIC) {
                outputWarn("No Wifi Shield selected. Please select your Wifi Shield and retry system initiation.");
                return;
            } else if (eegDataSource == DATASOURCE_PLAYBACKFILE && playbackData_fname == "N/A" && sdData_fname == "N/A") { //if data source == playback && playback file == 'N/A'
                outputWarn("No playback file selected. Please select a playback file and retry system initiation.");        // tell user that they need to select a file before the system can be started
                return;
            } else if (eegDataSource == DATASOURCE_GANGLION && (selectedProtocol == BoardProtocol.NATIVE_BLE || selectedProtocol == BoardProtocol.BLED112) && ganglion_portName == "N/A") {
                outputWarn("No BLE device selected. Please select your Ganglion device and retry system initiation.");
                return;
            } else if (eegDataSource == DATASOURCE_GANGLION && selectedProtocol == BoardProtocol.WIFI && wifi_portName == "N/A" && controlPanel.getWifiSearchStyle() == controlPanel.WIFI_DYNAMIC) {
                outputWarn("No Wifi Shield selected. Please select your Wifi Shield and retry system initiation.");
                return;
            } else if (eegDataSource == -1) {//if no data source selected
                outputWarn("No DATA SOURCE selected. Please select a DATA SOURCE and retry system initiation.");//tell user they must select a data source before initiating system
                return;
            } else { //otherwise, initiate system!
                //verbosePrint("ControlPanel: CPmouseReleased: init");
                setInitSessionButtonText("STOP SESSION");
                // Global steps to START SESSION
                // Prepare the serial port

                //Set data logger outputs to save data to BDF or CSV
                controlPanel.setDataLoggerOutputs();

                if (controlPanel.getWifiSearchStyle() == controlPanel.WIFI_STATIC && (selectedProtocol == BoardProtocol.WIFI || selectedProtocol == BoardProtocol.WIFI)) {
                    wifi_ipAddress = controlPanel.wifiBox.staticIPAddressTF.getText();
                    println("Static IP address of " + wifi_ipAddress);
                }

                //Set this flag to true, and draw "Starting Session..." to screen after then next draw() loop
                midInit = true;
                output("Attempting to Start Session..."); // Show this at the bottom of the GUI
                println("initButtonPressed: Calling initSystem() after next draw()");
            }
        } else {
            //if system is already active ... stop session and flip button state back
            setInitSessionButtonText("START SESSION");
            topNav.setLockTopLeftSubNavCp5Objects(false); //Unlock top left subnav buttons
            //creates new data file name so that you don't accidentally overwrite the old one
            controlPanel.dataLogBoxCyton.setSessionTextfieldText(directoryManager.getFileNameDateTime());
            controlPanel.dataLogBoxGanglion.setSessionTextfieldText(directoryManager.getFileNameDateTime());
            controlPanel.wifiBox.setStaticIPTextfield(wifi_ipAddress);
            w_focus.killAuditoryFeedback();
            haltSystem();
        }
    }

    public String getInitSessionButtonText() {
        return initSystemButton.getCaptionLabel().getText();
    }

    public void setInitSessionButtonText(String text) {
        initSystemButton.getCaptionLabel().setText(text);
    }
};


//=======================================================================================================================================
//
//                    Custom Cp5 Classes and Methods
//
//  Created: Conor Russomanno Oct. 2014
//  Refactored: Richard Waltman Nov. 2020  
//
//=======================================================================================================================================

//Reusable method for creating CP5 buttons throughout the GUI
public Button createButton(ControlP5 _cp5, String name, String text, int _x, int _y, int _w, int _h, int _roundness, PFont _font, int _fontSize, int _bgColor, int _textColor, int _colorHover, int _colorPressed, Integer _strokeColor, int _marginTop) {
    final Button b = _cp5.addButton(name)
        .setPosition(_x, _y)
        .setSize(_w, _h)
        .setColorLabel(_textColor)
        .setCornerRoundness(_roundness) //From Processing rect(): To draw a rounded rectangle, add a fifth parameter, which is used as the radius value for all four corners.
        .setColorForeground(_colorHover)
        .setColorBackground(_bgColor)
        .setColorActive(_colorPressed)
        .setBorderColor(_strokeColor)
        ;
    b.getCaptionLabel()
        .setFont(_font)
        .toUpperCase(false)
        .setSize(_fontSize)
        .setText(text)
        .setColor(_textColor) //This sets the color of the button label
        .getStyle()
        .setMarginTop(_marginTop)
        ;
    //Add Help Text to all Buttons. If description is null or object is locked, take no action.
    b.addCallback(new CallbackListener() {
        public void controlEvent(CallbackEvent theEvent) {
            if (theEvent.getAction() == ControlP5.ACTION_ENTER && !b.isLock() && b.getDescription() != null) {
                //Show helpt text if object is not locked and has a description
                buttonHelpText.setButtonHelpText(b.getDescription(), (int)b.getPosition()[0] + b.getWidth()/2, (int)b.getPosition()[1] + (3*b.getHeight())/4);
                buttonHelpText.setTimeUserEnteredUIObject();
            } else if (theEvent.getAction() == ControlP5.ACTION_LEAVE || theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                //Hide help text if clicked or user's mouse leaves object
                buttonHelpText.setVisible(false);
            }
        }
    });
    return b;
}

//Square corners and no text label adjustment w/ default hover and press colors
public Button createButton(ControlP5 _cp5, String name, String text, int _x, int _y, int _w, int _h, PFont _font, int _fontSize, int _bgColor, int _textColor) {
    return createButton(_cp5, name, text, _x, _y, _w, _h, 0, _font, _fontSize, _bgColor, _textColor, BUTTON_HOVER, BUTTON_PRESSED, OPENBCI_DARKBLUE, 0);
}

//Default button colors and fonts
private Button createButton(ControlP5 _cp5, String name, String text, int _x, int _y, int _w, int _h) {
    return createButton(_cp5, name, text, _x, _y, _w, _h, 0, p5, 12, colorNotPressed, OPENBCI_DARKBLUE, BUTTON_HOVER, BUTTON_PRESSED, OPENBCI_DARKBLUE, 0);
}


///////////////////////////////////////////////////////
//              BUTTON HELP TEXT CLASS               //
///////////////////////////////////////////////////////
class ButtonHelpText{
    private int x, y, w, h;
    private String myText = "";
    private boolean isVisible;
    private int numLines;
    private int lineSpacing = 14;
    private int padding = 10;
    private int timeUserEnteredUIObject;
    private final int delay = 1000;
    private final int fadeInTime = 500;
    private float masterOpacity;

    ButtonHelpText(){

    }

    public void setTimeUserEnteredUIObject() {
        timeUserEnteredUIObject = millis();
        isVisible = true;
    }

    public void setVisible(boolean _isVisible){
        isVisible = _isVisible;
    }

    public void setButtonHelpText(String _myText, int _x, int _y){
        myText = _myText;
        x = _x;
        y = _y;
    }

    public void draw(){
        //When using expert mode, disable help text over UI objects
        if (!isVisible || guiSettings.getExpertModeBoolean()) {
            return;
        }

        int delta = millis() - timeUserEnteredUIObject;
        boolean timeToShowHelpText =  delta > delay;

        if (timeToShowHelpText) {
            
            //Fade in the help text
            masterOpacity = (delta < delay + fadeInTime) ? map(delta, delay, delay + fadeInTime, 0, 255) : 255f;

            pushStyle();
            textAlign(CENTER, TOP);

            textFont(p5,12);
            textLeading(lineSpacing); //line spacing
            stroke(31,69,110, masterOpacity);
            fill(255, masterOpacity);
            numLines = (int)((float)myText.length()/30.0f) + 1; //add 1 to round up
            // println("numLines: " + numLines);
            //if on left side of screen, draw box brightness to prevent box off screen
            if(x <= width/2){
                rect(x, y, 200, 2*padding + numLines*lineSpacing + 4);
                fill(31,69,110, masterOpacity); //text color
                text(myText, x + padding, y + padding, 180, (numLines*lineSpacing + 4));
            } else{ //if on right side of screen, draw box left to prevent box off screen
                rect(x - 200, y, 200, 2*padding + numLines*lineSpacing + 4);
                fill(OPENBCI_BLUE); //text color
                text(myText, x + padding - 200, y + padding, 180, (numLines*lineSpacing + 4));
            }
            popStyle();
        }
    }
};

////////////////////////////////////////////////////////////////////////////////////
//                              MENULIST CLASS                                    //
//   Based on ControlP5 Processing Library example, written by Andreas Schlegel   //
//      WARNING: This class does not respond well to being resized -RW 5/5/23     //
////////////////////////////////////////////////////////////////////////////////////
public class MenuList extends controlP5.Controller {

    float pos, npos;
    int itemHeight = 24;
    int scrollerLength = 40;
    int scrollerWidth = 15;
    List< Map<String, Object>> items = new ArrayList< Map<String, Object>>();
    PGraphics menu;
    boolean updateMenu;
    int hoverItem = -1;
    int activeItem = -1;
    PFont menuFont;
    int padding = 7;

    MenuList(ControlP5 c, String theName, int theWidth, int theHeight, PFont theFont) {

        super( c, theName, 0, 0, theWidth, theHeight );
        c.register( this );
        menu = createGraphics(getWidth(),getHeight());
        final ControlP5 cc = c; //allows check for isLocked() below
        final String _theName = theName;

        menuFont = theFont;

        setView(new ControllerView<MenuList>() {

            public void display(PGraphics pg, MenuList t) {
                if (updateMenu && !cc.get(MenuList.class, _theName).isLock()) {
                    updateMenu();
                }
                if (isMouseOver()) {
                    menu.beginDraw();
                    int len = -(itemHeight * items.size()) + getHeight();
                    int ty;
                    if(len != 0){
                        ty = PApplet.parseInt(map(pos, len, 0, getHeight() - scrollerLength - 2, 2 ) );
                    } else {
                        ty = 0;
                    }
                    menu.fill(OPENBCI_DARKBLUE, 100);
                    if(ty > 0){
                        menu.rect(getWidth()-scrollerWidth-2, ty, scrollerWidth, scrollerLength );
                    }
                    menu.endDraw();
                }
                pg.image(menu, 0, 0);
            }
        }
        );
        updateMenu();
    }

    //only update the image buffer when necessary - to save some resources
    public void updateMenu() {
        int len = -(itemHeight * items.size()) + getHeight();
        npos = constrain(npos, len, 0);
        pos += (npos - pos) * 0.1f;
        //    pos += (npos - pos) * 0.1;
        menu.beginDraw();
        menu.noStroke();
        menu.background(255, 64);
        // menu.textFont(cp5.getFont().getFont());
        menu.textFont(menuFont);
        menu.pushMatrix();
        menu.translate( 0, pos );
        menu.pushMatrix();

        int i0;
        if((itemHeight * items.size()) != 0){
            i0 = PApplet.max( 0, PApplet.parseInt(map(-pos, 0, itemHeight * items.size(), 0, items.size())));
        } else{
            i0 = 0;
        }
        int range = ceil((PApplet.parseFloat(getHeight())/PApplet.parseFloat(itemHeight))+1);
        int i1 = PApplet.min( items.size(), i0 + range );

        menu.translate(0, i0*itemHeight);

        for (int i=i0; i<i1; i++) {
            Map m = items.get(i);
            menu.fill(255, 100);
            if (i == hoverItem) {
                menu.fill(127, 134, 143);
            }
            if (i == activeItem) {
                menu.stroke(TURN_ON_GREEN);
                menu.strokeWeight(1);
                menu.fill(TURN_ON_GREEN);
                menu.rect(0, 0, getWidth()-1, itemHeight-1 );
                menu.noStroke();
            } else {
                menu.rect(0, 0, getWidth(), itemHeight-1 );
            }
            menu.fill(OPENBCI_DARKBLUE);
            menu.textFont(menuFont);

            //make sure there is something in the Ganglion serial list...
            try {
                menu.text(m.get("headline").toString(), 8, itemHeight - padding); // 5/17
                menu.translate( 0, itemHeight );
            } catch(Exception e){
                println("Nothing in list...");
            }
        }
        menu.popMatrix();
        menu.popMatrix();
        menu.endDraw();
        updateMenu = abs(npos-pos)>0.01f ? true:false;
    }

    // When detecting a click, check if the click happend to the far right, if yes, scroll to that position,
    // Otherwise do whatever this item of the list is supposed to do.
    public void onClick() {
        println(getName() + ": click! ");
        if (items.size() > 0) { //Fixes #480
            if (getPointer().x()>getWidth()-scrollerWidth) {
                if(getHeight() != 0){
                    npos= -map(getPointer().y(), 0, getHeight(), 0, items.size()*itemHeight);
                }
                updateMenu = true;
            } else {
                int len = itemHeight * items.size();
                int index = 0;
                if(len != 0){
                    index = PApplet.parseInt( map( getPointer().y() - pos, 0, len, 0, items.size() ) ) ;
                }
                setValue(index);
                activeItem = index;
            }
            updateMenu = true;
        }
    }

    public void onMove() {
        if (getPointer().x()>getWidth() || getPointer().x()<0 || getPointer().y()<0  || getPointer().y()>getHeight() ) {
            hoverItem = -1;
        } else {
            int len = itemHeight * items.size();
            int index = 0;
            if(len != 0){
                index = PApplet.parseInt( map( getPointer().y() - pos, 0, len, 0, items.size() ) ) ;
            }
            hoverItem = index;
        }
        updateMenu = true;
    }

    public void onDrag() {
        if (getPointer().x() > (getWidth()-scrollerWidth)) {
            npos= -map(getPointer().y(), 0, getHeight(), 0, items.size()*itemHeight);
            updateMenu = true;
        } else {
            npos += getPointer().dy() * 2;
            updateMenu = true;
        }
    }

    public void onScroll(int n) {
        npos += ( n * 4 );
        updateMenu = true;
    }

    public void addItem(Map<String, Object> m) {
        items.add(m);
        updateMenu = true;
    }

    public void addItem(String theHeadline) {
        Map m = new HashMap<String, Object>();
        m.put("headline", theHeadline);
        addItem(m);
    }

    public void addItem(String theHeadline, int value) {
        Map m = new HashMap<String, Object>();
        m.put("headline", theHeadline);
        m.put("value", value);
        items.add(m);
    }

    public void addItem(String theHeadline, String theSubline, String theCopy) {
        Map m = new HashMap<String, Object>();
        m.put("headline", theHeadline);
        m.put("subline", theSubline);
        m.put("copy", theCopy);
        items.add(m);
    }

    public void removeItem(Map<String, Object> m) {
        items.remove(m);
        updateMenu = true;
    }

    //Returns null if selecting an item that does not exist
    public Map<String, Object> getItem(int theIndex) {
        Map<String, Object> m = new HashMap<String, Object>();
        try {
            m = items.get(theIndex);
        } catch (Exception e) {
            //println("Item " + theIndex + " does not exist.");
        }
        return m;
    }

    public int getListSize() {
       return items.size(); 
    }
};

////////////////////////////////////////////////////////////////
//                      GUI CopyPaste                         //
// Custom class used by the GUI to handle both Copy and Paste //
// Use standard copy and paste keyboard shortcuts for all OS  //
//                                                            //
// Copy ControlP5 Textfield Text                              //
//      - Windows and Linux: Control + C                      //
//      - Mac: Command + C                                    //
// Paste Text into Textfield                                  //
//      - Windows and Linux: Control + V                      //
//      - Mac: Command + V                                    //
////////////////////////////////////////////////////////////////
class CopyPaste {

    private final int CMD_CNTL_KEYCODE = (isLinux() || isWindows()) ? 17 : 157;
    private final int C_KEYCODE = 67;
    private final int V_KEYCODE = 86;
    private boolean commandControlPressed;
    private boolean copyPressed;
    private String value;

    CopyPaste () {

    }
    
    public boolean checkIfPressedAllOS() {
        //This logic mimics the behavior of copy/paste in Mac OS X, and applied to all.
        if (keyCode == CMD_CNTL_KEYCODE) {
            commandControlPressed = true;
            //println("KEYBOARD SHORTCUT: COMMAND PRESSED");
            return true;
        }

        if (commandControlPressed && keyCode == V_KEYCODE) {
            //println("KEYBOARD SHORTCUT: PASTE PRESSED");
            // Get clipboard contents
            String s = GClip.paste();
            //println("FROM CLIPBOARD ~~ " + s);
            // Assign to stored value
            value = s;
            return true;
        }

        if (commandControlPressed && keyCode == C_KEYCODE) {
            //println("KEYBOARD SHORTCUT: COPY PRESSED");
            copyPressed = true;
            return true;
        }

        return false;
    }

    public void checkIfReleasedAllOS() {
        if (keyCode == CMD_CNTL_KEYCODE) {
            commandControlPressed = false;
        }
    }
    
    //Pull stored value from this class and set to null, otherwise return null.
    private String pullValue() {
        if (value == null) {
            return value;
        }
        String s = value;
        value = null;
        return s;
    }

    private void checkForPaste(Textfield tf) {
        if (value == null) {
            return;
        }

        if (tf.isFocus()) {
            StringBuilder status = new StringBuilder("OpenBCI_GUI: User pasted text from the clipboard into ");
            status.append(tf.toString());
            println(status);
            StringBuilder sb = new StringBuilder();
            String existingText = dropNonPrintableChars(tf.getText());
            String val = pullValue();
            //println("EXISTING TEXT =="+ existingText+ "__end. VALUE ==" + val + "__end.");

            // On Mac, Remove 'v' character from the end of the existing text
            existingText = existingText.length() > 0 && isMac() ? existingText.substring(0, existingText.length() - 1) : existingText;

            sb.append(existingText);
            sb.append(val);
            //The 'v' character does make it to the textfield, but this is immediately overwritten here.
            tf.setText(sb.toString());
        } 
    }

    private void checkForCopy(Textfield tf) {
        if (!copyPressed) {
            return;
        }

        if (tf.isFocus()) {
            String s = dropNonPrintableChars(tf.getText());
            if (s.length() == 0) {
                return;
            }
            StringBuilder status = new StringBuilder("OpenBCI_GUI: User copied text from ");
            status.append(tf.toString());
            status.append(" to the clipboard");
            println(status);
            //println("FOUND TEXT =="+ s+"__end.");
            if (isMac()) {
                //Remove the 'c' character that was just typed in the textfield
                s = s.substring(0, s.length() - 1);
                tf.setText(s);
                //println("MAC FIXED TEXT =="+ s+"__end.");
            }
            boolean b = GClip.copy(s);
            copyPressed = false;
        } 
    }

    public void checkForCopyPaste(Textfield tf) {
        checkForPaste(tf);
        checkForCopy(tf);
    }
}

//Cp5 Textfield helper class
public class TextFieldUpdateHelper {

    // textFieldIsActive is used to ignore hotkeys when a textfield is active. Resets to false on every draw loop.
    private boolean textFieldIsActive = false;

    TextFieldUpdateHelper() {

    }
    
    public void resetTextFieldIsActive() {
        textFieldIsActive = false;
    }

    public boolean getAnyTextfieldsActive() {
        return textFieldIsActive;
    }

    public void checkTextfield(Textfield tf) {
        if (tf.isVisible()) {
            tf.setUpdate(true);
            if (tf.isFocus()) {
                textFieldIsActive = true;
                copyPaste.checkForCopyPaste(tf);
            }
        } else {
            tf.setUpdate(false);
        }
    }
}


public enum ElectrodeState {
    GREYED_OUT(0, 0xFF717577),
    RED(1, 0xFFFF0000),
    YELLOW(2, 0xFFE6C700),
    GREEN(3, 0xFF00FF64),
    BLUE(4, 0xFF416080),
    NOT_TESTABLE(4, 0xFF717577);

    private final int value;
    private final int _color;

    ElectrodeState(int newValue, int c) {
        value = newValue;
        _color = c;
    }

    public int getValue() { return value; }

    public int getColor() { return _color; }
}

interface CytonElectrodeEnum {
    public int getIndex();
    public Integer getChanGUI();
    public String getADSChan();
    public String getMeasurementType();
    public boolean isPin_N();
    public float[] getCircleXY();
    public String getLabelName();
    public float[] getLabelXY();
    public float getBorderScalar();
}

public enum CytonElectrodeLocations implements CytonElectrodeEnum
{
    ONE_N(0, 1, "1N", "EEG", 0.10000f, 0.38992f, "Fp1", 0.50000f, 0.15265f),
    TWO_N(1, 2, "2N", "EEG", 0.10000f, 0.51967f, "Fp2", 0.50000f, 0.18308f),
    THREE_N(2, 3, "3N", "EEG", 0.10000f,   0.64941f, "C3", 0.50000f, 0.11283f),
    FOUR_N(3, 4, "4N", "EEG", 0.10000f, 0.92547f, "C4", 0.50000f, 0.17101f),
    FIVE_N(4, 5, "5N", "EEG", 0.18140f,   0.64941f, "P7", 0.38278f, 0.19765f),
    SIX_N(5, 6, "6N", "EEG", 0.11781f,	0.64941f, "P8", 0.61722f, 0.19765f),
    SEVEN_N(6, 7, "7N", "EEG", 0.17313f, 0.88820f, "O1", 0.37352f, 0.15514f),
    EIGHT_N(7, 8, "8N", "EEG", 0.12608f, 0.88820f, "O2", 0.62530f, 0.15514f),
    NINE_N(8, 9, "9N", "EEG", 0.10000f, 0.38992f, "F7", 0.50000f, 0.15265f),
    TEN_N(9, 10, "10N", "EEG", 0.10000f, 0.51967f, "F8", 0.50000f, 0.18308f),
    ELEVEN_N(10, 11, "11N", "EEG", 0.10000f,   0.64941f, "F3", 0.50000f, 0.11283f),
    TWELVE_N(11, 12, "12N", "EEG", 0.10000f, 0.92547f, "F4", 0.50000f, 0.17101f),
    THIRTEEN_N(12, 13, "13N", "EEG", 0.18140f,   0.64941f, "T7", 0.18278f, 0.19765f),
    FOURTEEN_N(13, 14, "14N", "EEG", 0.11781f,	0.64941f, "T8", 0.11722f, 0.19765f),
    FIFTEEN_N(14, 15, "15N", "EEG", 0.17313f, 0.88820f, "P3", 0.11352f, 0.11514f),
    SIXTEEN_N(15, 16, "16N", "EEG", 0.12608f, 0.88820f, "P4", 0.11530f, 0.11514f);

    private int index;
    private Integer guiChan;
    private String adsChan;
    private String measurement;
    //Used to draw electrode status circles on the visual map in the correct locations.
    private float xPosScale;
    private float yPosScale;
    //Used to draw labels
    private String labelName;
    private float labelXScale;
    private float labelYScale;

    private static CytonElectrodeLocations[] vals = values();
 
    CytonElectrodeLocations(int index, Integer channel, String adsChan, String type, float xPosScale, float yPosScale, String labelName, float labelXScale, float labelYScale) {
        this.index = index;
        this.guiChan = channel;
        this.adsChan = adsChan;
        this.measurement = type;  
        this.xPosScale = xPosScale;
        this.yPosScale = yPosScale;
        this.labelName = labelName;
        this.labelXScale = labelXScale;
        this.labelYScale = labelYScale;
    }

    @Override
    public int getIndex() {
        return index;
    }

    public static CytonElectrodeLocations getByIndex(int i) {
        return vals[i];
    }

    public static CytonElectrodeLocations getByADSChan(String value) {  
        if (value != null) {  
            for (CytonElectrodeLocations location : values()) {  
                if (location.adsChan.equals(value)) {  
                    return location;  
                }  
            }  
        }
        println("getByADSChan - ERROR | Value == " + value);
        throw new IllegalArgumentException("Invalid electrode location: " + value);
    }

    public static String[] getAllLocationNames() {
        return Arrays.toString(values()).replaceAll("^.|.$", "").split(", ");
    }

    @Override
    public Integer getChanGUI() {
        return guiChan;
    }

    @Override
    public String getADSChan() {
        return adsChan;
    }

    @Override
    public String getMeasurementType() {
        return measurement;
    }

    @Override
    public boolean isPin_N() {
        return adsChan.endsWith("N");
    }

    // 72/2538 = 0.02836
    //Manual adjustment 70%. 0.02836 * .7 = 0.019852
    public static float getDiameterScalar() {
        //return 0.019852; //70%
        return 0.022688f; //80%
    }

    @Override
    public float[] getCircleXY() {
        return new float[] { xPosScale, yPosScale };
    }

    @Override
    public String getLabelName() {
        return labelName;
    }

    @Override
    public float[] getLabelXY() {
        return new float[] { labelXScale, labelYScale };
    }

    @Override
    public float getBorderScalar() {
        return 0.05f;
    }
}

class CytonElectrodeStatus {

    private CytonElectrodeLocations thisElectrode;

    protected BoardCyton cytonBoard;
    protected Integer channelNumber;
    protected String electrodeLocation;
    protected String measurement;
    protected int dataTableColumnOffset;
    protected double statusValue;
    protected String statusValueAsString;
    protected String anatomicalName;
    protected ElectrodeState state_live;
    protected ElectrodeState state_imp;
    protected NumberFormat railedNF = NumberFormat.getInstance();
    protected DecimalFormat impedanceNF;
    protected DecimalFormat impShortNF;
    //Impedance ranges in kOhms
    protected double impedanceGreenCutoff = 750d;
    protected double impedanceYellowCuttoff = 2500d;
    //Anything greater than impedanceYellowCuttoff is red
    private boolean isCheckingAnotherElectrode = false;
    protected boolean isInImpedanceMode = false;

    protected ControlP5 local_cp5;
    protected Button testing_button;
    protected RectDimensions cellDims;
    protected final int testingButtonPadding = 3;

    protected boolean is_N_Pin = false;

    protected Gif checkingElectrodeGif;
    protected final int gifDiameterBorderOffset = 30; //From the weight of the pixels in the original gif

    CytonElectrodeStatus(ControlP5 _cp5, CytonElectrodeEnum electrodeEnum, BoardCyton _impBoard, Gif statusGif) {
        local_cp5 = _cp5;
        cytonBoard = (BoardCyton)_impBoard;
        impedanceNF = new DecimalFormat("###,###.#");
        impShortNF = new DecimalFormat("###,###");

        thisElectrode = (CytonElectrodeLocations)electrodeEnum;
        channelNumber = thisElectrode.getChanGUI();
        electrodeLocation = thisElectrode.getADSChan();
        measurement = thisElectrode.getMeasurementType();
        anatomicalName = thisElectrode.getLabelName();
        is_N_Pin = thisElectrode.isPin_N();
        railedNF.setMaximumFractionDigits(2);
        dataTableColumnOffset = is_N_Pin ? 1 : 2;
        checkingElectrodeGif = statusGif;

        state_imp = ElectrodeState.GREYED_OUT;
        state_live = ElectrodeState.GREYED_OUT;

        //This will be resized and positioned during session starts when widget is assigned a container
        createCytonElectrodeTestingButton("electrode_"+electrodeLocation, "Test", 0, 0, 20, 10);
    }

    public void draw(int w, int h) {

        float x = w * thisElectrode.getCircleXY()[0];
        float y = h * thisElectrode.getCircleXY()[1];

        ElectrodeState state = getElectrodeState();

        pushStyle();
        fill(state.getColor());
        float d = w * thisElectrode.getDiameterScalar();
        ellipseMode(CENTER);
        ellipse(x, y, d, d);

        if (state != ElectrodeState.NOT_TESTABLE && cytonBoard.isCheckingImpedanceNorP(channelNumber-1, is_N_Pin)) {
            imageMode(CENTER);
            image(checkingElectrodeGif, x - 1, y - 1, d + gifDiameterBorderOffset, d + gifDiameterBorderOffset);
        }
        popStyle();
    }

    public void update(Grid _dataTable, boolean _isImpedanceMode) {
        
        isInImpedanceMode = _isImpedanceMode;
        ElectrodeState state = getElectrodeState();

        if (state == ElectrodeState.NOT_TESTABLE) {
            return;
        }

        int i = channelNumber - 1;

        if (_isImpedanceMode && cytonBoard.isCheckingImpedanceNorP(i, is_N_Pin) && cytonBoard.isStreaming()) {
            
            //update the impedance values
            statusValue = data_elec_imp_ohm[i]/1000; //value in kOhm
            boolean greaterThanZero = statusValue > Double.MIN_NORMAL;
            int railedTextColor = OPENBCI_DARKBLUE;
            if (statusValue > impedanceYellowCuttoff) {
                state_imp = ElectrodeState.RED;
            } else if (statusValue < impedanceYellowCuttoff && statusValue > impedanceGreenCutoff) {
                state_imp = ElectrodeState.YELLOW;
            } else if (greaterThanZero && statusValue < impedanceGreenCutoff) {
                state_imp = ElectrodeState.GREEN;
            }
            //Impedance mode uses buttons carefully positioned in the table to display information
            testing_button.getCaptionLabel().setText(getImpValShortString());
            testing_button.setColorCaptionLabel(state.getColor());

        } else if (!_isImpedanceMode) {

            //update the railed percentage values
            statusValue = is_railed[i].getPercentage();
            boolean greaterThanZero = statusValue > Double.MIN_NORMAL;
            int railedTextColor = OPENBCI_DARKBLUE;
            if (is_railed[i].is_railed) {
                state_live = ElectrodeState.RED;
                railedTextColor = SIGNAL_CHECK_RED;
            } else if (is_railed[i].is_railed_warn) {
                state_live = ElectrodeState.YELLOW;
                railedTextColor = SIGNAL_CHECK_YELLOW;
            } else if (greaterThanZero) {
                state_live = ElectrodeState.BLUE;
            }
            //Railed percentage mode (Live) uses text in the data table
            StringBuilder s = new StringBuilder(railedNF.format(statusValue));
            s.append(" %");
            _dataTable.setString(s.toString(), channelNumber, dataTableColumnOffset);
            _dataTable.setTextColor(railedTextColor, channelNumber, dataTableColumnOffset);

        }
    }

    public String getImpedanceValueAsString(boolean isAnatomicalName) {
        StringBuilder sb = new StringBuilder(isAnatomicalName ? anatomicalName : electrodeLocation);
        sb.append(" - ");
        sb.append(impedanceNF.format(statusValue));
        sb.append(" kOhm");
        return sb.toString();
    }

    public String getImpValShortString() {
        StringBuilder sb = new StringBuilder(impShortNF.format(statusValue));
        sb.append(" k\u2126");
        return sb.toString();
    }

    public Integer getGUIChannelNumber() {
        return channelNumber;
    }

    public final ElectrodeState getElectrodeState() {
        return isInImpedanceMode ? state_imp : state_live;
    }

    public void setElectrodeState(ElectrodeState s) {
        if (isInImpedanceMode) {
            state_imp = s;
        } else {
            state_live = s;
        }
    }

    public boolean getIsNPin() {
        return is_N_Pin;
    }

    public void overrideTestingButtonSwitch(boolean b) {
        if (b) {
            testing_button.setOn();
        } else {
            testing_button.setOff();
        }
    }

    public void updateGreenThreshold(double _d) {
        impedanceGreenCutoff = _d;
    }

    public void updateYellowThreshold(double _d) {
        impedanceYellowCuttoff = _d;
    }

    //Here is the method that creates a "Test" button for every electrode position
    protected void createCytonElectrodeTestingButton(String name, String text, int _x, int _y, int _w, int _h) {
        ElectrodeState state = getElectrodeState();
        if (state == ElectrodeState.NOT_TESTABLE) {
            return; //Some electrode positions cannot be tested
        }
        testing_button = createButton(local_cp5, name, text, _x, _y, _w, _h);
        testing_button.setBorderColor(null);
        testing_button.setColorActive(BUTTON_PRESSED_LIGHT);
        testing_button.setColorForeground(BUTTON_HOVER_LIGHT);
        testing_button.setSwitch(true); //This turns the button into a switch. Switch will be Off by default.
        testing_button.onPress(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                final int _chan = channelNumber - 1;
                final int curMillis = millis();
                println("CytonElectrodeTestButton: Toggling Impedance on ~~ " + electrodeLocation);
                w_cytonImpedance.toggleImpedanceOnElectrode(!cytonBoard.isCheckingImpedanceNorP(_chan, is_N_Pin), _chan, is_N_Pin, curMillis);
            }
        });
        testing_button.setDescription("Click to toggle impedance check for this ADS pin.");
    }

    public void resizeButton(Grid _dataTable) {
        ElectrodeState state = getElectrodeState();
        if (state == ElectrodeState.NOT_TESTABLE) {
            return; //Some electrode positions cannot be tested
        }
        cellDims = _dataTable.getCellDims(channelNumber, dataTableColumnOffset);
        testing_button.setPosition(cellDims.x, cellDims.y + 1);
        testing_button.setSize(cellDims.w + 1, cellDims.h - 1);
    }

    //Override the electrode state
    public void setElectrodeGreyedOut() {
        ElectrodeState state = getElectrodeState();
        if (state == ElectrodeState.NOT_TESTABLE) {
            return;
        }
        state = ElectrodeState.GREYED_OUT;
    }

    //Override the electrode state
    public void setElectrodeGreenStatus() {
        ElectrodeState state = getElectrodeState();
        if (state == ElectrodeState.NOT_TESTABLE) {
            return;
        }
        state = ElectrodeState.GREEN;
    }

    public void resetTestingButton() {
        testing_button.getCaptionLabel().setText("Test");
        testing_button.setOff();
    }

    public void setLockTestingButton(boolean b) {
        if (testing_button != null) {
            testing_button.setLock(b);
        }
    }

    public Button getTestingButton() {
        return testing_button;
    }

    public void drawLabels(boolean _showAnatomicalName, int container_x, int container_y, int w, int h, PFont _font) {
        pushStyle();
        fill(OPENBCI_DARKBLUE);
        textAlign(CENTER);
        textFont(_font);
        float x = w * thisElectrode.getLabelXY()[0];
        float y = h * thisElectrode.getLabelXY()[1];
        String s = _showAnatomicalName ? thisElectrode.getLabelName() : thisElectrode.getADSChan();
        text(s, container_x + x, container_y + y);
        popStyle();
    }

    public String getThisElectrodeLabel() {
        return thisElectrode.getLabelName();
    }
}

public enum CytonSignalCheckMode implements IndexingInterface
{
    LIVE (0, "Live"),
    IMPEDANCE (1, "Impedance");

    private int index;
    private String label;
    private static CytonSignalCheckMode[] vals = values();

    CytonSignalCheckMode(int _index, String _label) {
        this.index = _index;
        this.label = _label;
    }

    @Override
    public String getString() {
        return label;
    }

    @Override
    public int getIndex() {
        return index;
    }

    public boolean getIsImpedanceMode() {
        return label.equals("Impedance");
    }

    private static List<String> getEnumStringsAsList() {
        List<String> enumStrings = new ArrayList<String>();
        for (IndexingInterface val : vals) {
            enumStrings.add(val.getString());
        }
        return enumStrings;
    }
}

public enum CytonImpedanceLabels implements IndexingInterface
{
    ADS_CHANNEL (0, "Channel"),
    ANATOMICAL (1, "Anatomical")
    ;

    private int index;
    private String label;
    private boolean boolean_value;
    private static CytonImpedanceLabels[] vals = values();

    CytonImpedanceLabels(int _index, String _label) {
        this.index = _index;
        this.label = _label;
    }

    @Override
    public String getString() {
        return label;
    }

    @Override
    public int getIndex() {
        return index;
    }

    public boolean getIsAnatomicalName() {
        return label.equals("Anatomical");
    }

    private static List<String> getEnumStringsAsList() {
        List<String> enumStrings = new ArrayList<String>();
        for (IndexingInterface val : vals) {
            enumStrings.add(val.getString());
        }
        return enumStrings;
    }
}

public enum CytonImpedanceInterval implements IndexingInterface
{
    FOUR (0, 4000, "4 sec"),
    FIVE (1, 5000, "5 sec"),
    SEVEN (2, 7000, "7 sec"),
    TEN (3, 10000, "10 sec")
    ;

    private int index;
    private int value;
    private String label;
    private boolean boolean_value;
    private static CytonImpedanceInterval[] vals = values();

    CytonImpedanceInterval(int _index, int _val, String _label) {
        this.index = _index;
        this.value = _val;
        this.label = _label;
    }

    @Override
    public String getString() {
        return label;
    }

    @Override
    public int getIndex() {
        return index;
    }

    public int getValue() {
        return value;
    }

    private static List<String> getEnumStringsAsList() {
        List<String> enumStrings = new ArrayList<String>();
        for (IndexingInterface val : vals) {
            enumStrings.add(val.getString());
        }
        return enumStrings;
    }
}
class DataLogger {
    //variables for writing EEG data out to a file
    private DataWriterODF fileWriterODF;
    private DataWriterAuxODF fileWriterAuxODF;
    private DataWriterBDF fileWriterBDF;
    public DataWriterBF fileWriterBF; //Add the ability to simulataneously save to BrainFlow CSV, independent of BDF or ODF
    private String sessionName = "N/A";
    public final int OUTPUT_SOURCE_NONE = 0;
    public final int OUTPUT_SOURCE_ODF = 1; // The OpenBCI CSV Data Format
    public final int OUTPUT_SOURCE_BDF = 2; // The BDF data format http://www.biosemi.com/faq/file_format.htm
    private int outputDataSource;

    DataLogger() {
        //Default to OpenBCI CSV Data Format
        outputDataSource = OUTPUT_SOURCE_ODF;
        fileWriterBF = new DataWriterBF();
    }

    public void initialize() {

    }

    public void uninitialize() {
        closeLogFile();  //close log file
        fileWriterBF.resetBrainFlowStreamer();
    }

    public void update() {
        limitRecordingFileDuration();

        saveNewData();
    }

    
    private void saveNewData() {
        //If data is available, save to playback file...
        if(!settings.isLogFileOpen()) {
            return;
        }

        double[][] newData = currentBoard.getFrameData();

        switch (outputDataSource) {
            case OUTPUT_SOURCE_ODF:
                fileWriterODF.append(newData);
                if (currentBoard instanceof AuxDataBoard)
                    fileWriterAuxODF.append(((AuxDataBoard)currentBoard).getAuxFrameData());
                break;
            case OUTPUT_SOURCE_BDF:
                fileWriterBDF.writeRawData_dataPacket(newData);
                break;
            case OUTPUT_SOURCE_NONE:
            default:
                // Do nothing...
                break;
        }
    }

    public void limitRecordingFileDuration() {
        if (settings.isLogFileOpen() && outputDataSource == OUTPUT_SOURCE_ODF && settings.maxLogTimeReached()) {
            println("DataLogging: Max recording duration reached for OpenBCI data format. Creating a new recording file in the session folder.");
            closeLogFile();
            openNewLogFile(directoryManager.getFileNameDateTime());
            settings.setLogFileStartTime(System.nanoTime());
        }
    }

    public void onStartStreaming() {
        if (outputDataSource > OUTPUT_SOURCE_NONE && eegDataSource != DATASOURCE_PLAYBACKFILE) {
            //open data file if it has not already been opened
            if (!settings.isLogFileOpen()) {
                openNewLogFile(directoryManager.getFileNameDateTime());
            }
            settings.setLogFileStartTime(System.nanoTime());
        }

        //Print BrainFlow Streamer Info here after ODF and BDF println
        if (eegDataSource != DATASOURCE_PLAYBACKFILE && eegDataSource != DATASOURCE_STREAMING) {
            controlPanel.setBrainFlowStreamerOutput();
            StringBuilder sb = new StringBuilder("OpenBCI_GUI: BrainFlow Streamer Location: ");
            sb.append(brainflowStreamer);
            println(sb.toString());
        }
    }

    public void onStopStreaming() {
        //Close the log file when using OpenBCI Data Format (.txt)
        if (outputDataSource == OUTPUT_SOURCE_ODF) closeLogFile();
    }

    public float getSecondsWritten() {
        if (outputDataSource == OUTPUT_SOURCE_ODF && fileWriterODF != null) {
            return PApplet.parseFloat(fileWriterODF.getRowsWritten())/currentBoard.getSampleRate();
        }
        
        if (outputDataSource == OUTPUT_SOURCE_BDF && fileWriterBDF != null) {
            return fileWriterBDF.getRecordsWritten();
        }

        return 0.f;
    }

    private void openNewLogFile(String _fileName) {
        //close the file if it's open
        switch (outputDataSource) {
            case OUTPUT_SOURCE_ODF:
                openNewLogFileODF(_fileName);
                break;
            case OUTPUT_SOURCE_BDF:
                openNewLogFileBDF(_fileName);
                break;
            case OUTPUT_SOURCE_NONE:
            default:
                // Do nothing...
                break;
        }
        settings.setLogFileIsOpen(true);
    }

    /**
    * @description Opens (and closes if already open) and BDF file. BDF is the
    *  biosemi data format.
    * @param `_fileName` {String} - The meat of the file name
    */
    private void openNewLogFileBDF(String _fileName) {
        if (fileWriterBDF != null) {
            println("OpenBCI_GUI: closing log file");
            closeLogFile();
        }
        //open the new file
        fileWriterBDF = new DataWriterBDF(_fileName);

        output_fname = fileWriterBDF.fname;
        println("OpenBCI_GUI: openNewLogFile: opened BDF output file: " + output_fname); //Print filename of new BDF file to console
    }

    /**
    * @description Opens (and closes if already open) and ODF file. ODF is the
    *  openbci data format.
    * @param `_fileName` {String} - The meat of the file name
    */
    private void openNewLogFileODF(String _fileName) {
        if (fileWriterODF != null) {
            println("OpenBCI_GUI: closing log file");
            closeLogFile();
        }
        //open the new file
        fileWriterODF = new DataWriterODF(sessionName, _fileName);
        if (currentBoard instanceof AuxDataBoard) {
            if (fileWriterAuxODF != null)
                fileWriterAuxODF.closeFile();
            fileWriterAuxODF = new DataWriterAuxODF(sessionName, _fileName);
        }

        output_fname = fileWriterODF.fname;
        println("OpenBCI_GUI: openNewLogFile: opened ODF output file: " + output_fname); //Print filename of new ODF file to console
    }

    private void closeLogFile() {
        switch (outputDataSource) {
            case OUTPUT_SOURCE_ODF:
                closeLogFileODF();
                break;
            case OUTPUT_SOURCE_BDF:
                closeLogFileBDF();
                break;
            case OUTPUT_SOURCE_NONE:
            default:
                // Do nothing...
                break;
        }
        settings.setLogFileIsOpen(false);
    }

    /**
    * @description Close an open BDF file. This will also update the number of data
    *  records.
    */
    private void closeLogFileBDF() {
        if (fileWriterBDF != null) {
            fileWriterBDF.closeFile();
        }
        fileWriterBDF = null;
    }

    /**
    * @description Close an open ODF file.
    */
    private void closeLogFileODF() {
        if (fileWriterODF != null) {
            fileWriterODF.closeFile();
        }
        fileWriterODF = null;
        if (fileWriterAuxODF != null) {
            fileWriterAuxODF.closeFile();
        }
        fileWriterAuxODF = null;
    }

    public int getDataLoggerOutputFormat() {
        return outputDataSource;
    }

    public void setDataLoggerOutputFormat(int outputSource) {
        outputDataSource = outputSource;
    }

    public void setSessionName(String s) {
        sessionName = s;
    }

    public final String getSessionName() {
        return sessionName;
    }
    
    public void setBfWriterFolder(String _folderName, String _folderPath) {
        fileWriterBF.setBrainFlowStreamerFolderName(_folderName, _folderPath);
    }

    public void setBfWriterDefaultFolder() {
        fileWriterBF.setBrainFlowStreamerFolderName(sessionName, settings.getSessionPath());
    }

    public String getBfWriterFilePath() {
        return fileWriterBF.getBrainFlowStreamerRecordingFileName();
    }
};

//------------------------------------------------------------------------
//                       Global Variables & Instances
//------------------------------------------------------------------------
 //for FFT




String curTimestamp;
HashMap<Integer,String> index_of_times;

float playback_speed_fac = 1.0f;  //make 1.0 for real-time.  larger for faster playback

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------


public void processNewData() {

    List<double[]> currentData = currentBoard.getData(getCurrentBoardBufferSize());
    int[] exgChannels = currentBoard.getEXGChannels();
    int channelCount = currentBoard.getNumEXGChannels();

    //update the data buffers
    for (int Ichan=0; Ichan < channelCount; Ichan++) {
        for(int i = 0; i < getCurrentBoardBufferSize(); i++) {
            dataProcessingRawBuffer[Ichan][i] = (float)currentData.get(i)[exgChannels[Ichan]];
        }

        dataProcessingFilteredBuffer[Ichan] = dataProcessingRawBuffer[Ichan].clone();
    }

    //apply additional processing for the time-domain montage plot (ie, filtering)
    dataProcessing.process(dataProcessingFilteredBuffer, fftBuff);

    dataProcessing.newDataToSend = true;

    //look to see if the latest data is railed so that we can notify the user on the GUI
    for (int Ichan=0; Ichan < nchan; Ichan++) is_railed[Ichan].update(dataProcessingRawBuffer[Ichan], Ichan);

    //compute the electrode impedance. Do it in a very simple way [rms to amplitude, then uVolt to Volt, then Volt/Amp to Ohm]
    for (int Ichan=0; Ichan < nchan; Ichan++) {
        // Calculate the impedance
        float impedance = (sqrt(2.0f)*dataProcessing.data_std_uV[Ichan]*1.0e-6f) / BoardCytonConstants.leadOffDrive_amps;
        // Subtract the 2.2kOhm resistor
        impedance -= BoardCytonConstants.series_resistor_ohms;
        // Verify the impedance is not less than 0
        if (impedance < 0) {
            // Incase impedance some how dipped below 2.2kOhm
            impedance = 0;
        }
        // Store to the global variable
        data_elec_imp_ohm[Ichan] = impedance;
    }
}

public void initializeFFTObjects(ddf.minim.analysis.FFT[] fftBuff, float[][] dataProcessingRawBuffer, int Nfft, float fs_Hz) {

    float[] fooData;
    for (int Ichan=0; Ichan < nchan; Ichan++) {
        //make the FFT objects...Following "SoundSpectrum" example that came with the Minim library
        fftBuff[Ichan].window(ddf.minim.analysis.FFT.HAMMING);

        //do the FFT on the initial data
        if (isFFTFiltered == true) {
            fooData = dataProcessingFilteredBuffer[Ichan];  //use the filtered data for the FFT
        } else {
            fooData = dataProcessingRawBuffer[Ichan];  //use the raw data for the FFT
        }
        fooData = Arrays.copyOfRange(fooData, fooData.length-Nfft, fooData.length);
        fftBuff[Ichan].forward(fooData); //compute FFT on this channel of data
    }
}

//------------------------------------------------------------------------
//                          CLASSES
//------------------------------------------------------------------------

class DataProcessing {
    private float fs_Hz;  //sample rate
    private int nchan;
    float data_std_uV[];
    float polarity[];
    boolean newDataToSend;
    final int[] processing_band_low_Hz = {
        1, 4, 8, 13, 30
    }; //lower bound for each frequency band of interest (2D classifier only)
    final int[] processing_band_high_Hz = {
        4, 8, 13, 30, 55
    };  //upper bound for each frequency band of interest
    float avgPowerInBins[][];
    float headWidePower[];

    public EmgSettings emgSettings;

    DataProcessing(int NCHAN, float sample_rate_Hz) {
        nchan = NCHAN;
        fs_Hz = sample_rate_Hz;
        data_std_uV = new float[nchan];
        polarity = new float[nchan];
        newDataToSend = false;
        avgPowerInBins = new float[nchan][processing_band_low_Hz.length];
        headWidePower = new float[processing_band_low_Hz.length];

        emgSettings = new EmgSettings();
    }
    
    //Process data on a channel-by-channel basis
    private synchronized void processChannel(int Ichan, float[][] data_forDisplay_uV, float[] prevFFTdata) {            
        int Nfft = getNfftSafe();
        double foo;

        // Filter the data in the time domain
        // TODO: Use double arrays here and convert to float only to plot data.
        // ^^^ This might not feasible or meaningful performance improvement. I looked into it a while ago and it seems we need floats for the FFT library also. -RW 2022)
        try {
            double[] tempArray = floatToDoubleArray(data_forDisplay_uV[Ichan]);
            
            //Apply BandStop filter if the filter should be active on this channel
            if (filterSettings.values.bandStopFilterActive[Ichan].isActive()) {
                DataFilter.perform_bandstop(
                    tempArray,
                    currentBoard.getSampleRate(),
                    filterSettings.values.bandStopStartFreq[Ichan],
                    filterSettings.values.bandStopStopFreq[Ichan],
                    filterSettings.values.bandStopFilterOrder[Ichan].getValue(),
                    filterSettings.values.bandStopFilterType[Ichan].getValue(),
                    1.0f);
            }

            //Apply BandPass filter if the filter should be active on this channel
            if (filterSettings.values.bandPassFilterActive[Ichan].isActive()) {
                DataFilter.perform_bandpass(
                    tempArray,
                    currentBoard.getSampleRate(),
                    filterSettings.values.bandPassStartFreq[Ichan],
                    filterSettings.values.bandPassStopFreq[Ichan],
                    filterSettings.values.bandPassFilterOrder[Ichan].getValue(),
                    filterSettings.values.bandPassFilterType[Ichan].getValue(),
                    1.0f);
            }

            //Apply Environmental Noise filter on all channels. Do it like this since there are no codes for NONE or FIFTY_AND_SIXTY in BrainFlow
            switch (filterSettings.values.globalEnvFilter) {
                case FIFTY_AND_SIXTY:
                    DataFilter.remove_environmental_noise(
                        tempArray,
                        currentBoard.getSampleRate(),
                        NoiseTypes.FIFTY.get_code());
                    DataFilter.remove_environmental_noise(
                        tempArray,
                        currentBoard.getSampleRate(),
                        NoiseTypes.SIXTY.get_code());
                    break;
                case FIFTY:
                    DataFilter.remove_environmental_noise(
                        tempArray,
                        currentBoard.getSampleRate(),
                        NoiseTypes.FIFTY.get_code());
                    break;
                case SIXTY:
                    DataFilter.remove_environmental_noise(
                        tempArray,
                        currentBoard.getSampleRate(),
                        NoiseTypes.SIXTY.get_code());
                    break;
                default:
                    break;
            }

            doubleToFloatArray(tempArray, data_forDisplay_uV[Ichan]);
        } catch (BrainFlowError e) {
            e.printStackTrace();
        }

        //compute the standard deviation of the filtered signal...this is for the head plot
        float[] fooData_filt = dataProcessingFilteredBuffer[Ichan];  //use the filtered data
        fooData_filt = Arrays.copyOfRange(fooData_filt, fooData_filt.length-((int)fs_Hz), fooData_filt.length);   //just grab the most recent second of data
        data_std_uV[Ichan]=std(fooData_filt); //compute the standard deviation for the whole array "fooData_filt"

        //copy the previous FFT data...enables us to apply some smoothing to the FFT data
        for (int I=0; I < fftBuff[Ichan].specSize(); I++) {
            prevFFTdata[I] = fftBuff[Ichan].getBand(I); //copy the old spectrum values
        }

        //prepare the data for the new FFT
        float[] fooData;
        if (isFFTFiltered == true) {
            fooData = dataProcessingFilteredBuffer[Ichan];  //use the filtered data for the FFT
        } else {
            fooData = dataProcessingRawBuffer[Ichan];  //use the raw data for the FFT
        }
        fooData = Arrays.copyOfRange(fooData, fooData.length-Nfft, fooData.length);   //trim to grab just the most recent block of data
        float meanData = mean(fooData);  //compute the mean
        for (int I=0; I < fooData.length; I++) fooData[I] -= meanData; //remove the mean (for a better looking FFT

        //compute the FFT
        fftBuff[Ichan].forward(fooData); //compute FFT on this channel of data

        // FFT ref: https://www.mathworks.com/help/matlab/ref/fft.html
        // first calculate double-sided FFT amplitude spectrum
        for (int I=0; I <= Nfft/2; I++) {
            fftBuff[Ichan].setBand(I, (float)(fftBuff[Ichan].getBand(I) / Nfft));
        }
        // then convert into single-sided FFT spectrum: DC & Nyquist (i=0 & i=N/2) remain the same, others multiply by two.
        for (int I=1; I < Nfft/2; I++) {
            fftBuff[Ichan].setBand(I, (float)(fftBuff[Ichan].getBand(I) * 2));
        }

        //average the FFT with previous FFT data so that it makes it smoother in time
        double min_val = 0.01d;
        for (int I=0; I < fftBuff[Ichan].specSize(); I++) {   //loop over each fft bin
            if (prevFFTdata[I] < min_val) prevFFTdata[I] = (float)min_val; //make sure we're not too small for the log calls
            foo = fftBuff[Ichan].getBand(I);
            if (foo < min_val) foo = min_val; //make sure this value isn't too small

            if (true) {
                //smooth in dB power space
                foo =   (1.0d-smoothFac[smoothFac_ind]) * java.lang.Math.log(java.lang.Math.pow(foo, 2));
                foo += smoothFac[smoothFac_ind] * java.lang.Math.log(java.lang.Math.pow((double)prevFFTdata[I], 2));
                foo = java.lang.Math.sqrt(java.lang.Math.exp(foo)); //average in dB space
            } else {
                //smooth (average) in linear power space
                foo =   (1.0d-smoothFac[smoothFac_ind]) * java.lang.Math.pow(foo, 2);
                foo+= smoothFac[smoothFac_ind] * java.lang.Math.pow((double)prevFFTdata[I], 2);
                // take sqrt to be back into uV_rtHz
                foo = java.lang.Math.sqrt(foo);
            }
            fftBuff[Ichan].setBand(I, (float)foo); //put the smoothed data back into the fftBuff data holder for use by everyone else
            // fftBuff[Ichan].setBand(I, 1.0f);  // test
        } //end loop over FFT bins

        // calculate single-sided psd by single-sided FFT amplitude spectrum
        // PSD ref: https://www.mathworks.com/help/dsp/ug/estimate-the-power-spectral-density-in-matlab.html
        // when i = 1 ~ (N/2-1), psd = (N / fs) * mag(i)^2 / 4
        // when i = 0 or i = N/2, psd = (N / fs) * mag(i)^2

        for (int i = 0; i < processing_band_low_Hz.length; i++) {
            float sum = 0;
            // int binNum = 0;
            for (int Ibin = 0; Ibin <= Nfft/2; Ibin ++) { // loop over FFT bins
                float FFT_freq_Hz = fftBuff[Ichan].indexToFreq(Ibin);   // center frequency of this bin
                float psdx = 0;
                // if the frequency matches a band
                if (FFT_freq_Hz >= processing_band_low_Hz[i] && FFT_freq_Hz < processing_band_high_Hz[i]) {
                    if (Ibin != 0 && Ibin != Nfft/2) {
                        psdx = fftBuff[Ichan].getBand(Ibin) * fftBuff[Ichan].getBand(Ibin) * Nfft/currentBoard.getSampleRate() / 4;
                    }
                    else {
                        psdx = fftBuff[Ichan].getBand(Ibin) * fftBuff[Ichan].getBand(Ibin) * Nfft/currentBoard.getSampleRate();
                    }
                    sum += psdx;
                    // binNum ++;
                }
            }
            avgPowerInBins[Ichan][i] = sum;   // total power in a band
            // println(i, binNum, sum);
        }
    }

    public void process(float[][] data_forDisplay_uV, ddf.minim.analysis.FFT[] fftData) {              //holds the FFT (frequency spectrum) of the latest data

        float prevFFTdata[] = new float[fftBuff[0].specSize()];

        for (int Ichan=0; Ichan < nchan; Ichan++) { 
            processChannel(Ichan, data_forDisplay_uV, prevFFTdata);
        } //end the loop over channels.

        for (int i = 0; i < processing_band_low_Hz.length; i++) {
            float sum = 0;

            for (int j = 0; j < nchan; j++) {
                sum += avgPowerInBins[j][i];
            }
            headWidePower[i] = sum/nchan;   // averaging power over all channels
        }

        //find strongest channel
        int refChanInd = findMax(data_std_uV);
        //println("EEG_Processing: strongest chan (one referenced) = " + (refChanInd+1));
        float[] refData_uV = dataProcessingFilteredBuffer[refChanInd];  //use the filtered data
        refData_uV = Arrays.copyOfRange(refData_uV, refData_uV.length-((int)fs_Hz), refData_uV.length);   //just grab the most recent second of data


        //compute polarity of each channel
        for (int Ichan=0; Ichan < nchan; Ichan++) {
            float[] fooData_filt = dataProcessingFilteredBuffer[Ichan];  //use the filtered data
            fooData_filt = Arrays.copyOfRange(fooData_filt, fooData_filt.length-((int)fs_Hz), fooData_filt.length);   //just grab the most recent second of data
            float dotProd = calcDotProduct(fooData_filt, refData_uV);
            if (dotProd >= 0.0f) {
                polarity[Ichan]=1.0f;
            } else {
                polarity[Ichan]=-1.0f;
            }
        }

        //Compute EMG values independent of widgets
        emgSettings.values.process(dataProcessingFilteredBuffer);
    }
}

interface DataSource {

    public boolean initialize();

    public void uninitialize();

    public void update();

    public int getNumEXGChannels();

    public double[][] getFrameData();

    public List<double[]> getData(int maxSamples);

    public void startStreaming();

    public void stopStreaming();

    public int getSampleRate();

    public void setEXGChannelActive(int channelIndex, boolean active);

    public boolean isEXGChannelActive(int channelIndex);

    public int[] getEXGChannels();

    public int getTimestampChannel();

    public int getSampleIndexChannel();

    public int getTotalChannelCount();

    public boolean isStreaming();
};
abstract class DataSourcePlayback implements DataSource, FileBoard  {
    private String playbackFilePathExg;
    private ArrayList<double[]> rawDataExg;
    private int currentSampleExg;
    private int timeOfLastUpdateMSExg;
    private String underlyingClassName;
    private int numNewSamplesThisFrameExg;

    private boolean initialized = false;
    private boolean streaming = false;
    
    public Board underlyingBoard = null;
    private int sampleRateExg = -1;
    private int numChannelsExg = 0;  // use it instead getTotalChannelCount() method for old playback files

    DataSourcePlayback(String filePath) {
        playbackFilePathExg = filePath;
    }

    @Override
    public boolean initialize() {
        currentSampleExg = 0;
        String[] lines = loadStrings(playbackFilePathExg);
        
        if(!parseExgHeader(lines)) {
            return false;
        }
        if(!instantiateUnderlyingBoard()) {
            return false;
        }
        if(!parseExgData(lines)) {
            return false;
        }

        return true;
    }

    @Override
    public void uninitialize() {
        initialized = false;
    }

    protected boolean parseExgHeader(String[] lines) {
        for (String line : lines) {
            if (!line.startsWith("%")) {
                break; // reached end of header
            }

            //only needed for synthetic board. can delete if we get rid of synthetic board.
            if (line.startsWith("%Number of channels")) {
                int startIndex = line.indexOf('=') + 2;
                String nchanStr = line.substring(startIndex);
                int chanCount = Integer.parseInt(nchanStr);
                updateToNChan(chanCount); // sythetic board depends on this being set before it's initialized
            }

            // some boards have configurable sample rate, so read it from header
            if (line.startsWith("%Sample Rate")) {
                int startIndex = line.indexOf('=') + 2;
                int endIndex = line.indexOf("Hz") - 1;

                String hzString = line.substring(startIndex, endIndex);
                sampleRateExg = Integer.parseInt(hzString);
            }

            // used to figure out the underlying board type
            if (line.startsWith("%Board")) {
                int startIndex = line.indexOf('=') + 2;
                underlyingClassName = line.substring(startIndex);
            }
        }

        boolean success = sampleRateExg > 0 && underlyingClassName != "";
        if(!success) {
            outputError("Playback file does not contain the required header data.");
        }
        return success;
    }

    protected boolean instantiateUnderlyingBoard() {
        try {
            // get class from name
            Class<?> boardClass = Class.forName(underlyingClassName);
            // find default contructor (since this is processing, PApplet is required arg in all constructors)
            Constructor<?> constructor = boardClass.getConstructor(OpenBCI_GUI.class);
            underlyingBoard = (Board)constructor.newInstance(ourApplet);
        } catch (Exception e) {
            outputError("Cannot instantiate underlying board of class " + underlyingClassName);
            println(e.getMessage());
            e.printStackTrace();
            return false;
        }

        return underlyingBoard != null;
    }

    protected boolean parseExgData(String[] lines) {
        int dataStart;
        // set data start to first line of data (skip header)
        for (dataStart = 0; dataStart < lines.length; dataStart++) {
            String line = lines[dataStart];
            if (!line.startsWith("%")) {
                dataStart++; // skip column names
                break;
            }
        }

        int dataLength = lines.length - dataStart;
        rawDataExg = new ArrayList<double[]>(dataLength);
        
        for (int iData=0; iData<dataLength; iData++) {
            String line = lines[dataStart + iData];
            String[] valStrs = line.split(",");
            if (((valStrs.length - 1) != getTotalChannelCount()) && (numChannelsExg == 0)) {
                outputWarn("you are using old file for playback.");
            }
            numChannelsExg = valStrs.length - 1;  // -1 becaise of gui's timestamps

            double[] row = new double[numChannelsExg];
            for (int iCol = 0; iCol < numChannelsExg; iCol++) {
                row[iCol] = Double.parseDouble(valStrs[iCol]);
            }
            rawDataExg.add(row);
        }

        return true;
    }

    @Override
    public void update() {
        if (!streaming) {
            return; // do not update
        }

        float sampleRateMS = getSampleRate() / 1000.f;

        int timeElapsedMS = millis() - timeOfLastUpdateMSExg;
        numNewSamplesThisFrameExg = floor(timeElapsedMS * sampleRateMS);

        // account for the fact that each update will not coincide with a sample exactly. 
        // to keep the streaming rate accurate, we increment the time of last update
        // based on how many samples we incremented this frame.
        timeOfLastUpdateMSExg += numNewSamplesThisFrameExg / sampleRateMS;

        currentSampleExg += numNewSamplesThisFrameExg;
        
        if (endOfFileReached()) {
            topNav.stopButtonWasPressed();
        }

        // don't go beyond raw data array size
        currentSampleExg = min(currentSampleExg, getTotalSamples());
    }

    @Override
    public void startStreaming() {
        streaming = true;
        timeOfLastUpdateMSExg = millis();
    }

    @Override
    public void stopStreaming() {
        streaming = false;
    }

    @Override
    public boolean isStreaming() {
        return streaming;
    }

    @Override
    public int getSampleRate() {
        return sampleRateExg;
    }

    @Override
    public void setEXGChannelActive(int channelIndex, boolean active) {
        outputWarn("Deactivating channels is not possible for Playback board.");
    }

    @Override
    public boolean isEXGChannelActive(int channelIndex) {
        return true;
    }
    
    @Override
    public int[] getEXGChannels() {
        return underlyingBoard.getEXGChannels();
    }
    
    @Override
    public int getNumEXGChannels() {
        return getEXGChannels().length;
    }

    @Override
    public int getTimestampChannel() {
        return underlyingBoard.getTimestampChannel();
    }

    @Override
    public int getSampleIndexChannel() {
        return underlyingBoard.getSampleIndexChannel();
    }

    public int getTotalSamples() {
        return rawDataExg.size();
    }

    public float getTotalTimeSeconds() {
        return PApplet.parseFloat(getTotalSamples()) / PApplet.parseFloat(getSampleRate());
    }

    public int getCurrentSample() {
        return currentSampleExg;
    }

    public float getCurrentTimeSeconds() {
        return PApplet.parseFloat(getCurrentSample()) / PApplet.parseFloat(getSampleRate());
    }

    public void goToIndex(int index) {
        currentSampleExg = index;
    }

    @Override
    public int getTotalChannelCount() {
        if (numChannelsExg == 0)
            return underlyingBoard.getTotalChannelCount();
        return numChannelsExg;
    }

    @Override
    public double[][] getFrameData() {
        double[][] array = new double[numChannelsExg][numNewSamplesThisFrameExg];
        List<double[]> list = getData(numNewSamplesThisFrameExg);
        for (int i = 0; i < numNewSamplesThisFrameExg; i++) {
            for (int j = 0; j < numChannelsExg; j++) {
                array[j][i] = list.get(i)[j];
            }
        }
        return array;
    }

    @Override
    public List<double[]> getData(int maxSamples) {
        int firstSample = max(0, currentSampleExg - maxSamples);
        List<double[]> result = rawDataExg.subList(firstSample, currentSampleExg);

        // if needed, pad the beginning of the array with empty data
        if (maxSamples > currentSampleExg) {
            int sampleDiff = maxSamples - currentSampleExg;

            double[] emptyData = new double[numChannelsExg];
            ArrayList<double[]> newResult = new ArrayList(maxSamples);
            for (int i=0; i<sampleDiff; i++) {
                newResult.add(emptyData);
            }
            
            newResult.addAll(result);
            return newResult;
        }

        return result;
    }

    @Override
    public boolean endOfFileReached() {
        return currentSampleExg >= getTotalSamples();
    }

}

public DataSourcePlayback getDataSourcePlaybackClassFromFile(String path) {
    verbosePrint("Checking " + path + " for underlying board class.");
    String strCurrentLine;
    int lineCounter = 0;
    int maxLinesToCheck = 4;
    String infoToCheck = "%Board = ";
    String underlyingBoardClassName = "";
    BufferedReader reader = createBufferedReader(path);
    try {
        while (lineCounter < maxLinesToCheck) {
            strCurrentLine = reader.readLine();
            verbosePrint(strCurrentLine);
            if (strCurrentLine.startsWith(infoToCheck)) {
                String[] splitCurrentLine = split(strCurrentLine, "OpenBCI_GUI$");
                underlyingBoardClassName = splitCurrentLine[1];
            }
            lineCounter++;
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try {
            if (reader != null) {
                reader.close();
            }
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
    
    switch (underlyingBoardClassName) {
        case ("BoardCytonSerial"):
        case ("BoardCytonSerialDaisy"):
        case ("BoardCytonWifi"):
        case ("BoardCytonWifiDaisy"):
            return new DataSourcePlaybackCyton(path);
        case ("BoardGanglionBLE"):
        case ("BoardGanglionNative"):
        case ("BoardGanglionWifi"):
            return new DataSourcePlaybackGanglion(path);
        case ("BoardBrainFlowSynthetic"):
            return new DataSourcePlaybackSynthetic(path);
        default:
            return null;
    }
}
class DataSourcePlaybackCyton extends DataSourcePlayback implements AccelerometerCapableBoard, AnalogCapableBoard, DigitalCapableBoard, FileBoard  {
   
    DataSourcePlaybackCyton(String filePath) {
        super(filePath);
    }

    @Override
    public int getAccelSampleRate() {
        return getSampleRate();
    }

    @Override
    public int getAnalogSampleRate() {
        return getSampleRate();
    }

    @Override
    public int getDigitalSampleRate() {
        return getSampleRate();
    }

    @Override
    public boolean isAccelerometerActive() { 
        return underlyingBoard instanceof AccelerometerCapableBoard;
    }

    @Override
    public void setAccelerometerActive(boolean active) {
        // nothing
    }

    @Override
    public boolean canDeactivateAccelerometer() {
        return false;
    }

    @Override
    public int[] getAccelerometerChannels() {
        if (underlyingBoard instanceof AccelerometerCapableBoard) {
            return ((AccelerometerCapableBoard)underlyingBoard).getAccelerometerChannels();
        }

        return new int[0];
    }

    @Override
    public boolean isAnalogActive() {
        return underlyingBoard instanceof AnalogCapableBoard;
    }

    @Override
    public void setAnalogActive(boolean active) {
        // nothing
    }

    @Override
    public boolean canDeactivateAnalog() {
        return false;
    }

    @Override
    public int[] getAnalogChannels() {
        if (underlyingBoard instanceof AnalogCapableBoard) {
            return ((AnalogCapableBoard)underlyingBoard).getAnalogChannels();
        }

        return new int[0];
    }

    @Override
    public boolean isDigitalActive() {
        return underlyingBoard instanceof DigitalCapableBoard;
    }

    @Override
    public void setDigitalActive(boolean active) {
        // nothing
    }

    @Override
    public boolean canDeactivateDigital() {
        return false;
    }

    @Override
    public int[] getDigitalChannels() {
        if (underlyingBoard instanceof DigitalCapableBoard) {
            return ((DigitalCapableBoard)underlyingBoard).getDigitalChannels();
        }

        return new int[0];
    }

    @Override
    public List<double[]> getDataWithAnalog(int maxSamples) {
        return getData(maxSamples);
    }

    @Override
    public List<double[]> getDataWithDigital(int maxSamples) {
        return getData(maxSamples);
    }

    @Override
    public List<double[]> getDataWithAccel(int maxSamples) {
        return getData(maxSamples);
    }

}
class DataSourcePlaybackGanglion extends DataSourcePlayback implements AccelerometerCapableBoard, FileBoard  {
   
    DataSourcePlaybackGanglion(String filePath) {
        super(filePath);
    }

    @Override
    public int getAccelSampleRate() {
        return getSampleRate();
    }

    @Override
    public boolean isAccelerometerActive() { 
        return underlyingBoard instanceof AccelerometerCapableBoard;
    }

    @Override
    public void setAccelerometerActive(boolean active) {
        // nothing
    }

    @Override
    public boolean canDeactivateAccelerometer() {
        return false;
    }

    @Override
    public int[] getAccelerometerChannels() {
        if (underlyingBoard instanceof AccelerometerCapableBoard) {
            return ((AccelerometerCapableBoard)underlyingBoard).getAccelerometerChannels();
        }

        return new int[0];
    }

    @Override
    public List<double[]> getDataWithAccel(int maxSamples) {
        return getData(maxSamples);
    }

}
class DataSourcePlaybackSynthetic extends DataSourcePlayback implements AccelerometerCapableBoard, FileBoard  {
   
    DataSourcePlaybackSynthetic(String filePath) {
        super(filePath);
    }

    protected boolean instantiateUnderlyingBoard() {
        try {
            underlyingBoard = new BoardBrainFlowSynthetic(nchan);
        } catch (Exception e) {
            println(e.getMessage());
            e.printStackTrace();
            return false;
        }

        return underlyingBoard != null;
    }

    @Override
    public int getAccelSampleRate() {
        return getSampleRate();
    }

    @Override
    public boolean isAccelerometerActive() { 
        return underlyingBoard instanceof AccelerometerCapableBoard;
    }

    @Override
    public void setAccelerometerActive(boolean active) {
        // nothing
    }

    @Override
    public boolean canDeactivateAccelerometer() {
        return false;
    }

    @Override
    public int[] getAccelerometerChannels() {
        if (underlyingBoard instanceof AccelerometerCapableBoard) {
            return ((AccelerometerCapableBoard)underlyingBoard).getAccelerometerChannels();
        }

        return new int[0];
    }

    @Override
    public List<double[]> getDataWithAccel(int maxSamples) {
        return getData(maxSamples);
    }

}
class DataSourceSDCard implements DataSource, FileBoard, AccelerometerCapableBoard  {

    private String filePath;
    private int samplingRate;
    private ArrayList<double[]> data;
    private int[] exgChannels;
    private int totalChannels;
    private boolean streaming;
    private double startTime;
    private int counter;
    private int currentSample;
    private int numNewSamplesThisFrame;
    private int timeOfLastUpdateMS;
    private double accel_x;
    private double accel_y;
    private double accel_z;

    DataSourceSDCard(String filePath) {
        this.filePath = filePath;
        samplingRate = 0;
        data = new ArrayList<double[]>();
        streaming = false;
        exgChannels = null;
        counter = 0;
        startTime = 0.0f;
        timeOfLastUpdateMS = 0;
        totalChannels = 0;
        accel_x = 0.0f;
        accel_y = 0.0f;
        accel_z = 0.0f;
    }

    @Override
    public boolean initialize() {
        try {
        File file = new File(this.filePath);
        Scanner reader = new Scanner(file);
        startTime = millis() / 1000.0f;
        while (reader.hasNextLine()) {
            String line = reader.nextLine();
            String[] splitted = line.split(",");
            if (splitted.length < 8) {
                continue;
            }
            if (splitted.length < 15) {
                if (samplingRate == 0) {
                    samplingRate = 250;
                    exgChannels = new int[] {1,2,3,4,5,6,7,8};
                    totalChannels = 13;
                }
            }
            else {
                if (samplingRate == 0) {
                    samplingRate = 250;
                    exgChannels = new int[] {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
                    totalChannels = 21;
                }
            }
            try {
                parseRow(splitted, exgChannels.length);
            } catch (Exception e) {
                e.printStackTrace();
                continue;
            }
            counter++;
        }
        reader.close();
        println("Initialized, data len is " + data.size() + " Num EXG Channels is " + exgChannels.length);
        return true;
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return false;
        }
    }

    private void parseRow(String[] row, int numChannels) {
        double[] line = new double[totalChannels];
        if (row.length < numChannels - 1) {
            return;
        }
        for (int i = 0; i < numChannels + 1; i++) {
            double res = 0.0f;
            if (i == 0) {
                res = Integer.parseInt(row[i], 16);
            }
            else {
                res = parseInt24Hex(row[i]) * BoardCytonConstants.scale_fac_uVolts_per_count;
            }
            line[i] = res;
        }
        // new accel
        if (row.length >= numChannels + 4) {
            accel_x = parseInt16Hex(row[numChannels + 1]);
            accel_y = parseInt16Hex(row[numChannels + 2]);
            accel_z = parseInt16Hex(row[numChannels + 3]);
        }
        line[line.length - 4] = BoardCytonConstants.accelScale * accel_x;
        line[line.length - 3] = BoardCytonConstants.accelScale * accel_y;
        line[line.length - 2] = BoardCytonConstants.accelScale * accel_z;
        // add timestamp
        double delay = 1.0f / samplingRate;
        double timestamp = startTime + counter * delay;
        line[line.length - 1] = timestamp;
        data.add(line);
    }

    @Override
    public void uninitialize() {
        samplingRate = 0;
        data = new ArrayList<double[]>();
        streaming = false;
        exgChannels = null;
        counter = 0;
        startTime = 0.0f;
        timeOfLastUpdateMS = 0;
        totalChannels = 0;
        accel_x = 0.0f;
        accel_y = 0.0f;
        accel_z = 0.0f;
    }

    @Override
    public void update() {
        if (!streaming) {
            return; // do not update
        }

        float sampleRateMS = getSampleRate() / 1000.f;
        int timeElapsedMS = millis() - timeOfLastUpdateMS;
        numNewSamplesThisFrame = floor(timeElapsedMS * sampleRateMS);

        // account for the fact that each update will not coincide with a sample exactly. 
        // to keep the streaming rate accurate, we increment the time of last update
        // based on how many samples we incremented this frame.
        timeOfLastUpdateMS += numNewSamplesThisFrame / sampleRateMS;

        currentSample += numNewSamplesThisFrame;

        if (endOfFileReached()) {
            topNav.stopButtonWasPressed();
        }

        // don't go beyond raw data array size
        currentSample = min(currentSample, data.size() - 1);
    }

    @Override
    public void startStreaming() {
        streaming = true;
        timeOfLastUpdateMS = millis();
    }

    @Override
    public void stopStreaming() {
        streaming = false;
    }

    @Override
    public boolean isStreaming() {
        return streaming;
    }

    @Override
    public int getSampleRate() {
        return samplingRate;
    }

    @Override
    public int getAccelSampleRate() {
        return getSampleRate();
    }

    @Override
    public void setEXGChannelActive(int channelIndex, boolean active) {
        outputWarn("Deactivating channels is not possible for Playback board.");
    }

    @Override
    public boolean isEXGChannelActive(int channelIndex) {
        return true;
    }
    
    @Override
    public int[] getEXGChannels() {
        return exgChannels;
    }
    
    @Override
    public int getNumEXGChannels() {
        return getEXGChannels().length;
    }

    @Override
    public int getTimestampChannel() {
        return totalChannels - 1;
    }

    @Override
    public int getSampleIndexChannel() {
        return 0;
    }

    @Override
    public int getTotalChannelCount() {
        return totalChannels;
    }

    @Override
    public double[][] getFrameData() {
        double[][] array = new double[getTotalChannelCount()][numNewSamplesThisFrame];
        List<double[]> list = getData(numNewSamplesThisFrame);
        for (int i = 0; i < numNewSamplesThisFrame; i++) {
            for (int j = 0; j < getTotalChannelCount(); j++) {
                array[j][i] = list.get(i)[j];
            }
        }
        return array;
    }

    @Override
    public List<double[]> getData(int maxSamples) {
        int firstSample = max(0, currentSample - maxSamples);
        List<double[]> result = data.subList(firstSample, currentSample);

        // if needed, pad the beginning of the array with empty data
        if (maxSamples > currentSample) {
            int sampleDiff = maxSamples - currentSample;

            double[] emptyData = new double[getTotalChannelCount()];
            ArrayList<double[]> newResult = new ArrayList(maxSamples);
            for (int i=0; i<sampleDiff; i++) {
                newResult.add(emptyData);
            }
            
            newResult.addAll(result);
            return newResult;
        }

        return result;
    }

    @Override
    public int getTotalSamples() {
        return data.size();
    }

    @Override
    public float getTotalTimeSeconds() {
        return PApplet.parseFloat(getTotalSamples()) / PApplet.parseFloat(getSampleRate());
    }

    @Override
    public int getCurrentSample() {
        return currentSample;
    }

    @Override
    public float getCurrentTimeSeconds() {
        return PApplet.parseFloat(getCurrentSample()) / PApplet.parseFloat(getSampleRate());
    }

    @Override
    public void goToIndex(int index) {
        currentSample = index;
    }

    @Override
    public boolean isAccelerometerActive() { 
        return true;
    }

    @Override
    public void setAccelerometerActive(boolean active) {
        // nothing
    }

    @Override
    public boolean canDeactivateAccelerometer() {
        return false;
    }

    @Override
    public int[] getAccelerometerChannels() {
        return new int[]{totalChannels - 4, totalChannels - 3, totalChannels - 2};
    }

    @Override
    public List<double[]> getDataWithAccel(int maxSamples) {
        return getData(maxSamples);
    }

    @Override
    public boolean endOfFileReached() {
        return currentSample >= getTotalSamples();
    }

    private int parseInt24Hex(String hex) {
        if (hex.charAt(0) > '7') {  // if the number is negative
            hex = "FF" + hex;   // keep it negative
        } else {                  // if the number is positive
            hex = "00" + hex;   // keep it positive
        }

        return unhex(hex);
    }

    private int parseInt16Hex(String hex) {
        if (hex.charAt(0) > '7') {  // if the number is negative
            hex = "FFFF" + hex;   // keep it negative
        } else {                  // if the number is positive
            hex = "0000" + hex;   // keep it positive
        }

        return unhex(hex);
    }

}
public class DataWriterAuxODF extends DataWriterODF {
    protected String fileNamePrependString = "OpenBCI-RAW-Aux-";
    protected String headerFirstLineString = "%OpenBCI Raw Aux Data";

    //variation on constructor to have custom name
    DataWriterAuxODF(String _sessionName, String _fileName) {
        super(_sessionName, _fileName);
    }
    
    protected int getNumberOfChannels() {
        return ((AuxDataBoard)currentBoard).getNumAuxChannels();
    }

    protected int getSamplingRate() {
        return ((AuxDataBoard)currentBoard).getAuxSampleRate();
    }

    protected String getUnderlyingBoardClass() {
        return ((AuxDataBoard)currentBoard).getClass().getName();
    }

    protected String[] getChannelNames() {
        return ((AuxDataBoard)currentBoard).getAuxChannelNames();
    }

    protected int getTimestampChannel() {
        return ((AuxDataBoard)currentBoard).getAuxTimestampChannel();
    }

};

//write data to a text file in BDF+ format http://www.biosemi.com/faq/file_format.htm
public class DataWriterBDF {
    private PrintWriter writer;
    private OutputStream dstream;
    // private FileOutputStream fstream;
    // private BufferedOutputStream bstream;
    // private DataOutputStream dstream;

    // Each header component has a max allocated amount of ascii spaces
    // SPECS FOR BDF http://www.biosemi.com/faq/file_format.htm
    // ADDITIONAL SPECS FOR EDF+ http://www.edfplus.info/specs/edfplus.html#additionalspecs
    // A good resource for a comparison between BDF and EDF http://www.teuniz.net/edfbrowser/bdfplus%20format%20description.html
    final static int BDF_HEADER_SIZE_VERSION = 8; // Version of this data format Byte 1: "255" (non ascii) Bytes 2-8 : "BIOSEMI" (ASCII)
    final static int BDF_HEADER_SIZE_PATIENT_ID = 80; // Local patient identification (mind item 3 of the additional EDF+ specs)
    final static int BDF_HEADER_SIZE_RECORDING_ID = 80; // Local recording identification (mind item 4 of the additional EDF+ specs)
    final static int BDF_HEADER_SIZE_RECORDING_START_DATE = 8; // Start date of recording (dd.mm.yy) (mind item 2 of the additional EDF+ specs)
    final static int BDF_HEADER_SIZE_RECORDING_START_TIME = 8; // Start time of recordign (hh.mm.ss)
    final static int BDF_HEADER_SIZE_BYTES_IN_HEADER = 8; // Number of bytes in header record
    final static int BDF_HEADER_SIZE_RESERVED = 44; // Reserved
    final static int BDF_HEADER_SIZE_NUMBER_DATA_RECORDS = 8; // Number of data records (-1 if unknown, obey item 10 of the additional EDF+ specs)
    final static int BDF_HEADER_SIZE_DURATION_OF_DATA_RECORD = 8; // Duration of a data record, in seconds
    final static int BDF_HEADER_SIZE_NUMBER_SIGNALS = 4; // Number of signals (ns) in data record
    final static int BDF_HEADER_NS_SIZE_LABEL = 16; // ns * 16 ascii : ns * label (e.g. EEG Fpz-Cz or Body temp) (mind item 9 of the additional EDF+ specs)
    final static int BDF_HEADER_NS_SIZE_TRANSDUCER_TYPE = 80; // ns * 80 ascii : ns * transducer type (e.g. AgAgCl electrode)
    final static int BDF_HEADER_NS_SIZE_PHYSICAL_DIMENSION = 8; // ns * 8 ascii : ns * physical dimension (e.g. uV or degreeC)
    final static int BDF_HEADER_NS_SIZE_PHYSICAL_MINIMUM = 8; // ns * 8 ascii : ns * physical minimum (e.g. -500 or 34)
    final static int BDF_HEADER_NS_SIZE_PHYSICAL_MAXIMUM = 8; // ns * 8 ascii : ns * physical maximum (e.g. 500 or 40)
    final static int BDF_HEADER_NS_SIZE_DIGITAL_MINIMUM = 8; // ns * 8 ascii : ns * digital minimum (e.g. -2048)
    final static int BDF_HEADER_NS_SIZE_DIGITAL_MAXIMUM = 8; // ns * 8 ascii : ns * digital maximum (e.g. 2047)
    final static int BDF_HEADER_NS_SIZE_PREFILTERING = 80; // ns * 80 ascii : ns * prefiltering (e.g. HP:0.1Hz LP:75Hz)
    final static int BDF_HEADER_NS_SIZE_NR = 8; // ns * 8 ascii : ns * nr of samples in each data record
    final static int BDF_HEADER_NS_SIZE_RESERVED = 32; // ns * 32 ascii : ns * reserved

    // Ref: http://www.edfplus.info/specs/edfplus.html#header
    final static String BDF_HEADER_DATA_CONTINUOUS = "BDF+C";
    final static String BDF_HEADER_DATA_DISCONTINUOUS = "BDF+D";
    final static String BDF_HEADER_PHYSICAL_DIMENISION_UV = "uV";
    final static String BDF_HEADER_PHYSICAL_DIMENISION_G = "g";
    final static String BDF_HEADER_TRANSDUCER_AGAGCL = "AgAgCl electrode";
    final static String BDF_HEADER_TRANSDUCER_MEMS = "MEMS";
    final static String BDF_HEADER_ANNOTATIONS = "BDF Annotations ";

    final static int BDF_HEADER_BYTES_BLOCK = 256;

    DateFormat startDateFormat = new SimpleDateFormat("dd.MM.yy");
    DateFormat startTimeFormat = new SimpleDateFormat("HH.mm.ss");

    private char bdf_version_header = 0xFF;
    private char[] bdf_version = {'B', 'I', 'O', 'S', 'E', 'M', 'I'};

    private String bdf_patient_id_subfield_hospoital_code = "X"; // The code by which the patient is known in the hospital administration.
    private String bdf_patient_id_subfield_sex = "X"; // Sex (English, so F or M).
    private String bdf_patient_id_subfield_birthdate = "X"; // (e.g. 24-NOV-1992) Birthdate in dd-MM-yyyy format using the English 3-character abbreviations of the month in capitals. 02-AUG-1951 is OK, while 2-AUG-1951 is not.
    private String bdf_patient_id_subfield_name = "X"; // the patients name. No spaces! Use "_" where ever a space is

    private String bdf_recording_id_subfield_prefix = "X"; //"Startdate"; // The text 'Startdate'
    private String bdf_recording_id_subfield_startdate = "X"; // getDateString(startDateFormat); // The startdate itself in dd-MM-yyyy format using the English 3-character abbreviations of the month in capitals.
    private String bdf_recording_id_subfield_admin_code = "X"; // The hospital administration code of the investigation, i.e. EEG number or PSG number.
    private String bdf_recording_id_subfield_investigator = "X"; // A code specifying the responsible investigator or technician.
    private String bdf_recording_id_subfield_equipment = "X"; // A code specifying the used equipment.

    // Digital max and mins
    private String bdf_digital_minimum_ADC_24bit = "-8388608"; // -1 * 2^23
    private String bdf_digital_maximum_ADC_24bit = "8388607"; // 2^23 - 1
    private String bdf_digital_minimum_ADC_12bit = "-2048"; // -1 * 2^11
    private String bdf_digital_maximum_ADC_12bit = "2047"; // 2^11 - 1

    // Physcial max and mins
    private String bdf_physical_minimum_ADC_24bit = "-187500"; // 4.5 / 24 / (2^23) * 1000000 *  (2^23)
    private String bdf_physical_maximum_ADC_24bit = "187500"; // 4.5 / 24 / (2^23) * 1000000 * -1 * (2^23)
    private String bdf_physical_minimum_ADC_Accel = "-4";
    private String bdf_physical_maximum_ADC_Accel = "4";

    private String bdf_physical_minimum_ADC_24bit_ganglion = "-15686";
    private String bdf_physical_maximum_ADC_24bit_ganglion = "15686";

    public boolean continuous = true;
    public boolean write_accel = true;

    private int nbAnnotations = 1;
    private int nbAux = 3;
    private int nbChan = 8;
    private int sampleSize = 3; // Number of bytes in a sample

    private String labelsAnnotations[] = new String[nbAnnotations];
    private String transducerAnnotations[] = new String[nbAnnotations];
    private String physicalDimensionAnnotations[] = new String[nbAnnotations];
    private String physicalMinimumAnnotations[] = new String[nbAnnotations];
    private String physicalMaximumAnnotations[] = new String[nbAnnotations];
    private String digitalMinimumAnnotations[] = new String[nbAnnotations];
    private String digitalMaximumAnnotations[] = new String[nbAnnotations];
    private String prefilteringAnnotations[] = new String[nbAnnotations];
    private String nbSamplesPerDataRecordAnnotations[] = new String[nbAnnotations];
    private String reservedAnnotations[] = new String[nbAnnotations];

    private String labelsAux[] = new String[nbAux];
    private String transducerAux[] = new String[nbAux];
    private String physicalDimensionAux[] = new String[nbAux];
    private String physicalMinimumAux[] = new String[nbAux];
    private String physicalMaximumAux[] = new String[nbAux];
    private String digitalMinimumAux[] = new String[nbAux];
    private String digitalMaximumAux[] = new String[nbAux];
    private String prefilteringAux[] = new String[nbAux];
    private String nbSamplesPerDataRecordAux[] = new String[nbAux];
    private String reservedAux[] = new String[nbAux];

    private String labelsEEG[] = new String[nbChan];
    private String transducerEEG[] = new String[nbChan];
    private String physicalDimensionEEG[] = new String[nbChan];
    private String physicalMinimumEEG[] = new String[nbChan];
    private String physicalMaximumEEG[] = new String[nbChan];
    private String digitalMinimumEEG[] = new String[nbChan];
    private String digitalMaximumEEG[] = new String[nbChan];
    private String prefilteringEEG[] = new String[nbChan];
    private String nbSamplesPerDataRecordEEG[] = new String[nbChan];
    private String reservedEEG[] = new String[nbChan];

    private String tempWriterPrefix = directoryManager.getRecordingsPath()+"temp.txt";

    private int fs_Hz = 250;
    private int accel_Hz = 25;

    private int samplesInDataRecord = 0;
    private int dataRecordsWritten = 0;

    private Date startTime;
    private boolean startTimeCaptured = false;

    private int timeDataRecordStart = 0;

    private byte auxValBuf[][][];
    private byte auxValBuf_buffer[][][];
    private byte chanValBuf[][][];
    private byte chanValBuf_buffer[][][];

    public String fname = "";

    public int nbSamplesPerAnnontation = 20;

    private int totalByteCount = 0;

    /**
      * @description Creates an EDF writer! Name of output file based on current
      *  date and time.
      * @constructor
      */
    DataWriterBDF() {

        fname = getFileName();
        fs_Hz = currentBoard.getSampleRate();
        nbChan = currentBoard.getNumEXGChannels();

        init();
    }

    /**
      * @description Creates an EDF writer! The output file will contain the `_filename`.
      * @param `_fileName` {String} - Main component of the output file name.
      * @constructor
      */
    DataWriterBDF(String _fileName) {

        fname = getFileName(_fileName);
        fs_Hz = currentBoard.getSampleRate();
        nbChan = currentBoard.getNumEXGChannels();

        init();
    }
    
    /**
      * @description Used to initalize the writer.
      */
    private void init() {

        // Set the arrays needed for header
        setNbAnnotations(nbAnnotations);
        setNbAux(nbAux);
        setNbChan(nbChan);

        // Create the aux value buffer
        auxValBuf = new byte[nbAux][fs_Hz][sampleSize];
        auxValBuf_buffer = new byte[nbAux][fs_Hz][sampleSize];

        // Create the channel value buffer
        chanValBuf = new byte[nbChan][fs_Hz][sampleSize];
        chanValBuf_buffer = new byte[nbChan][fs_Hz][sampleSize];

        // Create the output stream for raw data
        dstream = createOutput(tempWriterPrefix);

        // Init the counter
        dataRecordsWritten = 0;
    }

    /**
      * @description Writes a raw data packet to the buffer. Also will flush the
      *  buffer if it is filled with one second worth of data. Will also capture
      *  the start time, or the first time a packet is recieved.
      * @param `data` double[][] - A data packet
      */
    public void writeRawData_dataPacket(double[][] data) {
        for (int i=0; i<data[0].length; i++) {

            if (!startTimeCaptured) {
                startTime = new Date();
                startTimeCaptured = true;
                timeDataRecordStart = millis();
            }

            writeChannelDataValues(data, i);
            if (currentBoard instanceof AccelerometerCapableBoard) {
                writeAuxDataValues(data, i);
            }
            samplesInDataRecord++;
            // writeValues(data.auxValues,scale_for_aux);
            if (samplesInDataRecord >= fs_Hz) {
                arrayCopy(chanValBuf,chanValBuf_buffer);
                if (currentBoard instanceof AccelerometerCapableBoard) {
                    arrayCopy(auxValBuf,auxValBuf_buffer);
                }

                samplesInDataRecord = 0;
                writeDataOut();
            }
        }
    }

    private void writeDataOut() {
        try {
            for (int i = 0; i < nbChan; i++) {
                for (int j = 0; j < fs_Hz; j++) {
                    for (int k = 0; k < 3; k++) {
                        dstream.write(chanValBuf_buffer[i][j][k]);
                    }
                }
            }
            if (eegDataSource == DATASOURCE_CYTON) {
                for (int i = 0; i < nbAux; i++) {
                    for (int j = 0; j < fs_Hz; j++) {
                        for (int k = 0; k < 3; k++) {
                            dstream.write(auxValBuf_buffer[i][j][k]);
                        }
                    }
                }
            }

            // Write the annotations
            dstream.write('+');
            String _t = Integer.toString((millis() - timeDataRecordStart) / 1000);
            int strLen = _t.length();
            for (int i = 0; i < strLen; i++) {
                dstream.write(_t.charAt(i));
            }
            dstream.write(20);
            dstream.write(20);
            int lenWritten = 1 + strLen + 1 + 1;
            // for (int i = lenWritten; i < fs_Hz * sampleSize; i++) {
            for (int i = lenWritten; i < nbSamplesPerAnnontation * sampleSize; i++) {
                dstream.write(0);
            }
            dataRecordsWritten++;

        } catch (Exception e) {
            println("writeRawData_dataPacket: Exception ");
            e.printStackTrace();
        }
    }

    public void closeFile() {

        println("Closed the temp data file. Now opening a new file.");
        try {
            dstream.close();
        } catch (Exception e) {
            println("closeFile: dstream close exception ");
            e.printStackTrace();
        }
        println("closeFile: Started...");

        OutputStream o = createOutput(fname);
        println("closeFile: Made file");

        // Create a new writer with the same file name
        // Write the header
        writeHeader(o);
        println("closeFile: Wrote header");

        writeData(o);
        println("closeFile: Data written. Closing new BDF+ file.");
        try {
            o.close();
            println("closeFile: wrote data");
            File tempFile = new File(tempWriterPrefix);
            if (Files.deleteIfExists(tempFile.toPath())) {
                println("closeFile: BDF+ temporary file deleted.");
                output("BDF+ file has been made.");
            } else {
                println("closeFile: error deleting temp file");
            }
        } catch (IOException e) {
            println("Error closing BDF OutputStream");
        }

    }

    public int getRecordsWritten() {
        return dataRecordsWritten;
    }

    /**
      * @description Resizes and resets the per aux channel arrays to size `n`
      * @param `n` {int} - The new size of arrays
      */
    public void setAnnotationsArraysToSize(int n) {
        labelsAnnotations = new String[n];
        transducerAnnotations = new String[n];
        physicalDimensionAnnotations = new String[n];
        physicalMinimumAnnotations = new String[n];
        physicalMaximumAnnotations = new String[n];
        digitalMinimumAnnotations = new String[n];
        digitalMaximumAnnotations = new String[n];
        prefilteringAnnotations = new String[n];
        nbSamplesPerDataRecordAnnotations = new String[n];
        reservedAnnotations = new String[n];
    }

    /**
      * @description Resizes and resets the per aux channel arrays to size `n`
      * @param `n` {int} - The new size of arrays
      */
    public void setAuxArraysToSize(int n) {
        labelsAux = new String[n];
        transducerAux = new String[n];
        physicalDimensionAux = new String[n];
        physicalMinimumAux = new String[n];
        physicalMaximumAux = new String[n];
        digitalMinimumAux = new String[n];
        digitalMaximumAux = new String[n];
        prefilteringAux = new String[n];
        nbSamplesPerDataRecordAux = new String[n];
        reservedAux = new String[n];
    }

    /**
      * @description Resizes and resets the per channel arrays to size `n`
      * @param `n` {int} - The new size of arrays
      */
    public void setEEGArraysToSize(int n) {
        labelsEEG = new String[n];
        transducerEEG = new String[n];
        physicalDimensionEEG = new String[n];
        physicalMinimumEEG = new String[n];
        physicalMaximumEEG = new String[n];
        digitalMinimumEEG = new String[n];
        digitalMaximumEEG = new String[n];
        prefilteringEEG = new String[n];
        nbSamplesPerDataRecordEEG = new String[n];
        reservedEEG = new String[n];
    }

    /**
      * @description Set an EEG 10-20 label for a given channel. (e.g. EEG Fpz-Cz)
      * @param `s` {String} - The string to store to the `labels` string array
      * @param `index` {int} - The position in the `labels` array to insert the
      *  string `str`. Must be smaller than `nbChan`.
      * @returns {boolean} - `true` if the label was added, `false` if not able to
      */
    public boolean setEEGLabelForIndex(String s, int index) {
        if (index < nbChan) {
            labelsEEG[index] = s;
            return true;
        } else {
            return false;
        }
    }

    /**
      * @description Set the number of annotation signals.
      * @param `n` {int} - The new number of channels
      */
    public void setNbAnnotations(int n) {
        if (n < 1) n = 1;

        // Set the main variable
        nbAnnotations = n;
        // Resize the arrays
        setAnnotationsArraysToSize(n);
        // Fill any arrays that can be filled
        setAnnotationsArraysToDefaults();
    }

    /**
      * @description Set the number of aux signals.
      * @param `n` {int} - The new number of aux channels
      */
    public void setNbAux(int n) {
        if (n < 1) n = 1;

        // Set the main variable
        nbAux = n;
        // Resize the arrays
        setAuxArraysToSize(n);
        // Fill any arrays that can be filled
        setAuxArraysToDefaults();
    }

    /**
      * @description Set the number of channels. Important to do. This will nuke
      *  the labels array if the size increases or decreases.
      * @param `n` {int} - The new number of channels
      */
    public void setNbChan(int n) {
        if (n < 1) n = 1;

        // Set the main variable
        nbChan = n;
        // Resize the arrays
        setEEGArraysToSize(n);
        // Fill any arrays that can be filled
        setEEGArraysToDefaults();
    }

    /**
      * @description Sets the patient's sex.
      * @param `s` {String} - The patients sex (e.g. M or F)
      * @returns {String} - The string that was set.
      */
    public String setPatientIdSex(String s) {
        return bdf_patient_id_subfield_sex = swapSpacesForUnderscores(s);
    }

    /**
      * @description Sets the patient's birthdate.
      * @param `s` {String} - The patients birth date (e.g. 24-NOV-1992)
      * @returns {String} - The string that was set.
      */
    public String setPatientIdBirthdate(String s) {
        return bdf_patient_id_subfield_birthdate = swapSpacesForUnderscores(s);
    }

    /**
      * @description Sets the patient's name. Note that spaces will be swapped for
      *  underscores.
      * @param `s` {String} - The patients name.
      * @returns {String} - The string that was set.
      */
    public String setPatientIdName(String s) {
        return bdf_patient_id_subfield_name = swapSpacesForUnderscores(s);
    }

    /**
      * @description Set any prefilerting for a given channel. (e.g. HP:0.1Hz LP:75Hz)
      * @param `s` {String} - The string to store to the `prefiltering` string array
      * @param `index` {int} - The position in the `prefiltering` array to insert the
      *  string `str`. Must be smaller than `nbChan`.
      * @returns {boolean} - `true` if the string was added, `false` if not able to
      */
    public boolean setEEGPrefilterForIndex(String s, int index) {
        if (index < nbChan) {
            prefilteringEEG[index] = s;
            return true;
        } else {
            return false;
        }
    }

    /**
      * @description Sets the recording admin code. Note that spaces will be
      *  swapped for underscores.
      * @param `s` {String} - The recording admin code.
      * @returns {String} - The string that was set.
      */
    public String setRecordingIdAdminCode(String s) {
        return bdf_recording_id_subfield_admin_code = swapSpacesForUnderscores(s);
    }

    /**
      * @description Sets the recording admin code. Note that spaces will be
      *  swapped for underscores. (e.g. AJ Keller)
      * @param `s` {String} - The recording id of the investigator.
      * @returns {String} - The string that was set. (e.g. AJ_Keller)
      */
    public String setRecordingIdInvestigator(String s) {
        return bdf_recording_id_subfield_investigator = swapSpacesForUnderscores(s);
    }

    /**
      * @description Sets the recording equipment code. Note that spaces will be
      *  swapped for underscores. (e.g. OpenBCI 32bit or OpenBCI Ganglion)
      * @param `s` {String} - The recording equipment id.
      * @returns {String} - The string that was set.
      */
    public String setRecordingIdEquipment(String s) {
        return bdf_recording_id_subfield_equipment = swapSpacesForUnderscores(s);
    }

    /**
      * @description Set a transducer type for a given channel. (e.g. AgAgCl electrode)
      * @param `s` {String} - The string to store to the `transducerEEG` string array
      * @param `index` {int} - The position in the `transducerEEG` array to insert the
      *  string `str`. Must be smaller than `nbChan`.
      * @returns {boolean} - `true` if the string was added, `false` if not able to
      */
    public boolean setTransducerForIndex(String s, int index) {
        if (index < nbChan) {
            transducerEEG[index] = s;
            return true;
        } else {
            return false;
        }
    }

    /**
      * @description Used to combine a `str` (string) into one big string a certain number of
      *  `times` with left justification padding of `size`.
      * @param `s` {String} - The string to be inserted
      * @param `size` {int} - The total allowable size for `str` to be inserted.
      *  If `str.length()` < `size` then `str` will essentially be right padded with
      *  spaces till the `output` is of length `size`.
      * @param `times` {int} - The number of times to repeat the `str` with `padding`
      * @returns {String} - The `str` right padded with spaces to beome `size` length
      *  and that repeated `times`.
      */
    private String combineStringIntoSizeTimes(String s, int size, int times) {
        String output = "";
        for (int i = 0; i < times; i++) {
            output += padStringRight(s, size);
        }
        return output;
    }

    /**
      * @description Calculate the number of bytes in the header. Entirerly based
      *  off the number of channels (`nbChan`)
      * @returns {int} - The number of bytes in the header is 256 + (256 * N) where
      *  N is the number of channels (signals)
      */
    private int getBytesInHeader() {
        return BDF_HEADER_BYTES_BLOCK + (BDF_HEADER_BYTES_BLOCK * getNbSignals()); // Add one for the annotations channel
    }

    /**
      * @description Used to get the continuity of the EDF file based on class public
      *  boolean variable `continuous`. If stop stream then start stream is pressed
      *  we must set the variable `continuous` to false.
      * @returns {String} - The string with NO spacing
      */
    private String getContinuity() {
        if (continuous) {
            return BDF_HEADER_DATA_CONTINUOUS;
        } else {
            return BDF_HEADER_DATA_DISCONTINUOUS;
        }
    }

    /**
      * @description Returns a string of the date based on the input DateFormat `d`
      * @param `d` {DateFormat} - The format you want the date/time in
      * @returns {String} - The current date/time formatted based on `d`
      */
    private String getDateString(DateFormat d) {
        // Get current date time with Date()
        return d.format(new Date());
    }

    /**
      * @description Returns a string of the date based on the input DateFormat `d`
      * @param `d` {DateFormat} - The format you want the date/time in
      * @returns {String} - The current date/time formatted based on `d`
      */
    private String getDateString(Date d, DateFormat df) {
        // Get current date time with Date()
        return df.format(d);
    }

    /**
      * @description Generate a file name for the EDF file that has the current date
      *  and time injected into it.
      * @returns {String} - A fully qualified name of an output file with the date
      *  and time.
      */
    private String getFileName() {
        //build up the file name
        String output = "";

        // If no file name is supplied then we generate one based off the current
        //  date and time of day.
        output += year() + "-";
        if (month() < 10) output += "0";
        output += month() + "-";
        if (day() < 10) output += "0";
        output += day();

        output += "_";
        if (hour() < 10) output += "0";
        output += hour() + "-";
        if (minute() < 10) output += "0";
        output += minute() + "-";
        if (second() < 10) output += "0";
        output += second();

        return getFileName(output);
    }

    /**
      * @description Generate a file name for the EDF file with `str` string embedded
      *  within.
      * @param `s` {String} - The string to inject
      * @returns {String} - A fully qualified name of an output file with `str`.
      */
    private String getFileName(String s) {
        String output = directoryManager.getRecordingsPath()+"OpenBCI-BDF-";
        output += s;
        output += ".bdf";
        return output;
    }

    /**
      * @description Get's the number of signal channels to write out. Have to
      *  keep in mind that the annotations channel counts.
      * @returns {int} - The number of signals in the header.
      */
    private int getNbSignals() {
        if (eegDataSource == DATASOURCE_CYTON) {
            return nbChan + nbAux + nbAnnotations;
        } else {
            return nbChan + nbAnnotations;
        }

    }

    /**
      * @description Takes an array of strings and joins split by `delimiter`
      * @param `stringArray` {String []} - An array of strings
      * @param `delimiter` {String} - The delimiter to split the strings with
      * @returns `String` - All the strings from `stringArray` separated by
      *  `delimiter`.
      * @reference http://www.edfplus.info/specs/edf.html
      */
    private String joinStringArray(String[] stringArray, String delimiter) {
        String output = "";

        // Number of elecments to add
        int numberOfElements = stringArray.length;

        // Each element will be written
        for (int i = 0; i < numberOfElements; i++) {
            // Add the element
            output += stringArray[i];
            // Add a delimiter between
            output += delimiter;
        }

        return output;
    }

    /**
      * @description Used to combine a `str` (string) with left justification padding of `size`.
      * @param `s` {String} - The string to be inserted
      * @param `size` {int} - The total allowable size for `str` to be inserted.
      *  If `str.length()` < `size` then `str` will essentially be right padded with
      *  spaces till the `output` is of length `size`.
      * @returns {String} - The `str` right padded with spaces to become `size` length.
      */
    private String padStringRight(String s, int size) {
        char[] output = new char[size];
        int len = 0;
        if (s != null) len = s.length();
        for (int i = 0; i < size; i++) {
            if (i < len) {
                output[i] = s.charAt(i);
            } else {
                output[i] = ' ';
            }
        }
        return new String(output, 0, size);
    }

    /**
      * @description Sets the header per channel arrays to their default values
      */
    private void setAuxArraysToDefaults() {
        labelsAux[0] = "Accel X";
        labelsAux[1] = "Accel Y";
        labelsAux[2] = "Accel Z";
        setStringArray(transducerAux, BDF_HEADER_TRANSDUCER_MEMS, nbAux);
        setStringArray(physicalDimensionAux, BDF_HEADER_PHYSICAL_DIMENISION_G, nbAux);
        setStringArray(digitalMinimumAux, bdf_digital_minimum_ADC_12bit, nbAux);
        setStringArray(digitalMaximumAux, bdf_digital_maximum_ADC_12bit, nbAux);
        setStringArray(physicalMinimumAux, bdf_physical_minimum_ADC_Accel, nbAux);
        setStringArray(physicalMaximumAux, bdf_physical_maximum_ADC_Accel, nbAux);
        setStringArray(prefilteringAux, " ", nbAux);
        setStringArray(nbSamplesPerDataRecordAux, Integer.toString(fs_Hz), nbAux);
        setStringArray(reservedAux, " ", nbAux);
    }

    /**
      * @description Sets the header per channel arrays to their default values
      */
    private void setAnnotationsArraysToDefaults() {
        setStringArray(labelsAnnotations, BDF_HEADER_ANNOTATIONS, 1); // Leave space for the annotations space
        setStringArray(transducerAnnotations, " ", 1);
        setStringArray(physicalDimensionAnnotations, " ", 1);
        setStringArray(digitalMinimumAnnotations, bdf_digital_minimum_ADC_24bit, 1);
        setStringArray(digitalMaximumAnnotations, bdf_digital_maximum_ADC_24bit, 1);
        if (eegDataSource == DATASOURCE_GANGLION) {
            setStringArray(physicalMinimumAnnotations, bdf_physical_minimum_ADC_24bit_ganglion, 1);
            setStringArray(physicalMaximumAnnotations, bdf_physical_maximum_ADC_24bit_ganglion, 1);
        } else {
            setStringArray(physicalMinimumAnnotations, bdf_physical_minimum_ADC_24bit, 1);
            setStringArray(physicalMaximumAnnotations, bdf_physical_maximum_ADC_24bit, 1);
        }
        setStringArray(prefilteringAnnotations, " ", 1);
        nbSamplesPerDataRecordAnnotations[0] = Integer.toString(nbSamplesPerAnnontation);
        setStringArray(reservedAnnotations, " ", 1);
    }

    /**
      * @description Sets the header per channel arrays to their default values
      */
    private void setEEGArraysToDefaults() {
        for (int i = 1; i <= nbChan; i++) {
            labelsEEG[i - 1] = "EEG " + i;
        }
        setStringArray(transducerEEG, BDF_HEADER_TRANSDUCER_AGAGCL, nbChan);
        setStringArray(physicalDimensionEEG, BDF_HEADER_PHYSICAL_DIMENISION_UV, nbChan);
        setStringArray(digitalMinimumEEG, bdf_digital_minimum_ADC_24bit, nbChan);
        setStringArray(digitalMaximumEEG, bdf_digital_maximum_ADC_24bit, nbChan);
        setStringArray(physicalMinimumEEG, bdf_physical_minimum_ADC_24bit, nbChan);
        setStringArray(physicalMaximumEEG, bdf_physical_maximum_ADC_24bit, nbChan);
        setStringArray(prefilteringEEG, " ", nbChan);
        setStringArray(nbSamplesPerDataRecordEEG, Integer.toString(fs_Hz), nbChan);
        setStringArray(reservedEEG, " ", nbChan);
    }

    /**
      * @description Convience function to fill a string array with the same values
      * @param `arr` {String []} - A string array to fill
      * @param `val` {Stirng} - The string to be inserted into `arr`
      */
    private void setStringArray(String[] arr, String val, int len) {
        for (int i = 0; i < len; i++) {
            arr[i] = val;
        }
    }

    /**
      * @description Converts a byte from Big Endian to Little Endian
      * @param `val` {byte} - The byte to swap
      * @returns {byte} - The swapped byte.
      */
    private byte swapByte(byte val) {
        int mask = 0x80;
        int res = 0;
        // println("swapByte: starting to swap val: 0b" + binary(val,8));
        for (int i = 0; i < 8; i++) {
            // println("\nswapByte: i: " + i);
            // Isolate the MSB with a big mask i.e. 10000000, 01000000, etc...
            int temp = (val & mask);
            // println("swapByte: temp:    0b" + binary(temp,8));
            // Save this temp value
            res = (res >> 1) | (temp << i);
            // println("swapByte: res:     0b" + binary(res,8));
            // Move mask one place
            mask = mask >> 1;
            // println("swapByte: mask: 0b" + binary(mask,32));
        }
        // println("swapByte: ending swapped val: 0b" + binary(res,8));
        return (byte)res;
    }

    /**
      * @description Swaps any spaces for underscores because EDF+ calls for it
      * @param `s` {String} - A string containing spaces
      * @returns {String} - A string with underscores instead of spaces.
      * @reference http://www.edfplus.info/specs/edfplus.html#additionalspecs
      */
    private String swapSpacesForUnderscores(String s) {
        int len = s.length();
        char[] output = new char[len];
        // Loop through the String
        for (int i = 0; i < len; i++) {
            if (s.charAt(i) == ' ') {
                output[i] = '_';
            } else {
                output[i] = s.charAt(i);
            }
        }
        return new String(output, 0, len);
    }

    /**
      * @description Moves a packet worth of data into channel buffer. Reverses byte order.
      *  Ref [1]: http://www.biosemi.com/faq/file_format.htm
      */
    private void writeChannelDataValues(double[][] allData, int sampleIndex) {
        int[] exgchannels = currentBoard.getEXGChannels();

        for (int i = 0; i < nbChan; i++) {
            // [daniellasry 5/3/2020] This function has been updated to work
            // with brainflow and the new data flow.
            // the following lines convert the new input type (double)
            // to the input type this function originally expected
            // (24 bit integer in a byte array of length 3)
            int value = (int)allData[exgchannels[i]][sampleIndex];
            ByteBuffer bb = ByteBuffer.allocate(4); 
            bb.putInt(value); 
            byte[] bytes = bb.array();
            // skip the first byte which should be full of zeroes anyway (24 bit int)
            byte[] values = {bytes[1], bytes[2], bytes[3]};

            // Make the values little endian
            chanValBuf[i][samplesInDataRecord][0] = values[2];
            chanValBuf[i][samplesInDataRecord][1] = values[1];
            chanValBuf[i][samplesInDataRecord][2] = values[0];
        }
    }

    /**
      * @description Moves a packet worth of data into aux buffer, also converts
      *  from Big Endian to Little Indian as per the specs of BDF+.
      *  Ref [1]: http://www.biosemi.com/faq/file_format.htm
      */
    private void writeAuxDataValues(double[][] allData, int sampleIndex) {
        int[] accelChannels = ((AccelerometerCapableBoard)currentBoard).getAccelerometerChannels();

        for (int i = 0; i < nbAux; i++) {
            if (write_accel) {
                // [daniellasry 5/3/2020] This function has been updated to work
                // with brainflow and the new data flow.
                // the following lines convert the new input type (double)
                // to the input type this function originally expected
                // (16 bit integer in a byte array of length 2)
                int accelInt = (int)allData[accelChannels[i]][sampleIndex];
                ByteBuffer bb = ByteBuffer.allocate(4); 
                bb.putInt(accelInt);
                byte[] bytes = bb.array();
                // skip the first 2 bytes which should be full of zeroes anyway (16 bit int)
                byte[] values = {bytes[2], bytes[3]};

                // grab the lower part of
                boolean zeroPack = true;
                // shift right
                int t = (int)values[0] & 0x0F;
                values[0] = (byte)((int)values[0] >> 4);
                if (values[0] >= 8) {
                    zeroPack = false;
                }
                values[1] = (byte)((int)values[1] >> 4);
                values[1] = (byte)((int)values[1] | t);
                if (!zeroPack) {
                    values[0] = (byte)((int)values[0] | 0xF0);
                }
                // make msb -> lsb
                auxValBuf[i][samplesInDataRecord][0] = values[1];
                auxValBuf[i][samplesInDataRecord][1] = values[0];
                // pad byte
                if (zeroPack) {
                    auxValBuf[i][samplesInDataRecord][2] = (byte)0x00;
                } else {
                    auxValBuf[i][samplesInDataRecord][2] = (byte)0xFF;
                }
            } else {
                // TODO: Implement once GUI gets support for non standard packets
            }
        }
    }

    /**
      * @description Writes data from a temp file over to the final file with the
      *  header in place already.
      *  TODO: Stop keeping it in memory.
      * @param `o` {OutputStream} - An output stream to write to.
      */
    private void writeData(OutputStream o) {

        InputStream input = createInput(tempWriterPrefix);

        try {
            println("writeData: started...");
            int data = input.read();
            int byteCount = 0;
            while (data != -1) {
                o.write(data);
                data = input.read();
                byteCount++;
                if (isVerbose) {
                    if (byteCount % (3*fs_Hz*nbChan) == 0) verbosePrint("+ 1 Second Of Data Written to BDF");
                }
            }
            verbosePrint("writeData: finished: wrote " + byteCount + " bytes");
            totalByteCount += byteCount;
            verbosePrint("Estimated file size == " + totalByteCount);
            totalByteCount = 0;
        }
        catch (IOException e) {
            print("writeData: ");
            e.printStackTrace();
        }
        finally {
            try {
                input.close();
            }
            catch (IOException e) {
                print("writeData: ");
                e.printStackTrace();
            }
        }
    }

    /**
      * @description Writes a fully qualified BDF+ header
      */
    private void writeHeader(OutputStream o) {
        // writer.write(0xFF); // Write the first byte of the header here
        try {
            // println("writeHeader: starting...");

            o.write(0xFF);
            writeString(padStringRight(new String(bdf_version),BDF_HEADER_SIZE_VERSION - 1), o); // Do one less then supposed to because of the first byte already written.
            String[] temp1  = {bdf_patient_id_subfield_hospoital_code,bdf_patient_id_subfield_sex,bdf_patient_id_subfield_birthdate,bdf_patient_id_subfield_name};
            writeString(padStringRight(joinStringArray(temp1, " "), BDF_HEADER_SIZE_PATIENT_ID), o);
            String[] temp2 = {bdf_recording_id_subfield_prefix,bdf_recording_id_subfield_startdate,bdf_recording_id_subfield_admin_code,bdf_recording_id_subfield_investigator,bdf_recording_id_subfield_equipment};
            writeString(padStringRight(joinStringArray(temp2, " "), BDF_HEADER_SIZE_RECORDING_ID), o);
            writeString(getDateString(startTime, startDateFormat), o);
            writeString(getDateString(startTime, startTimeFormat), o);
            writeString(padStringRight(Integer.toString(getBytesInHeader()),BDF_HEADER_SIZE_BYTES_IN_HEADER), o);
            verbosePrint("writeHeader: Bytes in header == " + getBytesInHeader());
            totalByteCount += getBytesInHeader();
            writeString(padStringRight("24BIT",BDF_HEADER_SIZE_RESERVED), o);//getContinuity(),BDF_HEADER_SIZE_RESERVED), o);
            writeString(padStringRight(Integer.toString(dataRecordsWritten),BDF_HEADER_SIZE_NUMBER_DATA_RECORDS), o);
            println("writeHeader: Writing " + dataRecordsWritten + " Seconds of Data to BDF");
            writeString(padStringRight("1",BDF_HEADER_SIZE_DURATION_OF_DATA_RECORD), o);
            writeString(padStringRight(Integer.toString(getNbSignals()),BDF_HEADER_SIZE_NUMBER_SIGNALS), o);

            writeStringArrayWithPaddingTimes(labelsEEG, BDF_HEADER_NS_SIZE_LABEL, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(labelsAux, BDF_HEADER_NS_SIZE_LABEL, o);
            writeStringArrayWithPaddingTimes(labelsAnnotations, BDF_HEADER_NS_SIZE_LABEL, o);

            writeStringArrayWithPaddingTimes(transducerEEG, BDF_HEADER_NS_SIZE_TRANSDUCER_TYPE, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(transducerAux, BDF_HEADER_NS_SIZE_TRANSDUCER_TYPE, o);
            writeStringArrayWithPaddingTimes(transducerAnnotations, BDF_HEADER_NS_SIZE_TRANSDUCER_TYPE, o);

            writeStringArrayWithPaddingTimes(physicalDimensionEEG, BDF_HEADER_NS_SIZE_PHYSICAL_DIMENSION, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(physicalDimensionAux, BDF_HEADER_NS_SIZE_PHYSICAL_DIMENSION, o);
            writeStringArrayWithPaddingTimes(physicalDimensionAnnotations, BDF_HEADER_NS_SIZE_PHYSICAL_DIMENSION, o);

            writeStringArrayWithPaddingTimes(physicalMinimumEEG, BDF_HEADER_NS_SIZE_PHYSICAL_MINIMUM, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(physicalMinimumAux, BDF_HEADER_NS_SIZE_PHYSICAL_MINIMUM, o);
            writeStringArrayWithPaddingTimes(physicalMinimumAnnotations, BDF_HEADER_NS_SIZE_PHYSICAL_MINIMUM, o);

            writeStringArrayWithPaddingTimes(physicalMaximumEEG, BDF_HEADER_NS_SIZE_PHYSICAL_MAXIMUM, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(physicalMaximumAux, BDF_HEADER_NS_SIZE_PHYSICAL_MAXIMUM, o);
            writeStringArrayWithPaddingTimes(physicalMaximumAnnotations, BDF_HEADER_NS_SIZE_PHYSICAL_MAXIMUM, o);

            writeStringArrayWithPaddingTimes(digitalMinimumEEG, BDF_HEADER_NS_SIZE_DIGITAL_MINIMUM, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(digitalMinimumAux, BDF_HEADER_NS_SIZE_DIGITAL_MINIMUM, o);
            writeStringArrayWithPaddingTimes(digitalMinimumAnnotations, BDF_HEADER_NS_SIZE_DIGITAL_MINIMUM, o);

            writeStringArrayWithPaddingTimes(digitalMaximumEEG, BDF_HEADER_NS_SIZE_DIGITAL_MAXIMUM, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(digitalMaximumAux, BDF_HEADER_NS_SIZE_DIGITAL_MAXIMUM, o);
            writeStringArrayWithPaddingTimes(digitalMaximumAnnotations, BDF_HEADER_NS_SIZE_DIGITAL_MAXIMUM, o);

            writeStringArrayWithPaddingTimes(prefilteringEEG, BDF_HEADER_NS_SIZE_PREFILTERING, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(prefilteringAux, BDF_HEADER_NS_SIZE_PREFILTERING, o);
            writeStringArrayWithPaddingTimes(prefilteringAnnotations, BDF_HEADER_NS_SIZE_PREFILTERING, o);

            writeStringArrayWithPaddingTimes(nbSamplesPerDataRecordEEG, BDF_HEADER_NS_SIZE_NR, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(nbSamplesPerDataRecordAux, BDF_HEADER_NS_SIZE_NR, o);
            writeStringArrayWithPaddingTimes(nbSamplesPerDataRecordAnnotations, BDF_HEADER_NS_SIZE_NR, o);

            writeStringArrayWithPaddingTimes(reservedEEG, BDF_HEADER_NS_SIZE_RESERVED, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(reservedAux, BDF_HEADER_NS_SIZE_RESERVED, o);
            writeStringArrayWithPaddingTimes(reservedAnnotations, BDF_HEADER_NS_SIZE_RESERVED, o);

            // println("writeHeader: done...");

        } catch(Exception e) {
            println("writeHeader: Exception " + e);
        }
    }

    /**
      * @description Write out an array of strings with `padding` on each element.
      *  Each element is padded right.
      * @param `arr` {String []} - An array of strings to write out
      * @param `padding` {int} - The amount of padding for each `arr` element.
      * @param `o` {OutputStream} - The output stream to write to.
      */
    private void writeStringArrayWithPaddingTimes(String[] arr, int padding, OutputStream o) {
        int len = arr.length;
        for (int i = 0; i < len; i++) {
            writeString(padStringRight(arr[i], padding), o);
        }
    }

    /**
      * @description Writes a string to an OutputStream s
      * @param `s` {String} - The string to write.
      * @param `o` {OutputStream} - The output stream to write to.
      */
    private void writeString(String s, OutputStream o) {
        int len = s.length();
        try {
            for (int i = 0; i < len; i++) {
                o.write((int)s.charAt(i));
            }
        } catch (Exception e) {
            println("writeString: exception: " + e);
        }
    }

};
public enum DataWriterBFEnum implements IndexingInterface
{
    DEFAULT (0, "Default"),
    CUSTOM (1, "Custom"),
    NONE (2, "None");

    private int index;
    private String label;

    DataWriterBFEnum(int _index, String _label) {
        this.index = _index;
        this.label = _label;
    }

    @Override
    public String getString() {
        return label;
    }

    @Override
    public int getIndex() {
        return index;
    }

    public boolean getIsDefaultLocation() {
        return label.equals("Default");
    }

    public boolean getIsCustomLocation() {
        return label.equals("Custom");
    }

    public boolean getIsTurnedOff() {
        return label.equals("None");
    }
}

public class DataWriterBF {
    private String folderPath = "";
    private String folderName = "";
    private StringBuilder fileName = null;
    private final String brainflowWriteOption = ":w";
    private int fileNumber = 0;

    //variation on constructor to have custom name
    DataWriterBF() {
        
    }

    public void setBrainFlowStreamerFolderName(String _folderName, String _folderPath) {
        //settings.setSessionPath(directoryManager.getRecordingsPath() + "OpenBCISession_" + _sessionName + File.separator);
        folderName = _folderName;
        folderPath = _folderPath;

        if (folderName == null || folderPath == null) {
            println("Error setting BrainFlow Streamer file output path. Try selecting the custom path again.");
            fileName = null;
            return;
        }

        generateBrainFlowStreamerFileName();

        File directory = new File(fileName.toString());
        if (!directory.exists()){
            directory.mkdirs();
            // If you require it to make the entire directory path including parents,
            // use directory.mkdirs(); here instead.
        }
    }
    
    private void generateBrainFlowStreamerFileName() {
        fileName = new StringBuilder("file://");
        fileName.append(folderPath);
        fileName.append(File.separator);
        fileName.append("BrainFlow-RAW_");
        fileName.append(folderName);
        fileName.append("_");
        fileName.append(fileNumber);
        fileName.append(".csv");
        fileName.append(brainflowWriteOption);
    }

    public void incrementBrainFlowStreamerFileNumber() {
        fileNumber++;
        generateBrainFlowStreamerFileName();
    }

    public void resetBrainFlowStreamer() {
        fileNumber = 0;
        folderName = "";
        folderPath = "";
        fileName = null;
    }

    public String getBrainFlowStreamerRecordingFileName() {
        return fileName == null ? null : fileName.toString();
    }
}

//Called when user selects a folder from controlPanel dialog box
public void bfSelectedFolder(File selection) {

    if (selection == null) {
        outputError("BrainFlow File Streamer: Window was closed or the user hit cancel. Please select a new file location or choose Default.");
        dataLogger.setBfWriterFolder(null, null);
        return;
    }

    File directory = new File(selection.getAbsolutePath());
    if (!directory.exists()){
        directory.mkdirs();
        // If you require it to make the entire directory path including parents,
        // use directory.mkdirs(); here instead.
    }


    println("DataLogging: bfSelectedFolder: User selected " + selection.getAbsolutePath());

    dataLogger.setBfWriterFolder(selection.getName(), selection.getAbsolutePath());
}
public class DataWriterODF {
    private PrintWriter output;
    private String fname;
    private int rowsWritten;
    private DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
    protected String fileNamePrependString = "OpenBCI-RAW-";
    protected String headerFirstLineString = "%OpenBCI Raw EXG Data";

    //variation on constructor to have custom name
    DataWriterODF(String _sessionName, String _fileName) {
        settings.setSessionPath(directoryManager.getRecordingsPath() + "OpenBCISession_" + _sessionName + File.separator);
        fname = settings.getSessionPath();
        fname += fileNamePrependString;
        fname += _fileName;
        fname += ".txt";
        output = createWriter(fname);        //open the file
        writeHeader();    //add the header
        rowsWritten = 0;    //init the counter
    }

    public void writeHeader() {
        output.println(headerFirstLineString);
        output.println("%Number of channels = " + getNumberOfChannels());
        output.println("%Sample Rate = " + getSamplingRate() + " Hz");
        output.println("%Board = " + getUnderlyingBoardClass());

        String[] colNames = getChannelNames();
        
        for (int i=0; i<colNames.length; i++) {
            output.print(colNames[i]);
            output.print(", ");
        }
        output.print("Timestamp (Formatted)");
        output.println();
        output.flush();
    }

    public void append(double[][] data) {
        //get current date time with Date()
        for (int iSample=0; iSample<data[0].length; iSample++) {
            for (int iChan=0; iChan<data.length; iChan++) {
                output.print(data[iChan][iSample]);
                output.print(", ");
            }

            int timestampChan = getTimestampChannel();
            // *1000 to convert from seconds to milliserconds
            long timestampMS = (long)(data[timestampChan][iSample] * 1000.0f);

            output.print(dateFormat.format(new Date(timestampMS)));
            output.println();
            
            rowsWritten++;
        }
    }

    public void closeFile() {
        output.close();
    }

    public int getRowsWritten() {
        return rowsWritten;
    }

    protected int getNumberOfChannels() {
        return nchan;
    }

    protected int getSamplingRate() {
        return ((Board)currentBoard).getSampleRate();
    }

    protected String getUnderlyingBoardClass() {
        return ((Board)currentBoard).getClass().getName();
    }

    protected String[] getChannelNames() {
        return ((Board)currentBoard).getChannelNames();
    }

    protected int getTimestampChannel() {
        return ((Board)currentBoard).getTimestampChannel();
    }
    
};

//////////////////////////////////////
//
// This file contains classes that are helpful for debugging, as well as the HelpWidget,
// which is used to give feedback to the GUI user in the small text window at the bottom of the GUI
//
// Created: Conor Russomanno, June 2016
// Based on code: Chip Audette, Oct 2013 - Dec 2014
//
//
/////////////////////////////////////



//------------------------------------------------------------------------
//                       Global Variables & Instances
//------------------------------------------------------------------------

//set true if you want more verbosity in console.. verbosePrint("print_this_thing") is used to output feedback when isVerbose = true
boolean isVerbose = false;

//Help Widget initiation
HelpWidget helpWidget;

//use signPost(String identifier) to print 'identifier' text and time since last signPost() for debugging latency/timing issues
boolean printSignPosts = true;
float millisOfLastSignPost = 0.0f;
float millisSinceLastSignPost = 0.0f;

static enum OutputLevel {
    DEFAULT,
    INFO,
    SUCCESS,
    WARN,
    ERROR
}

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

public void verbosePrint(String _string) {
    if (isVerbose) {
        println(_string);
    }
}

//this class is used to create the help widget that provides system feedback in response to interactivity
//it is intended to serve as a pseudo-console, allowing us to print useful information to the interface as opposed to an IDE console
class HelpWidget {

    public float x, y, w, h;
    int padding;

    //current text shown in help widget, based on most recent command
    String currentOutput = "Learn how to use this application and more at docs.openbci.com";
    OutputLevel curOutputLevel = OutputLevel.INFO;
    private int colorFadeCounter;
    private int colorFadeTimeMillis = 1000;
    private boolean outputWasTriggered = false;

    HelpWidget(float _xPos, float _yPos, float _width, float _height) {
        x = _xPos;
        y = _yPos;
        w = _width;
        h = _height;
        padding = 5;
    }

    public void update() {
    }

    public void draw() {

        pushStyle();

        if(colorScheme == COLOR_SCHEME_DEFAULT){
            // draw background of widget
            stroke(OPENBCI_DARKBLUE);
            fill(255);
            rect(-1, height-h, width+2, h);
            noStroke();

            //draw bg of text field of widget
            strokeWeight(1);
            stroke(color(0, 5, 11));
            fill(color(0, 5, 11));
            rect(x + padding, height-h + padding, width - padding*2, h - padding *2);

            textFont(p4);
            textSize(14);
            fill(255);
            textAlign(LEFT, TOP);
            text(currentOutput, padding*2, height - h + padding);
        } else if (colorScheme == COLOR_SCHEME_ALTERNATIVE_A){
            // draw background of widget
            stroke(OPENBCI_DARKBLUE);
            fill(OPENBCI_BLUE);
            rect(-1, height-h, width+2, h);
            noStroke();

            //draw bg of text field of widget
            strokeWeight(1);
            int saturationFadeValue = 0;
            if (outputWasTriggered) {
                int timeDelta = millis() - colorFadeCounter;
                saturationFadeValue = (int)map(timeDelta, 0, colorFadeTimeMillis, 100, 0);
                if (timeDelta > colorFadeTimeMillis) {
                    outputWasTriggered = false;
                }
            }
            //Colors in this method are calculated using Hue, Saturation, Brightness
            colorMode(HSB, 360, 100, 100);
            int c = getBackgroundColor(saturationFadeValue);
            stroke(c);
            fill(c);
            rect(x + padding, height-h + padding, width - padding*2, h - padding *2);

            // Revert color mode back to standard RGB here
            colorMode(RGB, 255, 255, 255);
            textFont(p4);
            textSize(14);
            fill(getTextColor());
            textAlign(LEFT, TOP);
            text(currentOutput, padding*2, height - h + padding);
        }

        popStyle();
    }

    private int getTextColor() {
        /*
        switch (curOutputLevel) {
            case INFO:
                return #00529B;
            case SUCCESS:
                return #4F8A10;
            case WARN:
                return #9F6000;
            case ERROR:
                return #D8000C;
            case DEFAULT:
            default:
                return color(0, 5, 11); 
        }
        */
        return OPENBCI_DARKBLUE;
    }

    private int getBackgroundColor(int fadeVal) {  
        int sat = 0;
        int maxSat = 75;
        switch (curOutputLevel) {
            case INFO:
                //base color - #BDE5F8;
                sat = 25;
                sat = (int)map(fadeVal, 0, 100, sat, maxSat);
                return color(199, sat, 97);
            case SUCCESS:
                //base color -  #DFF2BF;
                maxSat = 25;
                sat = 0;
                sat = (int)map(fadeVal, 0, 100, sat, maxSat);
                return color(106, sat, 95);
            case WARN:
                //base color -  #FEEFB3;
                sat = 30;
                sat = (int)map(fadeVal, 0, 100, sat, maxSat);
                return color(48, sat, 100);
            case ERROR:
                //base color -  #FFD2D2;
                sat = 18;
                sat = (int)map(fadeVal, 0, 100, sat, maxSat);
                return color(0, sat, 100);
            case DEFAULT:
            default:
                colorMode(RGB, 255, 255, 255);
                return WHITE;
        }
    }

    public void output(String _output, OutputLevel level) {
        curOutputLevel = level;
        currentOutput = _output;

        String outputWithPrefix = "[" + level.name() + "]: " + _output;
        println(outputWithPrefix); // add this output to the console log
        outputWasTriggered = true;
        colorFadeCounter = millis();
    }
};

public void output(String _output) {
    output(_output, OutputLevel.DEFAULT);
}

public void output(String _output, OutputLevel level) {
    helpWidget.output(_output, level);
}

public void outputError(String _output) {
    output(_output, OutputLevel.ERROR);
}

public void outputInfo(String _output) {
    output(_output, OutputLevel.INFO);
}

public void outputSuccess(String _output) {
    output(_output, OutputLevel.SUCCESS);
}

public void outputWarn(String _output) {
    output(_output, OutputLevel.WARN);
}

// created 2/10/16 by Conor Russomanno to dissect the aspects of the GUI that are slowing it down
// here I will create methods used to identify where there are inefficiencies in the code
// note to self: make sure to check the frameRate() in setup... switched from 16 to 30... working much faster now... still a useful method below.
// --------------------------------------------------------------  START -------------------------------------------------------------------------------

//method for printing out an ["indentifier"][millisSinceLastSignPost] for debugging purposes... allows us to look at what is taking too long.
public void signPost(String identifier) {
    if (printSignPosts) {
        millisSinceLastSignPost = millis() - millisOfLastSignPost;
        println("SIGN POST: [" + identifier + "][" + millisSinceLastSignPost + "]");
        millisOfLastSignPost = millis();
    }
}
// ---------------------------------------------------------------- FINISH -----------------------------------------------------------------------------

interface DigitalCapableBoard {

    public boolean isDigitalActive();

    public void setDigitalActive(boolean active);

    public boolean canDeactivateDigital();

    public int[] getDigitalChannels();

    public List<double[]> getDataWithDigital(int maxSamples);
    
    public int getDigitalSampleRate();
};
class DirectoryManager {

    private final String guiDataPath = System.getProperty("user.home")+File.separator+"Documents"+File.separator+"OpenBCI_GUI"+File.separator;
    private final String recordingsPath = guiDataPath+"Recordings"+File.separator;
    private final String settingsPath = guiDataPath+"Settings"+File.separator;
    private final String consoleDataPath = guiDataPath+"Console_Data"+File.separator;
    private final DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss");

    DirectoryManager() {

    }

    public String getFileNameDateTime() {
        return dateFormat.format(new Date());
    }
    
    public String getGuiDataPath() {
        return guiDataPath;
    }

    public String getRecordingsPath() {
        return recordingsPath;
    }

    public String getSettingsPath() {
        return settingsPath;
    }

    public String getConsoleDataPath() {
        return consoleDataPath;
    }

    public void init() {
        // Create GUI data folder in Users' Documents and copy sample data if it doesn't already exist
        String directoryName = guiDataPath + File.separator + "Sample_Data" + File.separator;
        String guiv4fileName = directoryName + "OpenBCI-sampleData-2-meditation.txt";
        String guiv5fileName = directoryName + "OpenBCI_GUI-v5-meditation.txt";
        File directory = new File(directoryName);
        File guiv4_fileToCheck = new File(guiv4fileName);
        File guiv5_fileToCheck = new File(guiv5fileName);

        if (guiv4_fileToCheck.exists()) {
            //Delete old gui v4 files in Documents folder
            try {
                for (File subFile : directory.listFiles()) {
                    subFile.delete();
                }
                println("OpenBCI_GUI::Setup: Successfully deleted old GUI v4 sample data files!");
            } catch (SecurityException e) {
                println("OpenBCI_GUI::Setup: Error trying to delete old GUI Sample Data in Documents folder.");
            }
        }
        
        if (!guiv5_fileToCheck.exists()) {
            copySampleDataFiles(directory, directoryName);
        } else {
            println("OpenBCI_GUI::Setup: GUI v5 Sample Data exists in Documents folder.");
        }

        makeRecordingsFolder();
    }

    private void copySampleDataFiles(File directory, String directoryName) {
        println("OpenBCI_GUI::Setup: Copying sample data to Documents/OpenBCI_GUI/Sample_Data");
        // Make the entire directory path including parents
        directory.mkdirs();
        try {
            File[] filesFound = new File(dataPath("EEG_Sample_Data")).listFiles();
            //If this pathname does not denote a directory, then listFiles() returns null.
            for (File file : filesFound) {
                if (file.isFile()) {
                    Files.copy(file.toPath(),
                        (new File(directoryName + file.getName())).toPath(),
                        StandardCopyOption.REPLACE_EXISTING);
                }
            }
        } catch (IOException e) {
            println("OpenBCI_GUI::Setup: Error trying to copy Sample Data to Documents directory.");
        }
    }

    private void makeRecordingsFolder() {
        //Create \Documents\OpenBCI_GUI\Recordings\ if it doesn't exist
        String recordingDirString = guiDataPath + File.separator + "Recordings";
        File recDirectory = new File(recordingDirString);
        if (recDirectory.mkdir()) {
            println("OpenBCI_GUI::Setup: Created \\Documents\\OpenBCI_GUI\\Recordings\\");
        }
    }
    
};
class EmgSettings {
    
    public EmgSettingsValues values;

    private int channelCount;

    private boolean settingsWereLoaded = false;

    EmgSettings() {
        channelCount = currentBoard.getNumEXGChannels();
        values = new EmgSettingsValues();
    }

    public boolean loadSettingsValues(String filename) {
        try {
            File file = new File(filename);
            StringBuilder fileContents = new StringBuilder((int)file.length());        
            Scanner scanner = new Scanner(file);
            while(scanner.hasNextLine()) {
                fileContents.append(scanner.nextLine() + System.lineSeparator());
            }
            Gson gson = new Gson();
            EmgSettingsValues tempValues = gson.fromJson(fileContents.toString(), EmgSettingsValues.class);
            if (tempValues.window.length != channelCount) {
                outputError("Emg Settings: Loaded EMG Settings file has different number of channels than the current board.");
                return false;
            }
            //Explicitely copy values over to avoid reference issues
            //(e.g. values = tempValues "nukes" the old values object)
            values.window = tempValues.window;
            values.uvLimit = tempValues.uvLimit;
            values.creepIncreasing = tempValues.creepIncreasing;
            values.creepDecreasing = tempValues.creepDecreasing;
            values.minimumDeltaUV = tempValues.minimumDeltaUV;
            values.lowerThresholdMinimum = tempValues.lowerThresholdMinimum;
            return true;
        } catch (IOException e) {
            e.printStackTrace();    
            File f = new File(filename);
            if (f.exists()) {
                if (f.delete()) {
                    outputError("Emg Settings: Could not load EMG settings from disk. Deleting this file...");
                } else {
                    outputError("Emg Settings: Error deleting old/broken EMG settings file! Please make sure the GUI has proper read/write permissions.");
                }
            }
            return false;
        }
    }

    public String getJson() {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        return gson.toJson(values);
    }

    public boolean saveToFile(String filename) {
        String json = getJson();
        try {
            FileWriter writer = new FileWriter(filename);
            writer.write(json);
            writer.close();
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    public void revertAllChannelsToDefaultValues() {
        values = new EmgSettingsValues();
        settingsWereLoaded = true;
    }

    //Called in UI to control number of channels. This is set from the board when this class is instantiated.
    public int getChannelCount() {
        return channelCount;
    }

    //Avoid error with popup being in another thread.
    public void storeSettings() {
        StringBuilder settingsFilename = new StringBuilder(directoryManager.getSettingsPath());
        settingsFilename.append("EmgSettings");
        settingsFilename.append("_");
        settingsFilename.append(getChannelCount());
        settingsFilename.append("Channels.json");
        String filename = settingsFilename.toString();
        File fileToSave = new File(filename);
        selectOutput("Save EMG settings to file", "storeEmgSettings", fileToSave);
    }

    //Avoid error with popup being in another thread.
    public void loadSettings() {
        StringBuilder settingsFilename = new StringBuilder(directoryManager.getSettingsPath());
        settingsFilename.append("EmgSettings");
        settingsFilename.append("_");
        settingsFilename.append(getChannelCount());
        settingsFilename.append("Channels.json");
        String filename = settingsFilename.toString();
        File fileToLoad = new File(filename);
        selectInput("Select EMG settings file to load", "loadEmgSettings", fileToLoad);
    }

    public boolean getSettingsWereLoaded() {
        return settingsWereLoaded;
    }

    public void setSettingsWereLoaded(boolean settingsWereLoaded) {
        this.settingsWereLoaded = settingsWereLoaded;
    }
}

//Used by button in the EMG UI. Must be global and public. Called in above loadSettings method.
public void loadEmgSettings(File selection) {
    if (selection == null) {
        output("EMG Settings file not selected.");
    } else {
        if (dataProcessing.emgSettings.loadSettingsValues(selection.getAbsolutePath())) {
            outputSuccess("EMG Settings Loaded!");
            dataProcessing.emgSettings.setSettingsWereLoaded(true);
        }
    }
}

//Used by button in the EMG UI. Must be global and public. Called in above storeSettings method.
public void storeEmgSettings(File selection) {
    if (selection == null) {
        output("EMG Settings file not selected.");
    } else {
        if (dataProcessing.emgSettings.saveToFile(selection.getAbsolutePath())) {
            outputSuccess("EMG Settings Saved!");
        } else {
            outputError("Failed to save EMG Settings.");
        }
    }
}
interface EmgSettingsEnum {
    public int getIndex();
    public String getString();
}

public enum EmgWindow implements EmgSettingsEnum
{
    ONE_HUNDREDTH_SECOND (0, "0.01 s", .01f),
    ONE_TENTH_SECOND (1, "0.1 s", .1f),
    FIFTEEN_HUNDREDTHS_SECOND (2, "0.15 s", .15f),
    QUARTER_SECOND (3, "0.25 s", .25f),
    HALF_SECOND (4, "0.5 s", .5f),
    THREE_QUARTERS_SECOND (5, "0.75 s", .75f),
    ONE_SECOND (6, "1.0 s", 1f),
    TWO_SECONDS (7, "2.0 s", 2f);

    private int index;
    private String name;
    private float value;
 
    EmgWindow(int index, String name, float value) {
        this.index = index;
        this.name = name;
        this.value = value;
    }

    public int getIndex() {
        return index;
    }
    
    public String getString() {
        return name;
    }

    public float getValue() {
        return value;
    }
}

public enum EmgUVLimit implements EmgSettingsEnum
{
    FIFTY_UV (0, "50 uV", 50),
    ONE_HUNDRED_UV (1, "100 uV", 100),
    TWO_HUNDRED_UV (2, "200 uV", 200),
    FOUR_HUNDRED_UV (3, "400 uV", 400);

    private int index;
    private String name;
    private int value;
 
    EmgUVLimit(int index, String name, int value) {
        this.index = index;
        this.name = name;
        this.value = value;
    }

    public int getIndex() {
        return index;
    }
    
    public String getString() {
        return name;
    }

    public int getValue() {
        return value;
    }
}

public enum EmgCreepIncreasing implements EmgSettingsEnum
{
    POINT_9 (0, "0.9", .9f),
    POINT_95 (1, "0.95", .95f),
    POINT_98 (2, "0.98", .98f),
    POINT_99 (3, "0.99", .99f),
    POINT_999 (4, "0.999", .999f),
    POINT_9999 (5, "0.9999", .9999f),
    POINT_99999 (6, "0.99999", .99999f);
    
    private int index;
    private String name;
    private float value;
 
    EmgCreepIncreasing(int index, String name, float value) {
        this.index = index;
        this.name = name;
        this.value = value;
    }

    public int getIndex() {
        return index;
    }
    
    public String getString() {
        return name;
    }

    public float getValue() {
        return value;
    }
}

public enum EmgCreepDecreasing implements EmgSettingsEnum
{
    POINT_9 (0, "0.9", .9f),
    POINT_95 (1, "0.95", .95f),
    POINT_98 (2, "0.98", .98f),
    POINT_99 (3, "0.99", .99f),
    POINT_999 (4, "0.999", .999f),
    POINT_9999 (5, "0.9999", .9999f),
    POINT_99999 (6, "0.99999", .99999f);
    
    private int index;
    private String name;
    private float value;
 
    EmgCreepDecreasing(int index, String name, float value) {
        this.index = index;
        this.name = name;
        this.value = value;
    }

    public int getIndex() {
        return index;
    }
    
    public String getString() {
        return name;
    }

    public float getValue() {
        return value;
    }
}

public enum EmgMinimumDeltaUV implements EmgSettingsEnum
{
    TWO_UV (0, "2 uV", 2),
    FOUR_UV (1, "4 uV", 4),
    SIX_UV (2, "6 uV", 6),
    EIGHT_UV (3, "8 uV", 8),
    TEN_UV (4, "10 uV", 10),
    TWENTY_UV (5, "20 uV", 20),
    FORTY_UV (6, "40 uV", 40),
    EIGHTY_UV (7, "80 uV", 80);

    private int index;
    private String name;
    private int value;
 
    EmgMinimumDeltaUV(int index, String name, int value) {
        this.index = index;
        this.name = name;
        this.value = value;
    }

    public int getIndex() {
        return index;
    }
    
    public String getString() {
        return name;
    }

    public int getValue() {
        return value;
    }
}

public enum EmgLowerThresholdMinimum implements EmgSettingsEnum
{
    ZERO_UV (0, "0 uV", 0),
    TWO_UV (1, "2 uV", 2),
    FOUR_UV (2, "4 uV", 4),
    SIX_UV (3, "6 uV", 6),
    EIGHT_UV (4, "8 uV", 8),
    TEN_UV (5, "10 uV", 10),
    FIFTEEN_UV (6, "15 uV", 15),
    TWENTY_UV (7, "20 uV", 20),
    THIRTY_UV (8, "30 uV", 30),
    FORTY_UV (9, "40 uV", 40);

    private int index;
    private String name;
    private int value;
 
    EmgLowerThresholdMinimum(int index, String name, int value) {
        this.index = index;
        this.name = name;
        this.value = value;
    }

    public int getIndex() {
        return index;
    }
    
    public String getString() {
        return name;
    }

    public int getValue() {
        return value;
    }
}
////////////////////////////////////////////////////////////
//                 EmgSettingsUI.pde                      //
//          Display the Emg Settings UI as a popup        //
//            Note: This window is never resized.         //
//                                                        //
////////////////////////////////////////////////////////////

public boolean emgSettingsPopupIsOpen = false;

class EmgSettingsUI extends PApplet implements Runnable {

    PApplet ourApplet;
    private final String HEADER_MESSAGE = "EMG Settings";

    private ControlP5 emgCp5;
    private int x, y, w, h;
    private final int HEADER_HEIGHT = 55;
    private final int FOOTER_PADDING = 90;
    private final int PADDING_3 = 3;
    private final int PADDING_12 = 12;
    private final int NUM_CONTROL_BUTTONS = 3;
    private final int ROW_HEIGHT = 40;
    private final int DROPDOWN_HEIGHT = 18; 
    private final int NUM_COLUMNS = 7;
    private final int DROPDOWN_SPACER = 5;
    private int dropdownWidth;
    private boolean isFixedHeight;
    private int fixedHeight;
    private int[] dropdownYPositions;
    private final int NUM_FOOTER_OBJECTS = 3;
    private final int FOOTER_OBJECT_WIDTH = 45;
    private final int FOOTER_OBJECT_HEIGHT = 26;
    private int footerObjY;
    private int[] footerObjX = new int[NUM_FOOTER_OBJECTS];

    private final int HEADER_COLOR = OPENBCI_BLUE;
    private final int BACKGROUND_COLOR = GREY_235;
    private final int LABEL_COLOR = WHITE;

    private final int defaultWidth = 600;
    private final int defaultHeight = 600;

    public EmgSettingsValues emgSettingsValues;

    private TextBox channelColumnLabel;
    private TextBox windowLabel;
    private TextBox uvLimitLabel;
    private TextBox creepIncLabel;
    private TextBox creepDecLabel;
    private TextBox minDeltaUvLabel;
    private TextBox lowLimitLabel;

    private ScrollableList[] windowLists;
    private ScrollableList[] uvLimitLists;
    private ScrollableList[] creepIncLists;
    private ScrollableList[] creepDecLists;
    private ScrollableList[] minDeltaUvLists;
    private ScrollableList[] lowLimitLists;

    private int channelCount;

    private String[] channelLabels;

    private Button saveButton;
    private Button loadButton;
    private Button defaultButton;

    @Override
    public void run() {
        PApplet.runSketch(new String[] {HEADER_MESSAGE}, this);
    }

    public EmgSettingsUI() {
        super();
        emgSettingsPopupIsOpen = true;

        Thread t = new Thread(this);
        t.start();

        emgSettingsValues = dataProcessing.emgSettings.values;

        channelCount = currentBoard.getNumEXGChannels();

        x = 0;
        y = 0;
        w = defaultWidth;
        h = HEADER_HEIGHT + (channelCount * ROW_HEIGHT) + FOOTER_PADDING;
    }

    @Override
    public void settings() {
        size(defaultWidth, h);
    }

    @Override
    public void setup() {

        ourApplet = this;

        surface.setTitle(HEADER_MESSAGE);
        surface.setAlwaysOnTop(false);
        surface.setResizable(false);

        Frame frame = ( (PSurfaceAWT.SmoothCanvas) ((PSurfaceAWT)surface).getNative()).getFrame();
        frame.toFront();
        frame.requestFocus();

        //Instantiate local cp5 for this box. This allows extra control of drawing cp5 elements specifically inside this class.
        emgCp5 = new ControlP5(ourApplet);
        emgCp5.setGraphics(ourApplet, 0,0);
        emgCp5.setAutoDraw(false);

        createAllUIObjects();
    }

    @Override
    public void draw() {
        clear();
        scene();

        // Draw header
        pushStyle();
        noStroke();
        fill(HEADER_COLOR);
        rect(0, 0, width, HEADER_HEIGHT);
        popStyle();

        emgSettingsValues = dataProcessing.emgSettings.values;

        checkIfSessionWasClosed();
        checkIfSettingsWereLoaded();

        //Draw column labels
        channelColumnLabel.draw();
        windowLabel.draw();
        uvLimitLabel.draw();
        creepIncLabel.draw();
        creepDecLabel.draw();
        minDeltaUvLabel.draw();
        lowLimitLabel.draw();

        drawChannelLabels();

        //Draw cp5 objects on top of everything
        try {
            emgCp5.draw();
        } catch (ConcurrentModificationException e) {
            e.printStackTrace();
            outputError("EMG Settings UI: Unable to draw cp5 objects.");
        }
    }

    private void scene() {
        // Draw background
        background(BACKGROUND_COLOR);
    }

    @Override
    public void exit() {
        dispose();
        emgSettingsPopupIsOpen = false;
    }

    private void checkIfSessionWasClosed() {
        if (systemMode == SYSTEMMODE_PREINIT) {
            noLoop();
            Frame frame = ( (PSurfaceAWT.SmoothCanvas) ((PSurfaceAWT)surface).getNative()).getFrame();
            frame.dispose();
            exit();
        }
    }

    private void checkIfSettingsWereLoaded() {
        if (dataProcessing.emgSettings.getSettingsWereLoaded()) {
            try {
                updateCp5Objects();
            } catch (Exception e) {
                e.printStackTrace();
                outputError("EMG Settings UI: Unable to apply settings. Please save EMG Settings to a new file.");
            }
            dataProcessing.emgSettings.setSettingsWereLoaded(false);
        }
    }

    private void drawChannelLabels() {
        int colWidth = (w / NUM_COLUMNS);
        int colOffset = colWidth / 2;
        
        pushStyle();

        fill(OPENBCI_DARKBLUE);
        textFont(p5, 12);
        textLeading(12);
        textAlign(CENTER, CENTER);

        for (int i = 0; i < channelCount; i++) {
            String channelLabel = channelCount > channelLabels.length ? "Channel " + Integer.toString(i + 1) : channelLabels[i];
            text(channelLabel, x + colOffset, dropdownYPositions[i] + (DROPDOWN_HEIGHT / 2) - 2);
        }

        popStyle();
    }

    private void resizeDropdowns() {
        dropdownWidth = PApplet.parseInt((w - (DROPDOWN_SPACER * (NUM_COLUMNS + 1))) / NUM_COLUMNS);
        final int MAX_HEIGHT_ITEMS = 6;

        for (int i = 0; i < channelCount; i++) {
            int dropdownX = x + DROPDOWN_SPACER * 2 + dropdownWidth;
            dropdownYPositions[i] = HEADER_HEIGHT + PApplet.parseInt(y + ((ROW_HEIGHT) * i) + (((ROW_HEIGHT) - DROPDOWN_HEIGHT) / 2));
            final int buttonXIncrement = DROPDOWN_SPACER + dropdownWidth;

            windowLists[i].setPosition(dropdownX, dropdownYPositions[i]);
            windowLists[i].setSize(dropdownWidth, MAX_HEIGHT_ITEMS * DROPDOWN_HEIGHT);
            
            dropdownX += buttonXIncrement;
            uvLimitLists[i].setPosition(dropdownX, dropdownYPositions[i]);
            uvLimitLists[i].setSize(dropdownWidth, (uvLimitLists[i].getItems().size()+1) * DROPDOWN_HEIGHT);

            dropdownX += buttonXIncrement;
            creepIncLists[i].setPosition(dropdownX, dropdownYPositions[i]);
            creepIncLists[i].setSize(dropdownWidth, MAX_HEIGHT_ITEMS * DROPDOWN_HEIGHT);

            dropdownX += buttonXIncrement;
            creepDecLists[i].setPosition(dropdownX, dropdownYPositions[i]);
            creepDecLists[i].setSize(dropdownWidth, MAX_HEIGHT_ITEMS * DROPDOWN_HEIGHT);

            dropdownX += buttonXIncrement;
            minDeltaUvLists[i].setPosition(dropdownX, dropdownYPositions[i]);
            minDeltaUvLists[i].setSize(dropdownWidth, MAX_HEIGHT_ITEMS * DROPDOWN_HEIGHT);

            dropdownX += buttonXIncrement;
            lowLimitLists[i].setPosition(dropdownX, dropdownYPositions[i]);
            lowLimitLists[i].setSize(dropdownWidth, MAX_HEIGHT_ITEMS * DROPDOWN_HEIGHT);
        }
    }

    private void createAllUIObjects() {
        final int HALF_FOOTER_HEIGHT = (FOOTER_PADDING + (DROPDOWN_SPACER * 2)) / 2;
        footerObjY = y + h - HALF_FOOTER_HEIGHT - (FOOTER_OBJECT_HEIGHT / 2);
        int middle = x + w / 2;
        int halfObjWidth = FOOTER_OBJECT_WIDTH / 2;
        footerObjX[0] = middle - halfObjWidth - PADDING_12 - FOOTER_OBJECT_WIDTH;
        footerObjX[1] = middle - halfObjWidth;
        footerObjX[2] = middle + halfObjWidth + PADDING_12;
        createEmgSettingsSaveButton("saveEmgSettingsButton", "Save", footerObjX[0], footerObjY, FOOTER_OBJECT_WIDTH, FOOTER_OBJECT_HEIGHT);
        createEmgSettingsLoadButton("loadEmgSettingsButton", "Load", footerObjX[1], footerObjY, FOOTER_OBJECT_WIDTH, FOOTER_OBJECT_HEIGHT);
        createEmgSettingsDefaultButton("defaultEmgSettingsButton", "Reset", footerObjX[2], footerObjY, FOOTER_OBJECT_WIDTH, FOOTER_OBJECT_HEIGHT);

        channelLabels = new String[channelCount];
        for (int i = 0; i < channelCount; i++) {
            channelLabels[i] = "Channel " + (i+1);
        }

        //Create column labels
        int labelBG = color(255,255,255,0);
        int labelTxt = WHITE;
        int colWidth = (w / NUM_COLUMNS);
        int colOffset = colWidth / 2;
        int labelY = y + HEADER_HEIGHT / 2;
        channelColumnLabel = new TextBox("Channel", x + colOffset, labelY, labelTxt, labelBG, 14, h4, CENTER, CENTER);
        windowLabel = new TextBox("Window", x + colOffset + colWidth, labelY, labelTxt, labelBG, 14, h4, CENTER, CENTER);
        uvLimitLabel = new TextBox("uV Limit", x + colOffset + colWidth*2, labelY, labelTxt, labelBG, 14, h4, CENTER, CENTER);
        creepIncLabel = new TextBox("Creep +", x + colOffset + colWidth*3, labelY, labelTxt, labelBG, 14, h4, CENTER, CENTER);
        creepDecLabel = new TextBox("Creep -", x + colOffset + colWidth*4, labelY, labelTxt, labelBG, 14, h4, CENTER, CENTER);
        minDeltaUvLabel = new TextBox("Min \u0394uV", x + colOffset + colWidth*5, labelY, labelTxt, labelBG, 14, h4, CENTER, CENTER);
        lowLimitLabel = new TextBox("Low Limit", x + colOffset + colWidth*6, labelY, labelTxt, labelBG, 14, h4, CENTER, CENTER);

        createAllDropdowns();
    }

    private void createAllDropdowns() {
        //the size and space of these buttons are dependendant on the size of the screen and full ChannelController
        verbosePrint("EmgChannelSettingsUI: Creating EMG channel setting UI objects...");

        windowLists = new ScrollableList[channelCount];
        uvLimitLists = new ScrollableList[channelCount];
        creepIncLists = new ScrollableList[channelCount];
        creepDecLists = new ScrollableList[channelCount];
        minDeltaUvLists = new ScrollableList[channelCount];
        lowLimitLists = new ScrollableList[channelCount];

        dropdownYPositions = new int[channelCount];

        //Init dropdowns in reverse so that chan 1 draws on top of chan 2, etc.
        for (int i = channelCount - 1; i >= 0; i--) {
            int exgChannel = i;
            windowLists[i] = createDropdown(exgChannel, "smooth_ch_"+(i+1), emgSettingsValues.window[exgChannel].values(), emgSettingsValues.window[exgChannel]);
            uvLimitLists[i] = createDropdown(exgChannel, "uvLimit_ch_"+(i+1), emgSettingsValues.uvLimit[exgChannel].values(), emgSettingsValues.uvLimit[exgChannel]);
            creepIncLists[i] = createDropdown(exgChannel, "creep_inc_ch_"+(i+1), emgSettingsValues.creepIncreasing[exgChannel].values(), emgSettingsValues.creepIncreasing[exgChannel]);   
            creepDecLists[i] = createDropdown(exgChannel, "creep_dec_ch_"+(i+1), emgSettingsValues.creepDecreasing[exgChannel].values(), emgSettingsValues.creepDecreasing[exgChannel]);   
            minDeltaUvLists[i] = createDropdown(exgChannel, "minDeltaUv_ch_"+(i+1), emgSettingsValues.minimumDeltaUV[exgChannel].values(), emgSettingsValues.minimumDeltaUV[exgChannel]);       
            lowLimitLists[i] = createDropdown(exgChannel, "lowLimit_ch_"+(i+1), emgSettingsValues.lowerThresholdMinimum[exgChannel].values(), emgSettingsValues.lowerThresholdMinimum[exgChannel]);
        }

        resizeDropdowns();
    }

    private ScrollableList createDropdown(int chanNum, String name, EmgSettingsEnum[] enumValues, EmgSettingsEnum e) {
        dropdownWidth = PApplet.parseInt((w - (DROPDOWN_SPACER * (NUM_COLUMNS + 1))) / NUM_COLUMNS);
        int _backgroundColor = 0xFFFFFFFF;
        ScrollableList list = emgCp5.addScrollableList(name)
            .setOpen(false)
            .setColorBackground(_backgroundColor) // text field bg color
            .setColorValueLabel(OPENBCI_DARKBLUE)       // text color
            .setColorCaptionLabel(OPENBCI_DARKBLUE)
            .setColorForeground(color(125))    // border color when not selected
            .setColorActive(BUTTON_PRESSED)       // border color when selected
            .setOutlineColor(OBJECT_BORDER_GREY)
            .setSize(dropdownWidth, DROPDOWN_HEIGHT)//temporary size
            .setBarHeight(DROPDOWN_HEIGHT) //height of top/primary bar
            .setItemHeight(DROPDOWN_HEIGHT) //height of all item/dropdown bars
            .setVisible(true)
            ;
        // for each entry in the enum, add it to the dropdown.
        for (EmgSettingsEnum value : enumValues) {
            // this will store the *actual* enum object inside the dropdown!
            list.addItem(value.getString(), value);
        }
        //Style the text in the ScrollableList
        list.getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(e.getString())
            .setFont(h5)
            .setSize(12)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        list.getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(e.getString())
            .setFont(p6)
            .setSize(10) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
        list.addCallback(new SLCallbackListener(chanNum));
        return list;
    }

    private class SLCallbackListener implements CallbackListener {
        private int channel;
    
        SLCallbackListener(int _i)  {
            channel = _i;
        }
        public void controlEvent(CallbackEvent theEvent) {
            int _bgColor = 0xFFFFFFFF;
            //Selecting an item from ScrollableList triggers Broadcast
            if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) { 
                int val = (int)(theEvent.getController()).getValue();
                Map bob = ((ScrollableList)theEvent.getController()).getItem(val);
                EmgSettingsEnum myEnum = (EmgSettingsEnum)bob.get("value");
                verbosePrint("EmgSettings: " + (theEvent.getController()).getName() + " == " + myEnum.getString());

                if (myEnum instanceof EmgWindow) {
                    emgSettingsValues.window[channel] = (EmgWindow)myEnum;
                } else if (myEnum instanceof EmgUVLimit) {
                    emgSettingsValues.uvLimit[channel] = (EmgUVLimit)myEnum;
                } else if (myEnum instanceof EmgCreepIncreasing) {
                    emgSettingsValues.creepIncreasing[channel] = (EmgCreepIncreasing)myEnum;
                } else if (myEnum instanceof EmgCreepDecreasing) {
                    emgSettingsValues.creepDecreasing[channel] = (EmgCreepDecreasing)myEnum;
                } else if (myEnum instanceof EmgMinimumDeltaUV) {
                    emgSettingsValues.minimumDeltaUV[channel] = (EmgMinimumDeltaUV)myEnum;
                } else if (myEnum instanceof EmgLowerThresholdMinimum) {
                    emgSettingsValues.lowerThresholdMinimum[channel] = (EmgLowerThresholdMinimum)myEnum;
                }
            }
        }
    }

    private void createEmgSettingsSaveButton(String name, String text, int _x, int _y, int _w, int _h) {
        saveButton = createButton(emgCp5, name, text, _x, _y, _w, _h, h5, 12, colorNotPressed, OPENBCI_DARKBLUE);
        saveButton.setBorderColor(OBJECT_BORDER_GREY);
        saveButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                dataProcessing.emgSettings.storeSettings();
            }
        });
    }

    private void createEmgSettingsLoadButton(String name, String text, int _x, int _y, int _w, int _h) {
        loadButton = createButton(emgCp5, name, text, _x, _y, _w, _h, h5, 12, colorNotPressed, OPENBCI_DARKBLUE);
        loadButton.setBorderColor(OBJECT_BORDER_GREY);
        loadButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                dataProcessing.emgSettings.loadSettings();
            }
        });
    }

    private void createEmgSettingsDefaultButton(String name, String text, int _x, int _y, int _w, int _h) {
        defaultButton = createButton(emgCp5, name, text, _x, _y, _w, _h, h5, 12, colorNotPressed, OPENBCI_DARKBLUE);
        defaultButton.setBorderColor(OBJECT_BORDER_GREY);
        defaultButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                dataProcessing.emgSettings.revertAllChannelsToDefaultValues();
            }
        });
    }

    private void updateCp5Objects() {
        for (int i = 0; i < channelCount; i++) {
            //Fetch values from the EmgSettingsValues object
            EmgWindow updateSmoothing = emgSettingsValues.window[i];
            EmgUVLimit updateUVLimit = emgSettingsValues.uvLimit[i];
            EmgCreepIncreasing updateCreepIncreasing = emgSettingsValues.creepIncreasing[i];
            EmgCreepDecreasing updateCreepDecreasing = emgSettingsValues.creepDecreasing[i];
            EmgMinimumDeltaUV updateMinimumDeltaUV = emgSettingsValues.minimumDeltaUV[i];
            EmgLowerThresholdMinimum updateLowerThresholdMinimum = emgSettingsValues.lowerThresholdMinimum[i];

            //Update the ScrollableLists
            windowLists[i].getCaptionLabel().setText(updateSmoothing.getString());
            uvLimitLists[i].getCaptionLabel().setText(updateUVLimit.getString());
            creepIncLists[i].getCaptionLabel().setText(updateCreepIncreasing.getString());
            creepDecLists[i].getCaptionLabel().setText(updateCreepDecreasing.getString());
            minDeltaUvLists[i].getCaptionLabel().setText(updateMinimumDeltaUV.getString());
            lowLimitLists[i].getCaptionLabel().setText(updateLowerThresholdMinimum.getString());
        }
    }

    //We have to add an implementation of this class since this is a child instance of PApplet.
    class TextBox {
        private int x, y;
        private int w, h;
        private int textColor;
        private int backgroundColor;
        private PFont font;
        private int fontSize;
        private String string;
        private boolean drawBackground = true;
        private int backgroundEdge_pixels;
        private int alignH,alignV;
        private boolean drawObject = true;

        TextBox(String s, int x1, int y1) {
            string = s; x = x1; y = y1;
            textColor = OPENBCI_DARKBLUE;
            backgroundColor = color(255);
            fontSize = 12;
            font = p5;
            backgroundEdge_pixels = 1;
            drawBackground = false;
            alignH = LEFT;
            alignV = BOTTOM;
        }

        TextBox(String s, int x1, int y1, int _textColor, int _backgroundColor, int _alignH, int _alignV) {
            this(s, x1, y1);
            textColor = _textColor;
            backgroundColor = _backgroundColor;
            drawBackground = true;
            alignH = _alignH;
            alignV = _alignV;
        }

        TextBox(String s, int x1, int y1, int _textColor, int _backgroundColor, int _fontSize, PFont _font, int _alignH, int _alignV) {
            this(s, x1, y1, _textColor, _backgroundColor, _alignH, _alignV);
            fontSize = _fontSize;
            font = _font;
        }
        
        public void draw() {

            if (!drawObject) {
                return;
            }

            pushStyle();
            noStroke();
            textFont(font);

            //draw the box behind the text
            if (drawBackground == true) {
                w = PApplet.parseInt(round(textWidth(string)));
                int xbox = x - backgroundEdge_pixels;
                switch (alignH) {
                    case LEFT:
                        xbox = x - backgroundEdge_pixels;
                        break;
                    case RIGHT:
                        xbox = x - w - backgroundEdge_pixels;
                        break;
                    case CENTER:
                        xbox = x - PApplet.parseInt(round(w/2.0f)) - backgroundEdge_pixels;
                        break;
                }
                w = w + 2*backgroundEdge_pixels;
                
                h = PApplet.parseInt(textAscent()) + backgroundEdge_pixels*2;
                int ybox = y;
                if (alignV == CENTER) {
                    ybox -= textAscent() / 2 - backgroundEdge_pixels;
                } else if (alignV == BOTTOM) {
                    ybox -= textAscent() + backgroundEdge_pixels*3;
                }
                fill(backgroundColor);
                rect(xbox,ybox,w,h);
            }
            popStyle();
            
            //draw the text itself
            pushStyle();
            noStroke();
            fill(textColor);
            textAlign(alignH,alignV);
            textFont(font);
            text(string,x,y);
            strokeWeight(1);
            popStyle();
        }

        public void setPosition(int _x, int _y) {
            x = _x;
            y = _y;
        }

        public void setText(String s) {
            string = s;
        }

        public void setTextColor(int c) {
            textColor = c;
        }

        public void setBackgroundColor(int c) {
            backgroundColor = c;
        }

        public int getWidth() {
            return w;
        }

        public int getHeight() {
            return h;
        }

        public void setVisible(boolean b) {
            drawObject = b;
        }
    };
}
////////////////////////////////////////////////////////////////////////////////////////////////
//                                   EMG Values Data Class                                    //
//                              Richard Waltman - February 2023                               //
//   Make this class full of arrays rather than instances of single class full of values.     //
//  This supports having custom settings that can be easily modified on a per-channel basis.  //
////////////////////////////////////////////////////////////////////////////////////////////////

class EmgSettingsValues {

    //These values can be changed via dropdowns
    public EmgWindow[] window;
    public EmgUVLimit[] uvLimit;
    public EmgCreepIncreasing[] creepIncreasing;
    public EmgCreepDecreasing[] creepDecreasing;
    public EmgMinimumDeltaUV[] minimumDeltaUV;
    public EmgLowerThresholdMinimum[] lowerThresholdMinimum;
    //Normalized output which is passed to Networking
    private transient float[] outputNormalized;
    //These values change during calculations
    private transient float[] upperThreshold;
    private transient float[] lowerThreshold;
    private transient float[] averageuV;

    private transient int channelCount;

    EmgSettingsValues() {

        channelCount = currentBoard.getNumEXGChannels();

        window = new EmgWindow[channelCount];
        uvLimit = new EmgUVLimit[channelCount];
        creepIncreasing = new EmgCreepIncreasing[channelCount];
        creepDecreasing = new EmgCreepDecreasing[channelCount];
        minimumDeltaUV = new EmgMinimumDeltaUV[channelCount];
        lowerThresholdMinimum = new EmgLowerThresholdMinimum[channelCount];

        outputNormalized = new float[channelCount];
        upperThreshold = new float[channelCount];
        lowerThreshold = new float[channelCount];
        averageuV = new float[channelCount];

        Arrays.fill(window, EmgWindow.ONE_SECOND);
        Arrays.fill(uvLimit, EmgUVLimit.TWO_HUNDRED_UV);
        Arrays.fill(creepIncreasing, EmgCreepIncreasing.POINT_9);
        Arrays.fill(creepDecreasing, EmgCreepDecreasing.POINT_99999);
        Arrays.fill(minimumDeltaUV, EmgMinimumDeltaUV.TEN_UV);
        Arrays.fill(lowerThresholdMinimum, EmgLowerThresholdMinimum.SIX_UV);
        Arrays.fill(outputNormalized, 0);
        Arrays.fill(upperThreshold, 25);
        Arrays.fill(lowerThreshold, 0);
        Arrays.fill(averageuV, 0.0f);
    }

    //Pass filtered data into this method
    public void process(float[][] data_forDisplay_uV) {
        //looping over channels and analyzing input data
        for (int i = 0; i < channelCount; i++) {
            float averagePeriod = currentBoard.getSampleRate() * window[i].getValue();
            int _uvLimit = uvLimit[i].getValue();
            float creepSpeedIncreasing = creepIncreasing[i].getValue();
            float creepSpeedDecreasing = creepDecreasing[i].getValue();
            int _minimumDeltaUV = minimumDeltaUV[i].getValue();
            int _lowerThresholdMininum = lowerThresholdMinimum[i].getValue();
            
            //Calculate average
            averageuV[i] = 0.0f;
            for (int j = data_forDisplay_uV[i].length - PApplet.parseInt(averagePeriod); j < data_forDisplay_uV[i].length; j++) {
                if (abs(data_forDisplay_uV[i][j]) <= _uvLimit) { //prevent BIG spikes from effecting the average
                    averageuV[i] += abs(data_forDisplay_uV[i][j]);  //add value to average ... we will soon divide by # of packets
                } else {
                    averageuV[i] += _uvLimit; //if it's greater than the limit, just add the limit
                }
            }
            averageuV[i] = averageuV[i] / averagePeriod; //finishing the average

            if (averageuV[i] >= upperThreshold[i] && averageuV[i] <= _uvLimit) { //
                upperThreshold[i] = averageuV[i];
            }
            if (averageuV[i] <= lowerThreshold[i]) {
                lowerThreshold[i] = averageuV[i];
            }
            if (upperThreshold[i] >= (averageuV[i] + _minimumDeltaUV)) {  //minRange = 15
                upperThreshold[i] *= creepSpeedIncreasing; //adjustmentSpeed
            }
            if (lowerThreshold[i] <= 1){
                lowerThreshold[i] = 1.0f;
            }
            if (lowerThreshold[i] <= averageuV[i]) {
                lowerThreshold[i] *= (1 / creepSpeedDecreasing); //adjustmentSpeed
            }
            if (lowerThreshold[i] < _lowerThresholdMininum) {
                lowerThreshold[i] = _lowerThresholdMininum;
            }
            if (upperThreshold[i] <= (lowerThreshold[i] + _minimumDeltaUV)){
                upperThreshold[i] = lowerThreshold[i] + _minimumDeltaUV;
            }

            outputNormalized[i] = map(averageuV[i], lowerThreshold[i], upperThreshold[i], 0, 1);
            if(outputNormalized[i] < 0){
                outputNormalized[i] = 0; //always make sure this value is >= 0
            }
        }
    }

    public float getOutputNormalized(int channel) {
        return outputNormalized[channel];
    }

    public float getAverageuV(int channel) {
        return averageuV[channel];
    }

    public float getUpperThreshold(int channel) {
        return upperThreshold[channel];
    }

    public float getLowerThreshold(int channel) {
        return lowerThreshold[channel];
    }
}






//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------




/**
  * @description Helper function to determine if the system is linux or not.
  * @return {boolean} true if os is linux, false otherwise.
  */
private boolean isLinux() {
    return System.getProperty("os.name").toLowerCase().indexOf("linux") > -1;
}

/**
  * @description Helper function to determine if the system is windows or not.
  * @return {boolean} true if os is windows, false otherwise.
  */
private boolean isWindows() {
    return System.getProperty("os.name").toLowerCase().indexOf("windows") > -1;
}

/**
  * @description Helper function to determine if the system is macOS or not.
  * @return {boolean} true if os is windows, false otherwise.
  */
private boolean isMac() {
    return !isWindows() && !isLinux();
}

private void checkIsMacFullDetail() {
    StringBuilder response = new StringBuilder("MacOS Details: ");
    if (isMacOsLowerThanCatalina()) {
        response.append("MacOS Mojave or earlier");
    } else if (isMacOsBigSur()) {
        response.append("MacOS Big Sur");
    } else if (isMacOsMonterey()) {
        response.append("MacOS Monterey");
    } else {
        response.append("MacOS Catalina");
    }
    println(response);
}

// For a full list of modern Mac OS versions, visit https://en.wikipedia.org/wiki/MacOS_version_history
private boolean isMacOsLowerThanCatalina() {
    int[] versionInfo = fetchAndParseMacOsVersion();
    return versionInfo[0] <= 10 && versionInfo[1] < 15;
}

private boolean isMacOsBigSur() {
    int[] versionInfo = fetchAndParseMacOsVersion();
    //This should return 11, but there was a recently discovered bug in Java 8 -- https://bugs.openjdk.java.net/browse/JDK-8274907
    int[] javaInfo = fetchAndParseJavaVersion();
    boolean usingJava8_202 = javaInfo[0] == 1 && javaInfo[1] == 8 && javaInfo[2] == 202;
    if (usingJava8_202) {
        return versionInfo[0] == 10 && versionInfo[1] == 16;
    } else {
        return versionInfo[0] == 11;
    }
}

private boolean isMacOsMonterey() {
    int[] versionInfo = fetchAndParseMacOsVersion();
    return versionInfo[0] == 12;
}

private String getOperatingSystemVersion() {
    return System.getProperty("os.version");
}

private int[] fetchAndParseMacOsVersion() {
    if (!isMac()) {
        println("Oops! Please only call this method on MacOS");
        return null;
    }
    final String version = getOperatingSystemVersion();
    final String[] splitStrings = split(version, '.');
    int[] versionVals = new int[splitStrings.length];
    for (int i = 0; i < splitStrings.length; i++) {
        versionVals[i] = Integer.valueOf(splitStrings[i]);
    }
    return versionVals;
}

private int[] fetchAndParseJavaVersion() {
    final String version = System.getProperty("java.version");
    final String[] splitStrings = split(version, '.');
    int[] versionVals = new int[splitStrings.length];
    versionVals[0] = Integer.valueOf(splitStrings[0]);
    versionVals[1] = Integer.valueOf(splitStrings[1]);
    final String[] minorVersion = split(splitStrings[2], "_");
    versionVals[2] = Integer.valueOf(minorVersion[minorVersion.length - 1]);
    return versionVals;
}

//BrainFlow only supports Windows 8 and 10. This will help with OpenBCI support tickets. #964
private void checkIsOldVersionOfWindowsOS() {
    boolean isOld = SystemUtils.IS_OS_WINDOWS_7 || SystemUtils.IS_OS_WINDOWS_VISTA || SystemUtils.IS_OS_WINDOWS_XP;
    if (isOld) {
        PopupMessage msg = new PopupMessage("Old Windows OS Detected", "OpenBCI GUI v5 and BrainFlow are made for 64-bit Windows 8, 8.1, and 10. Please update your OS, computer, or revert to GUI v4.2.0.");
    }
}

//Sanity check for 64-bit Java for Windows users #964
private void checkIs64BitJava() {
    boolean is64Bit = System.getProperty("sun.arch.data.model").indexOf("64") >= 0;
    if (!is64Bit) {
        PopupMessage msg = new PopupMessage("32-bit Java Detected", "OpenBCI GUI v5 and BrainFlow are made for 64-bit Java (Windows, Linux, and Mac). Please update your OS, computer, Processing IDE, or revert to GUI v4 or earlier.");
    }
}
/**
* Determines if elevated rights are required to install/uninstall the application.
*
* @return <code>true</code> if elevation is needed to have administrator permissions, <code>false</code> otherwise.
*/
public boolean isElevationNeeded() {
    return isElevationNeeded(null);
}
/**
* Determines if elevated rights are required to install/uninstall the application.
*
* @param path the installation path, or <tt>null</tt> if the installation path is unknown
* @return <tt>true</tt> if elevation is needed to have administrator permissions, <tt>false</tt> otherwise.
*/
public boolean isElevationNeeded(String path) {
    boolean result;
    if (isWindows()) {
        if (path != null) {
            // use the parent path, as that needs to be written to in order to delete the tree
            path = new File(path).getParent();
        }
        if (path == null || path.trim().length() == 0) {
            path = getWindowsProgramFiles();
        }
        result = !canWrite(path);
    } else {
        if (path != null) {
            result = !canWrite(path);
        } else {
            if (isMac()) {
                //Mac user name is never simply "root"
                return false;
            }
            result = !System.getProperty("user.name").equals("root");
        }
    }
    return result;
}
/**
* Determine if user has administrative privileges.
*
* @return
*/
public boolean isAdminUser() {
    if (isMac()) {
        return true;
    }
    if (isWindows()) {
        try {
            String NTAuthority = "HKU\\S-1-5-19";
            String command = "reg query \""+ NTAuthority + "\"";
            Process p = Runtime.getRuntime().exec(command);
            p.waitFor();
            return (p.exitValue() == 0);
        } catch (Exception e) {
            return canWrite(getWindowsProgramFiles());
        }
    }
    try {
        String command = "id -u";
        Process p = Runtime.getRuntime().exec(command);
        p.waitFor();
        InputStream stdIn = p.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(stdIn));
        String value = bufferedReader.readLine();
        return value.equals("0");
    } catch (Exception e) {
        return System.getProperty("user.name").equals("root");
    }
}
/**
* Tries to determine the Windows Program Files directory.
*
* @return the Windows Program Files directory
*/
private String getWindowsProgramFiles() {
    String path = System.getenv("ProgramFiles");
    if (path == null) {
        path = "C:\\Program Files";
    }
    return path;
}
/**
* Determines if the specified path can be written to.
*
* @param path the path to check
* @return <tt>true</tt> if the path can be written to, otherwise <tt>false</tt>
*/
private boolean canWrite(String path) {
    File file = new File(path);
    boolean canWrite = file.canWrite();
    if (canWrite) {
        // make sure that the path can actually be written to, for IZPACK-727
        try {
            File test = File.createTempFile(".izpackwritecheck", null, file);
            if (!test.delete()) {
                test.deleteOnExit();
            }
        } catch (IOException exception) {
            canWrite = false;
        }
    }
    return canWrite;
}

//compute the standard deviation
public float std(float[] data) {
    //calc mean
    float ave = mean(data);

    //calc sum of squares relative to mean
    float val = 0;
    for (int i=0; i < data.length; i++) {
        val += pow(data[i]-ave,2);
    }

    // divide by n to make it the average
    val /= data.length;

    //take square-root and return the standard
    return (float)Math.sqrt(val);
}

public float mean(float[] data) {
    return mean(data,data.length);
}

// cp5 textfields adds garbage chars to text field and they are invisible
public String dropNonPrintableChars(String myString)
{
    StringBuilder newString = new StringBuilder(myString.length());
    for (int offset = 0; offset < myString.length();)
    {
        int codePoint = myString.codePointAt(offset);
        offset += Character.charCount(codePoint);

        // Replace invisible control characters and unused code points
        switch (Character.getType(codePoint))
        {
            case Character.CONTROL:     // \p{Cc}
            case Character.FORMAT:      // \p{Cf}
            case Character.PRIVATE_USE: // \p{Co}
            case Character.SURROGATE:   // \p{Cs}
            case Character.UNASSIGNED:  // \p{Cn}
                break;
            default:
                newString.append(Character.toChars(codePoint));
                break;
        }
    }
    String res = newString.toString();
    res = res.replace("\r", "");
    res = res.replace("\n", "");
    res = res.replace("\t", "");
    return res;
}

public String getIpAddrFromStr(String strWithIP) {
    String temp = dropNonPrintableChars(strWithIP);
    String IPADDRESS_PATTERN = 
        "(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
    Pattern pattern = Pattern.compile(IPADDRESS_PATTERN);
    Matcher matcher = pattern.matcher(temp);
    if (matcher.find()) {
        return matcher.group();
    } else{
        output("Invalid Ip address");
        println("Provided Ip address doesn't match regexp");
        return "";
    }
}

public float getFontStringHeight(PFont _font, String string) {
    float minY = Float.MAX_VALUE;
    float maxY = Float.NEGATIVE_INFINITY;
    for (Character c : string.toCharArray()) {
        PShape character = _font.getShape(c); // create character vector
        for (int i = 0; i < character.getVertexCount(); i++) {
            minY = min(character.getVertex(i).y, minY);
            maxY = max(character.getVertex(i).y, maxY);
        }
    }
    return maxY - minY;
}

//////////////////////////////////////////////////
//
// Some functions to implement some math and some filtering.  These functions
// probably already exist in Java somewhere, but it was easier for me to just
// recreate them myself as I needed them.
//
// Created: Chip Audette, Oct 2013
//
//////////////////////////////////////////////////

public int findMax(float[] data) {
    float maxVal = data[0];
    int maxInd = 0;
    for (int I=1; I<data.length; I++) {
        if (data[I] > maxVal) {
            maxVal = data[I];
            maxInd = I;
        }
    }
    return maxInd;
}

public float mean(float[] data, int Nback) {
    return sum(data,Nback)/Nback;
}

public float sum(float[] data) {
    return sum(data, data.length);
}

public float sum(float[] data, int Nback) {
    float sum = 0;
    if (Nback > 0) {
        for (int i=(data.length)-Nback; i < data.length; i++) {
            sum += data[i];
        }
    }
    return sum;
}

public float calcDotProduct(float[] data1, float[] data2) {
    int len = min(data1.length, data2.length);
    float val=0.0f;
    for (int I=0;I<len;I++) {
        val+=data1[I]*data2[I];
    }
    return val;
}


public float log10(float val) {
    return (float)Math.log10(val);
}

public float log10(int val) {
    return (float)Math.log10(val);
}

public float filterWEA_1stOrderIIR(float[] filty, float learn_fac, float filt_state) {
    float prev = filt_state;
    for (int i=0; i < filty.length; i++) {
        filty[i] = prev*(1-learn_fac) + filty[i]*learn_fac;
        prev = filty[i]; //save for next time
    }
    return prev;
}

public void removeMean(float[] filty, int Nback) {
    float meanVal = mean(filty,Nback);
    for (int i=0; i < filty.length; i++) {
        filty[i] -= meanVal;
    }
}

public double[] floatToDoubleArray(float[] array) {
    double[] res = new double[array.length];
    for (int i = 0; i < res.length; i++) {
        res[i] = (double)array[i];
    }
    return res;
}

public float[] doubleToFloatArray(double[] array) {
    float[] res = new float[array.length];
    for (int i = 0; i < res.length; i++) {
        res[i] = (float)array[i];
    }
    return res;
}

public void floatToDoubleArray(float[] array, double[] res) {
    for (int i = 0; i < array.length; i++) {
        res[i] = (double)array[i];
    }
}

public void doubleToFloatArray(double[] array, float[] res) {
    for (int i = 0; i < array.length; i++) {
        res[i] = (float)array[i];
    }
}

// shortens a string to a given width by adding [...] in the middle
// make sure to pass the right font for accurate sizing
public String shortenString(String str, float maxWidth, PFont font) {
    if (textWidth(str) <= maxWidth) {
        return str;
    }

    textFont(font); // set font for accurate sizing
    int firstIndex = 0; // forward iterator
    int lastIndex = str.length()-1; // reverse iterator
    float spaceLeft = maxWidth - textWidth("..."); // account for the space taken by "..."

    while (firstIndex < lastIndex && spaceLeft >= 0.f) {
        spaceLeft -= textWidth(str.charAt(firstIndex)); // subtract space taken by first char
        spaceLeft -= textWidth(str.charAt(lastIndex)); // and last char

        // move interators inward
        firstIndex ++;
        lastIndex --;
    }

    String s1 = str.substring(0, firstIndex); // firstIndex is excluded here
    String s2 = str.substring(lastIndex + 1, str.length()); // manually exclude lastIndex
    return s1 + "..." + s2;
}

public int lerpInt(long first, long second, float bias) {
    return round(lerp(first, second, bias));    
}

public int[] range(int first, int second) {
    int total = abs(first-second);
    int[] result = new int[total];

    for(int i=0; i<total; i++) {
        int newNumber = first;
        if(first > second) {
            newNumber -= i;
        }
        else {
            newNumber += i;
        }

        result[i] = newNumber;
    }

    return result;
}

//------------------------------------------------------------------------
//                            Classes
//------------------------------------------------------------------------

class RectDimensions {
    public int x, y, w, h;
}

class DataStatus {
    public boolean is_railed;
    public boolean is_railed_warn;
    private double percentage;
    public String notificationString;
    private final int default_color = OPENBCI_DARKBLUE;
    private final int yellow = SIGNAL_CHECK_YELLOW;
    private final int red = BOLD_RED;
    private int colorIndicator = default_color;
    // thresholds are pecentages of max possible value
    private double threshold_railed = 90.0f;
    private double threshold_railed_warn = 75.0f;

    DataStatus() {
        notificationString = "";
        is_railed = false;
        is_railed_warn = false;
        percentage = 0.0f;
    }
    // here data is a full range for 20sec of data and doesnt take in account window size
    public void update(float[] data, int channel) {
        percentage = 0.0f;
        is_railed = false;
        is_railed_warn = false;

        if (data.length < 1) {
            return;
        }

        if (currentBoard instanceof ADS1299SettingsBoard) {
            double scaler =  (4.5f / (pow (2, 23) - 1) / ((ADS1299SettingsBoard)currentBoard).getGain(channel) * 1000000.f);
            double maxVal = scaler * pow (2, 23);
            int numSeconds = 3;
            int nPoints = numSeconds * currentBoard.getSampleRate();
            int endPos = data.length;
            int startPos = Math.max(0, endPos - nPoints);

            boolean is_straight_line = true;
            if (!currentBoard.isStreaming()) {
                is_straight_line = false;
            }
            float max = Math.abs(data[startPos]);
            for (int i = startPos + 1; i < endPos; i++) {
                if (Math.abs(data[i]) > max) {
                    max = Math.abs(data[i]);
                }
                if ((Math.abs(data[i - 1] - data[i]) > 0.00001f) && (Math.abs(data[i]) > 0.00001f)) {
                    is_straight_line = false;
                }
            }
            percentage = (max / maxVal) * 100.0f;

            notificationString = "Not Railed " + String.format("%1$,.2f", percentage) + "% ";
            colorIndicator = default_color;
            if (percentage > threshold_railed_warn) {
                is_railed_warn = true;
                notificationString = "Near Railed " + String.format("%1$,.2f", percentage) + "% ";
                colorIndicator = yellow;
            }
            if (percentage > threshold_railed) {
                is_railed = true;
                notificationString = "Railed " + String.format("%1$,.2f", percentage) + "% ";
                colorIndicator = red;
            } else {
                if (is_straight_line) {
                    is_railed = true;
                    notificationString = "Data from the board doesn't change";
                    colorIndicator = red;
                }
            }

        }
    }
    public int getColor() {
        return colorIndicator;
    }
    public double getPercentage() {
        return percentage;
    }

    public void setRailedWarnThreshold(double d) {
        threshold_railed_warn = d;
    }

    public void setRailedThreshold(double d) {
        threshold_railed = d;
    }
};

class FilterConstants {
    public double[] a;
    public double[] b;
    public String name;
    public String short_name;
    FilterConstants(double[] b_given, double[] a_given, String name_given, String short_name_given) {
        b = new double[b_given.length];a = new double[b_given.length];
        for (int i=0; i<b.length;i++) { b[i] = b_given[i];}
        for (int i=0; i<a.length;i++) { a[i] = a_given[i];}
        name = name_given;
        short_name = short_name_given;
    }
};

class PlotFontInfo {
        String fontName = "fonts/Raleway-Regular.otf";
        int axisLabel_size = 16;
        int tickLabel_size = 14;
        int buttonLabel_size = 12;
};


class TextBox {
    private int x, y;
    private int w, h;
    private int textColor;
    private int backgroundColor;
    private PFont font;
    private int fontSize;
    private String string;
    private boolean drawBackground = true;
    private int backgroundEdge_pixels;
    private int alignH,alignV;
    private boolean drawObject = true;

    TextBox(String s, int x1, int y1) {
        string = s; x = x1; y = y1;
        textColor = OPENBCI_DARKBLUE;
        backgroundColor = color(255);
        fontSize = 12;
        font = p5;
        backgroundEdge_pixels = 1;
        drawBackground = false;
        alignH = LEFT;
        alignV = BOTTOM;
    }

    TextBox(String s, int x1, int y1, int _textColor, int _backgroundColor, int _alignH, int _alignV) {
        this(s, x1, y1);
        textColor = _textColor;
        backgroundColor = _backgroundColor;
        drawBackground = true;
        alignH = _alignH;
        alignV = _alignV;
    }

    TextBox(String s, int x1, int y1, int _textColor, int _backgroundColor, int _fontSize, PFont _font, int _alignH, int _alignV) {
        this(s, x1, y1, _textColor, _backgroundColor, _alignH, _alignV);
        fontSize = _fontSize;
        font = _font;
    }
    
    public void draw() {

        if (!drawObject) {
            return;
        }

        pushStyle();
        noStroke();
        textFont(font);

        //draw the box behind the text
        if (drawBackground == true) {
            w = PApplet.parseInt(round(textWidth(string)));
            int xbox = x - backgroundEdge_pixels;
            switch (alignH) {
                case LEFT:
                    xbox = x - backgroundEdge_pixels;
                    break;
                case RIGHT:
                    xbox = x - w - backgroundEdge_pixels;
                    break;
                case CENTER:
                    xbox = x - PApplet.parseInt(round(w/2.0f)) - backgroundEdge_pixels;
                    break;
            }
            w = w + 2*backgroundEdge_pixels;
            
            h = PApplet.parseInt(textAscent()) + backgroundEdge_pixels*2;
            int ybox = y;
            if (alignV == CENTER) {
                ybox -= textAscent() / 2 - backgroundEdge_pixels;
            } else if (alignV == BOTTOM) {
                ybox -= textAscent() + backgroundEdge_pixels*3;
            }
            fill(backgroundColor);
            rect(xbox,ybox,w,h);
        }
        popStyle();
        
        //draw the text itself
        pushStyle();
        noStroke();
        fill(textColor);
        textAlign(alignH,alignV);
        textFont(font);
        text(string,x,y);
        strokeWeight(1);
        popStyle();
    }

    public void setPosition(int _x, int _y) {
        x = _x;
        y = _y;
    }

    public void setText(String s) {
        string = s;
    }

    public void setTextColor(int c) {
        textColor = c;
    }

    public void setBackgroundColor(int c) {
        backgroundColor = c;
    }

    public int getWidth() {
        return w;
    }

    public int getHeight() {
        return h;
    }

    public void setVisible(boolean b) {
        drawObject = b;
    }
};

public boolean pingWebsite(String url) {
    int code = 200;
    try {
        URL siteURL = new URL(url);
        HttpURLConnection connection = (HttpURLConnection) siteURL.openConnection();
        connection.setRequestMethod("GET");
        connection.setConnectTimeout(2000);
        connection.connect();

        code = connection.getResponseCode();
        if (code == 200) {
            return true;
        } else {
            return false;
        }
    } catch (IOException e) {
        return false;

    }
}

public BufferedReader createBufferedReader(String filepath) {
    File file;
    BufferedReader reader;
    try {
        file = new File(filepath);
        reader = new BufferedReader(new FileReader(file));
        return reader;
    } catch (IOException e) {
        e.printStackTrace();
        return null;
    }
}

//Used to check for one string in a text file
//Uses a buffered reader for this method so that we do not load entire file to memory
public boolean checkTextFileForInfo(String path, String infoToCheck, int maxLinesToCheck) {
    verbosePrint("Checking " + path + " for " + infoToCheck);
    String strCurrentLine;
    int lineCounter = 0;
    BufferedReader reader = createBufferedReader(path);
    try {
        while (lineCounter < maxLinesToCheck) {
            strCurrentLine = reader.readLine();
            verbosePrint(strCurrentLine);
            if (strCurrentLine.equals(infoToCheck)) {
                return true;
            }
            lineCounter++;
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try {
            if (reader != null) {
                reader.close();
            }
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
    return false;
}
interface FileBoard {

    public int getTotalSamples();

    public float getTotalTimeSeconds();

    public int getCurrentSample();

    public float getCurrentTimeSeconds();

    public void goToIndex(int index);

    public boolean endOfFileReached();
};
interface FilterSettingsEnum {
    public String getString();
}

public enum BFFilter implements FilterSettingsEnum
{
    BANDSTOP (0, "BandStop"),
    BANDPASS (1, "BandPass");

    private int index;
    private String name;
 
    BFFilter(int index, String name) {
        this.index = index;
        this.name = name;
    }

    public int getIndex() {
        return index;
    }
    
    public String getString() {
        return name;
    }
}

public enum FilterChannelSelect implements FilterSettingsEnum
{
    ALL_CHANNELS (0, "All Channels"),
    CUSTOM_CHANNELS (1, "Per Channel");

    private int index;
    private String name;
 
    FilterChannelSelect(int index, String name) {
        this.index = index;
        this.name = name;
    }

    public int getIndex() {
        return index;
    }

    public String getString() {
        return name;
    }
}

enum GlobalEnvironmentalFilter implements FilterSettingsEnum {
    FIFTY (0, "50 Hz"),
    SIXTY (1, "60 Hz"),
    FIFTY_AND_SIXTY (2, "50 + 60 Hz"),
    NONE (3, "None");

    private int index;
    private String name;

    GlobalEnvironmentalFilter(int index, String name) {
        this.index = index;
        this.name = name;
    }

    public int getIndex() {
        return index;
    }

    public String getString() {
        return name;
    }
}

enum FilterActiveOnChannel implements FilterSettingsEnum {
    ON (0, "Active"),
    OFF (1, "Inactive");

    private int index;
    private String name;

    FilterActiveOnChannel(int index, String name) {
        this.index = index;
        this.name = name;
    }

    public int getIndex() {
        return index;
    }

    public String getString() {
        return name;
    }

    public boolean isActive() {
        return name.equals("Active");
    }
}

enum BrainFlowFilterType implements FilterSettingsEnum {
    BUTTERWORTH (0, "Butterworth", FilterTypes.BUTTERWORTH.get_code()),
    CHEBYSHEV (1, "Chebyshev", FilterTypes.CHEBYSHEV_TYPE_1.get_code()),
    BESSEL (2, "Bessel", FilterTypes.BESSEL.get_code());

    private int index;
    private String name;
    private int value;

    BrainFlowFilterType(int index, String name, int value) {
        this.index = index;
        this.name = name;
        this.value = value;
    }

    public int getIndex() {
        return index;
    }

    public String getString() {
        return name;
    }

    private int getValue() {
        return value;
    }
}

public enum BrainFlowFilterOrder implements FilterSettingsEnum {
    TWO (0, "2", 2),
    THREE (1, "3", 3),
    FOUR (2, "4", 4);

    private int index;
    private String name;
    private int value;

    BrainFlowFilterOrder(int index, String name, int value) {
        this.index = index;
        this.name = name;
        this.value = value;
    }

    public int getIndex() {
        return index;
    }

    public String getString() {
        return name;
    }

    public int getValue() {
        return value;
    }
}
//Global variable to track if filter settings were loaded.
public boolean filterSettingsWereLoadedFromFile = false;

public class FilterSettingsValues {
    
    public BFFilter brainFlowFilter;
    public FilterChannelSelect filterChannelSelect;
    public GlobalEnvironmentalFilter globalEnvFilter;

    public FilterActiveOnChannel masterBandStopFilterActive;
    public double masterBandStopStartFreq;
    public double masterBandStopStopFreq;
    public BrainFlowFilterType masterBandStopFilterType = BrainFlowFilterType.BUTTERWORTH;
    public BrainFlowFilterOrder masterBandStopFilterOrder = BrainFlowFilterOrder.TWO;

    public FilterActiveOnChannel[] bandStopFilterActive;
    public double[] bandStopStartFreq;
    public double[] bandStopStopFreq;
    public BrainFlowFilterType[] bandStopFilterType;
    public BrainFlowFilterOrder[] bandStopFilterOrder;
    
    public FilterActiveOnChannel masterBandPassFilterActive;
    public double masterBandPassStartFreq;
    public double masterBandPassStopFreq;
    public BrainFlowFilterType masterBandPassFilterType = BrainFlowFilterType.BUTTERWORTH;
    public BrainFlowFilterOrder masterBandPassFilterOrder = BrainFlowFilterOrder.TWO;

    public FilterActiveOnChannel[] bandPassFilterActive;
    public double[] bandPassStartFreq;
    public double[] bandPassStopFreq;
    public BrainFlowFilterType[] bandPassFilterType;
    public BrainFlowFilterOrder[] bandPassFilterOrder;

    public FilterSettingsValues(int channelCount) {
        brainFlowFilter = BFFilter.BANDPASS;
        filterChannelSelect = FilterChannelSelect.ALL_CHANNELS;
        globalEnvFilter = GlobalEnvironmentalFilter.FIFTY_AND_SIXTY;

        //Set Master Values for all channels for BandStop Filter
        masterBandStopFilterActive = FilterActiveOnChannel.OFF;
        masterBandStopStartFreq = 58;
        masterBandStopStopFreq = 62;
        masterBandStopFilterType = BrainFlowFilterType.BUTTERWORTH;
        masterBandStopFilterOrder = BrainFlowFilterOrder.FOUR;
        //Create and assign master value to all channels
        bandStopFilterActive = new FilterActiveOnChannel[channelCount];
        bandStopStartFreq = new double[channelCount];
        bandStopStopFreq = new double[channelCount];
        bandStopFilterType = new BrainFlowFilterType[channelCount];
        bandStopFilterOrder = new BrainFlowFilterOrder[channelCount];
        Arrays.fill(bandStopFilterActive, masterBandStopFilterActive);
        Arrays.fill(bandStopStartFreq, masterBandStopStartFreq);
        Arrays.fill(bandStopStopFreq, masterBandStopStopFreq);
        Arrays.fill(bandStopFilterType, masterBandStopFilterType);
        Arrays.fill(bandStopFilterOrder, masterBandStopFilterOrder);

        //Set Master Values for all channels for BandPass Filter
        //Default to 5-50Hz BandPass on all channels since this has been the default for years
        masterBandPassFilterActive = FilterActiveOnChannel.ON;
        masterBandPassStartFreq = 5;
        masterBandPassStopFreq = 50;
        masterBandPassFilterType = BrainFlowFilterType.BUTTERWORTH;
        masterBandPassFilterOrder = BrainFlowFilterOrder.FOUR;
        //Create and assign master value to all channels
        bandPassFilterActive = new FilterActiveOnChannel[channelCount];
        bandPassStartFreq = new double[channelCount];
        bandPassStopFreq = new double[channelCount];
        bandPassFilterType = new BrainFlowFilterType[channelCount];
        bandPassFilterOrder = new BrainFlowFilterOrder[channelCount];
        Arrays.fill(bandPassFilterActive, masterBandPassFilterActive);
        Arrays.fill(bandPassStartFreq, masterBandPassStartFreq);
        Arrays.fill(bandPassStopFreq, masterBandPassStopFreq);
        Arrays.fill(bandPassFilterType, masterBandPassFilterType);
        Arrays.fill(bandPassFilterOrder, masterBandPassFilterOrder);
    }
}

class FilterSettings {
    
    public FilterSettingsValues values;
    //public FilterSettingsValues previousValues;
    private FilterSettingsValues defaultValues;

    protected DataSource board;
    public int channelCount;

    FilterSettings(DataSource theBoard) {
        board = theBoard;
        channelCount = board.getNumEXGChannels();

        values = new FilterSettingsValues(channelCount);
        defaultValues = new FilterSettingsValues(channelCount);
    }

    public boolean loadSettingsValues(String filename) {
        try {
            File file = new File(filename);
            StringBuilder fileContents = new StringBuilder((int)file.length());        
            Scanner scanner = new Scanner(file);
            while(scanner.hasNextLine()) {
                fileContents.append(scanner.nextLine() + System.lineSeparator());
            }
            Gson gson = new Gson();
            values = gson.fromJson(fileContents.toString(), FilterSettingsValues.class);
            return true;
        } catch (IOException e) {
            e.printStackTrace();    
            File f = new File(filename);
            if (f.exists()) {
                if (f.delete()) {
                    println("FilterSettings: Could not load filter settings from disk. Deleting this file...");
                } else {
                    println("FilterSettings: Error deleting old/broken filter settings file! Please make sure the GUI has proper read/write permissions.");
                }
            }
            return false;
        }
    }

    public String getJson() {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        return gson.toJson(values);
    }

    public boolean saveToFile(String filename) {
        String json = getJson();
        try {
            FileWriter writer = new FileWriter(filename);
            writer.write(json);
            writer.close();
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    public void revertAllChannelsToDefaultValues() {
        values = new FilterSettingsValues(channelCount);
    }

    //Called in UI to control number of channels. This is set from the board when this class is instantiated.
    public int getChannelCount() {
        return channelCount;
    }

    //Avoid error with popup being in another thread.
    public void storeSettings() {
        StringBuilder settingsFilename = new StringBuilder(directoryManager.getSettingsPath());
        settingsFilename.append("FilterSettings");
        settingsFilename.append("_");
        settingsFilename.append(getChannelCount());
        settingsFilename.append("Channels.json");
        String filename = settingsFilename.toString();
        File fileToSave = new File(filename);
        selectOutput("Save filter settings to file", "storeFilterSettings", fileToSave);
    }
    //Avoid error with popup being in another thread.
    public void loadSettings() {
        StringBuilder settingsFilename = new StringBuilder(directoryManager.getSettingsPath());
        settingsFilename.append("FilterSettings");
        settingsFilename.append("_");
        settingsFilename.append(getChannelCount());
        settingsFilename.append("Channels.json");
        String filename = settingsFilename.toString();
        File fileToLoad = new File(filename);
        selectInput("Select settings file to load", "loadFilterSettings", fileToLoad);
    }
}

//Used by button in the Filter UI. Must be global and public.
public void loadFilterSettings(File selection) {
    if (selection == null) {
        output("Filters Settings file not selected.");
    } else {
        if (filterSettings.loadSettingsValues(selection.getAbsolutePath())) {
            outputSuccess("Filter Settings Loaded!");
            filterSettingsWereLoadedFromFile = true;
        } else {
            outputError("Failed to load Filter Settings. The old/broken file has been deleted.");
        }
    }
}

//Used by button in the Filter UI. Must be global and public.
public void storeFilterSettings(File selection) {
    if (selection == null) {
        output("Filter Settings file not selected.");
    } else {
        if (filterSettings.saveToFile(selection.getAbsolutePath())) {
            outputSuccess("Filter Settings Saved!");
        } else {
            outputError("Failed to save Filter Settings.");
        }
    }
}



public boolean filterUIPopupIsOpen = false;

// Instantiate this class to show a popup message
class FilterUIPopup extends PApplet implements Runnable {
    private int fixedWidth;
    private int variableHeight;
    private int newVariableHeight;
    private int shortHeight;
    private int maxHeight;
    private boolean needToResizePopup = false;
    private boolean needToResetCp5Graphics = false;

    private int middle;
    private final int sm_spacer = 6;
    private final int halfSmSpacer = sm_spacer/2;
    private final int lg_spacer = 12;
    private int uiObjectHeight = 26;
    private final int headerHeight = uiObjectHeight + sm_spacer*2;
    private final int headerObjWidth = 90;
    private final int halfObjWidth = headerObjWidth/2;
    private final int numHeaderObjects = 4;
    private final int numColumns = 5;
    private final int numFooterObjects = 3;
    private int[] headerObjX = new int[numHeaderObjects];
    private final int headerObjY = sm_spacer;
    private int[] columnObjX = new int[numColumns];
    private int footerObjY = 0;
    private int[] footerObjX = new int[numFooterObjects];

    private String message = "Sample text string";
    private String headerMessage = "Filters";
    private String buttonMessage = "OK";
    private String buttonLink = null;

    private int headerColor = OPENBCI_BLUE;
    private int buttonColor = OPENBCI_BLUE;
    private int backgroundColor = GREY_235;
    
    private ControlP5 cp5;

    private final int textfieldWidth = 80;
    private final int halfTextfieldWidth = textfieldWidth/2;
    private final int onOff_diameter = uiObjectHeight;
    

    private ScrollableList bfGlobalFilterDropdown;
    private ScrollableList bfEnvironmentalNoiseDropdown;
    private Button saveButton;
    private Button loadButton;
    private Button defaultButton;

    private Button masterOnOffButton;
    private Textfield masterFirstColumnTextfield;
    private Textfield masterSecondColumnTextfield;
    private ScrollableList masterFilterTypeDropdown;
    private ScrollableList masterFilterOrderDropdown;

    private Button[] onOffButtons;
    private Textfield[] firstColumnTextfields;
    private Textfield[] secondColumnTextfields;
    private ScrollableList[] filterTypeDropdowns;
    private ScrollableList[] filterOrderDropdowns;
    
    private boolean masterFirstColumnTextfieldWasActive;
    private boolean masterSecondColumnTextfieldWasActive;
    private boolean[] firstColumnTextfieldWasActive;
    private boolean[] secondColumnTextfieldWasActive;
   
    private boolean[] filterSettingsWereModified;
    private int[] filterSettingsWereModifiedFadeCounter;
    private boolean masterFilterSettingWasModified;
    private int masterFilterSettingWasModifiedFadeCounter;
    private int filterSettingWasModifiedFadeTime = 1000;

    private final int typeDropdownWidth = headerObjWidth;
    private final int orderDropdownWidth = 60;
    private int widthOfAllChannelColumns;
    
    private int expanderX, expanderY, expanderW;
    private final int expanderH = 20;
    private boolean expanderIsHover = false;
    private int expanderTriangleWidth = 12;
    private int expanderTriangleHeight = 6;
    private int expanderBreakMiddle = 90;
    private int expanderLineOneEnd;
    private int expanderLineTwoStart;
    private int[] expanderTriangleXYCollapsed = new int[6];
    private int[] expanderTriangleXYExpanded = new int[6];
    private boolean ignoreExpanderInteraction = false;
    List<controlP5.ScrollableList> cp5ElementsToCheck = new ArrayList<controlP5.ScrollableList>();

    DecimalFormat df = new DecimalFormat("#.0");

    public FilterUIPopup() {
        super();
        filterUIPopupIsOpen = true;

        Thread t = new Thread(this);
        t.start();

        int numChans = filterSettings.getChannelCount();
        onOffButtons = new Button[numChans];
        firstColumnTextfields = new Textfield[numChans];
        secondColumnTextfields = new Textfield[numChans];
        filterTypeDropdowns = new ScrollableList[numChans];
        filterOrderDropdowns = new ScrollableList[numChans];
        firstColumnTextfieldWasActive = new boolean[numChans];
        secondColumnTextfieldWasActive = new boolean[numChans];
        filterSettingsWereModified = new boolean[numChans];
        filterSettingsWereModifiedFadeCounter = new int[numChans];

        fixedWidth = (headerObjWidth * 6) + sm_spacer*5;
        maxHeight = headerHeight*3 + sm_spacer*(numChans+5) + uiObjectHeight*(numChans+2) + expanderH;
        shortHeight = headerHeight*2 + sm_spacer*(1+5) + uiObjectHeight*(1+2) + lg_spacer + expanderH;
        variableHeight = shortHeight;
        //Include spacer on the outside left and right of all columns. Used to draw visual feedback
        widthOfAllChannelColumns = headerObjWidth*numColumns + lg_spacer*(numColumns-1) + lg_spacer*2;
    }

    @Override
    public void run() {
        PApplet.runSketch(new String[] {headerMessage}, this);
    }

    @Override public 
    void settings() {
        size(fixedWidth, variableHeight);
    }

    @Override public 
    void setup() {
        surface.setTitle(headerMessage);
        surface.setAlwaysOnTop(false);
        surface.setResizable(false);

        Frame frame = ( (PSurfaceAWT.SmoothCanvas) ((PSurfaceAWT)surface).getNative()).getFrame();
        frame.toFront();
        frame.requestFocus();

        cp5 = new ControlP5(this);
        cp5.setGraphics(this, 0, 0);
        cp5.setAutoDraw(false);

        createAllCp5Objects();
    }

    @Override public 
    void draw() {

        // Important: Reset the CP5 graphics reference points X,Y,W,H at the beginning of the next draw after screen has been resized.
        // Otherwise, the numbers are wrong.
        if (needToResetCp5Graphics) {
            variableHeight = height;
            arrangeAllObjectsXY();
            cp5.setGraphics(this, 0, 0);
        }

        if (needToResizePopup) {
            // Resize the window. Reset the CP5 graphics at the beginning of the next draw().
            surface.setSize(fixedWidth, newVariableHeight);
            needToResizePopup = false;
            needToResetCp5Graphics = true;
        }

        checkIfSessionWasClosed();
        checkIfSettingsWereLoaded();

        final int w = fixedWidth;
        final int h = variableHeight;

        pushStyle();

        // Draw background
        background(backgroundColor);

        // Draw visual feedback that a channel was modified
        // When a user interacts with an object for a channel, it will highlight blue and fade out
        if (masterFilterSettingWasModified) {
            // Fade out the color alpha value from 190 to 0 over time (ex. 1 second)
            int timeDelta = millis() - masterFilterSettingWasModifiedFadeCounter;
            int alphaFadeValue = (int)map(timeDelta, 0, filterSettingWasModifiedFadeTime, 190, 0);
            fill(color(57, 128, 204, alphaFadeValue)); //light blue from TopNav
            noStroke();
            rect(columnObjX[0] - lg_spacer, (int)masterOnOffButton.getPosition()[1] - (int)sm_spacer/2, widthOfAllChannelColumns, uiObjectHeight + sm_spacer);
            if (timeDelta > filterSettingWasModifiedFadeTime) {
                masterFilterSettingWasModified = false;
            }
        }
        
        for (int i = 0; i < filterSettings.getChannelCount(); i++) {
            if (filterSettingsWereModified[i]) {
                int timeDelta = millis() - filterSettingsWereModifiedFadeCounter[i];
                // Fade the color alpha value from 190 to 0
                int alphaFadeValue = (int)map(timeDelta, 0, filterSettingWasModifiedFadeTime, 190, 0);
                fill(color(57, 128, 204, alphaFadeValue)); //light blue from TopNav
                noStroke();
                rect(columnObjX[0] - lg_spacer, (int)onOffButtons[i].getPosition()[1] - (int)sm_spacer/2, widthOfAllChannelColumns, uiObjectHeight + sm_spacer);
                if (timeDelta > filterSettingWasModifiedFadeTime) {
                    filterSettingsWereModified[i] = false;
                }
            }
        }
        
        // Draw header
        noStroke();
        fill(headerColor);
        rect(0, 0, width, headerHeight);

        // Draw Channel Expander
        lockExpanderOnOverlapCheck(cp5ElementsToCheck);
        expanderIsHover = mouseY > expanderY - expanderH/2
            && mouseX < expanderX + expanderW
            && mouseY < expanderY + expanderH/2
            && mouseX > expanderX
            && !ignoreExpanderInteraction;
        int expanderColor = expanderIsHover ? OPENBCI_BLUE : color(102);
        int[] triXY = filterSettings.values.filterChannelSelect == FilterChannelSelect.ALL_CHANNELS ?
            expanderTriangleXYCollapsed :
            expanderTriangleXYExpanded;
        stroke(expanderColor);
        fill(expanderColor);
        line(expanderX, expanderY, expanderLineOneEnd, expanderY);
        line(expanderLineTwoStart, expanderY, expanderX + expanderW - 1, expanderY);
        textAlign(CENTER, TOP);
        textFont(p6, 10);
        StringBuilder expanderString = new StringBuilder();
        expanderString.append(filterSettings.values.filterChannelSelect == FilterChannelSelect.ALL_CHANNELS ? "Show " : "Hide ");
        expanderString.append("Channels");
        int expanderTextWidth = (int)textWidth(expanderString.toString()) + 4;
        text(expanderString.toString(), middle - expanderTextWidth/2, expanderY - expanderH/2 - 2, expanderTextWidth, expanderH);
        noStroke();
        triangle(triXY[0], triXY[1], triXY[2], triXY[3], triXY[4], triXY[5]);
        
        // Draw text labels
        textFont(p3, 16);
        textAlign(RIGHT, TOP);
        // Header labels
        fill(WHITE);
        text("Filter", headerObjX[0], headerObjY, headerObjWidth, uiObjectHeight);
        text("Notch", headerObjX[2], headerObjY, headerObjWidth, uiObjectHeight);
        // Column labels
        textAlign(CENTER, TOP);
        fill(102);
        text("Channel", columnObjX[0], headerHeight + sm_spacer, textfieldWidth, headerHeight);
        String firstColumnHeader = "";
        String secondColumnHeader = "";
        if (filterSettings.values.brainFlowFilter == BFFilter.BANDPASS) {
            firstColumnHeader = "Start (Hz)";
            secondColumnHeader = "Stop (Hz)";
        } else if (filterSettings.values.brainFlowFilter == BFFilter.BANDSTOP) {
            firstColumnHeader = "Start (Hz)";
            secondColumnHeader = "Stop (Hz)";
        }
        text(firstColumnHeader, columnObjX[1], headerHeight + sm_spacer, textfieldWidth, headerHeight);
        text(secondColumnHeader, columnObjX[2], headerHeight + sm_spacer, textfieldWidth, headerHeight);
        text("Type", columnObjX[3], headerHeight + sm_spacer, textfieldWidth, headerHeight);
        text("Order", columnObjX[4], headerHeight + sm_spacer, textfieldWidth, headerHeight);
        
        popStyle();
        
        // Catch an exception that only really happens when trying to close the Filter UI.
        // This is the only class that has write access to FilterSettings.
        // No other Classes have access to the private Cp5 objects in this class.
        try {
            cp5.draw();
        } catch (Exception e) {
            //println(e.getMessage());
            println("Caught ConcurrentModificationExcpetion in Filter UI...");
        }
        
    }

    @Override public 
    void mousePressed() {
        if (expanderIsHover) {
            filterSettings.values.filterChannelSelect = 
                filterSettings.values.filterChannelSelect == FilterChannelSelect.CUSTOM_CHANNELS ?
                FilterChannelSelect.ALL_CHANNELS :
                FilterChannelSelect.CUSTOM_CHANNELS;
            setUItoChannelMode(filterSettings.values.filterChannelSelect);
        }
    }

    @Override public 
    void mouseReleased() {

    }

    @Override public 
    void exit() {
        dispose();
        filterUIPopupIsOpen = false;
    }

    private void checkIfSessionWasClosed() {
        if (systemMode == SYSTEMMODE_PREINIT) {
            noLoop();
            Frame frame = ( (PSurfaceAWT.SmoothCanvas) ((PSurfaceAWT)surface).getNative()).getFrame();
            frame.dispose();
            exit();
        }
    }

    private void checkIfSettingsWereLoaded() {
        if (filterSettingsWereLoadedFromFile) {
            try {
                updateHeaderCp5Objects();
                updateChannelCp5Objects();
                setUItoChannelMode(filterSettings.values.filterChannelSelect);
            } catch (Exception e) {
                println(e.getMessage());
                outputError("Filter Settings: Unable to apply settings. Please save Filter Settings to a new file.");
            }
            filterSettingsWereLoadedFromFile = false;
        }   
    }

    private void createAllCp5Objects() {
        calculateXYForHeaderColumnsAndFooter();
        
        createFilterSettingsSaveButton("saveFilterSettingsButton", "Save", footerObjX[0], footerObjY, headerObjWidth, uiObjectHeight);
        createFilterSettingsLoadButton("loadFilterSettingsButton", "Load", footerObjX[1], footerObjY, headerObjWidth, uiObjectHeight);
        createFilterSettingsDefaultButton("defaultFilterSettingsButton", "Reset", footerObjX[2], footerObjY, headerObjWidth, uiObjectHeight);
        
        createOnOffButtons();
        createTextfields();
        createTypeDropdowns();
        createOrderDropdowns();

        // Create header objects last so they always draw on top!
        bfGlobalFilterDropdown = createDropdown("filter", -1, headerObjX[1], headerObjY, headerObjWidth, filterSettings.values.brainFlowFilter, BFFilter.values());
        bfEnvironmentalNoiseDropdown = createDropdown("environmentalFilter", -1, headerObjX[3], headerObjY, headerObjWidth - 10, filterSettings.values.globalEnvFilter, GlobalEnvironmentalFilter.values());
        cp5ElementsToCheck.add(bfGlobalFilterDropdown);
        cp5ElementsToCheck.add(bfEnvironmentalNoiseDropdown);
        
        updateChannelCp5Objects();
        arrangeAllObjectsXY();
        setUItoChannelMode(filterSettings.values.filterChannelSelect);
    }

    private void updateHeaderCp5Objects() {
        bfGlobalFilterDropdown.getCaptionLabel().setText(filterSettings.values.brainFlowFilter.getString());
        bfEnvironmentalNoiseDropdown.getCaptionLabel().setText(filterSettings.values.globalEnvFilter.getString());
    }

    private void calculateXYForHeaderColumnsAndFooter() {
        middle = width / 2;

        headerObjX[0] = middle - sm_spacer*2 - headerObjWidth*2;
        headerObjX[1] = middle - sm_spacer - headerObjWidth;
        headerObjX[2] = middle + sm_spacer - halfObjWidth;
        headerObjX[3] = middle + sm_spacer*2 + headerObjWidth - halfObjWidth;
        
        columnObjX[0] = middle - halfObjWidth - lg_spacer*2 - headerObjWidth*2;
        columnObjX[1] = middle - halfObjWidth - lg_spacer - headerObjWidth;
        columnObjX[2] = middle - halfObjWidth;
        columnObjX[3] = middle + halfObjWidth + lg_spacer;
        columnObjX[4] = middle + halfObjWidth + lg_spacer*2 + headerObjWidth;

        footerObjX[0] = middle - halfObjWidth - lg_spacer - headerObjWidth;
        footerObjX[1] = middle - halfObjWidth;
        footerObjX[2] = middle + halfObjWidth + lg_spacer;
        setFooterObjYPosition(filterSettings.values.filterChannelSelect);

        expanderLineOneEnd = middle - expanderBreakMiddle/2;
        expanderLineTwoStart = middle + expanderBreakMiddle/2;
    }

    public void arrangeAllObjectsXY() {
        calculateXYForHeaderColumnsAndFooter();

        bfGlobalFilterDropdown.setPosition(headerObjX[1], headerObjY);
        bfEnvironmentalNoiseDropdown.setPosition(headerObjX[3], headerObjY);

        int rowY = (int)masterOnOffButton.getPosition()[1];
        int onOffButtonNewX = columnObjX[0] + textfieldWidth/2 - onOff_diameter/2;
        int filterOrderDropdownNewX = columnObjX[4] + textfieldWidth/2 - orderDropdownWidth/2;
        masterOnOffButton.setPosition(onOffButtonNewX, rowY);
        masterFirstColumnTextfield.setPosition(columnObjX[1], rowY);
        masterSecondColumnTextfield.setPosition(columnObjX[2], rowY);
        masterFilterTypeDropdown.setPosition(columnObjX[3], rowY);
        masterFilterOrderDropdown.setPosition(filterOrderDropdownNewX, rowY);

        expanderX = columnObjX[0] - lg_spacer;
        expanderY = (int)masterOnOffButton.getPosition()[1] + uiObjectHeight + sm_spacer + expanderH/2; 
        expanderW = widthOfAllChannelColumns;

        expanderTriangleXYExpanded[0] = expanderX + expanderW/2 - expanderTriangleWidth/2;
        expanderTriangleXYExpanded[1] = expanderY + 2;
        expanderTriangleXYExpanded[2] = expanderX + expanderW/2;
        expanderTriangleXYExpanded[3] = expanderY + 2 + expanderTriangleHeight;
        expanderTriangleXYExpanded[4] = expanderX + expanderW/2 + expanderTriangleWidth/2;
        expanderTriangleXYExpanded[5] = expanderTriangleXYExpanded[1];

        expanderTriangleXYCollapsed[0] = expanderTriangleXYExpanded[0];
        expanderTriangleXYCollapsed[1] = expanderTriangleXYExpanded[3];
        expanderTriangleXYCollapsed[2] = expanderTriangleXYExpanded[2];
        expanderTriangleXYCollapsed[3] = expanderTriangleXYExpanded[1];
        expanderTriangleXYCollapsed[4] = expanderTriangleXYExpanded[4];
        expanderTriangleXYCollapsed[5] = expanderTriangleXYExpanded[3];

        for (int chan = 0; chan < filterSettings.getChannelCount(); chan++) {
            rowY = (int)onOffButtons[chan].getPosition()[1];
            onOffButtons[chan].setPosition(onOffButtonNewX, rowY);
            firstColumnTextfields[chan].setPosition(columnObjX[1], rowY);
            secondColumnTextfields[chan].setPosition(columnObjX[2], rowY);
            filterTypeDropdowns[chan].setPosition(columnObjX[3], rowY);
            filterOrderDropdowns[chan].setPosition(filterOrderDropdownNewX, rowY);
        }

        saveButton.setPosition(footerObjX[0], footerObjY);
        loadButton.setPosition(footerObjX[1], footerObjY);
        defaultButton.setPosition(footerObjX[2], footerObjY);
    }

    // Master method to update objects from the FilterSettings Class
    private void updateChannelCp5Objects() {

        //Reusable variables to update UI objects
        int onColor = SUBNAV_LIGHTBLUE;
        int offColor = BUTTON_PRESSED_DARKGREY;
        int updateColor = offColor;
        String firstColumnTFValue = "";
        String secondColumnTFValue = "";
        BrainFlowFilterType updateFilterType = BrainFlowFilterType.BUTTERWORTH;
        BrainFlowFilterOrder updateFilterOrder = BrainFlowFilterOrder.TWO;

        //Update master control UI objects in the "ALL" channel
        switch (filterSettings.values.brainFlowFilter) {
            case BANDSTOP:
                if (filterSettings.values.masterBandStopFilterActive == FilterActiveOnChannel.ON) {
                    updateColor = onColor;
                }
                firstColumnTFValue = df.format(filterSettings.values.masterBandStopStartFreq);
                secondColumnTFValue = df.format(filterSettings.values.masterBandStopStopFreq);
                updateFilterType = filterSettings.values.masterBandStopFilterType;
                updateFilterOrder = filterSettings.values.masterBandStopFilterOrder;
                break;
            case BANDPASS:
                if (filterSettings.values.masterBandPassFilterActive == FilterActiveOnChannel.ON) {
                    updateColor = onColor;
                }
                firstColumnTFValue = df.format(filterSettings.values.masterBandPassStartFreq);
                secondColumnTFValue = df.format(filterSettings.values.masterBandPassStopFreq);
                updateFilterType = filterSettings.values.masterBandPassFilterType;
                updateFilterOrder = filterSettings.values.masterBandPassFilterOrder;
                break;
        }
        masterOnOffButton.setColorBackground(updateColor);
        masterFirstColumnTextfield.setText(firstColumnTFValue);
        masterSecondColumnTextfield.setText(secondColumnTFValue);
        masterFilterTypeDropdown.getCaptionLabel().setText(updateFilterType.getString());
        masterFilterOrderDropdown.getCaptionLabel().setText(updateFilterOrder.getString());
        
        // Update UI objects for all channels
        for (int chan = 0; chan < filterSettings.getChannelCount(); chan++) {
            //Use same channel colors as the rest of the GUI for onOff buttons
            onColor = channelColors[chan%8];
            switch (filterSettings.values.brainFlowFilter) {
                case BANDSTOP:
                    //Fetch on/off button color
                    if (filterSettings.values.bandStopFilterActive[chan].isActive()) {
                        updateColor = onColor;
                    } else {
                        updateColor = offColor;
                    }
                    //Fetch filter values
                    firstColumnTFValue = df.format(filterSettings.values.bandStopStartFreq[chan]);
                    secondColumnTFValue = df.format(filterSettings.values.bandStopStopFreq[chan]);
                    //Fetch filter type
                    updateFilterType = filterSettings.values.bandStopFilterType[chan];
                    //Fetch order
                    updateFilterOrder = filterSettings.values.bandStopFilterOrder[chan];
                    break;
                case BANDPASS:
                    //Fetch on/off button color
                    if (filterSettings.values.bandPassFilterActive[chan].isActive()) {
                        updateColor = onColor;
                    }
                    //Fetch filter values
                    firstColumnTFValue = df.format(filterSettings.values.bandPassStartFreq[chan]);
                    secondColumnTFValue = df.format(filterSettings.values.bandPassStopFreq[chan]);
                    //Fetch filter type
                    updateFilterType = filterSettings.values.bandPassFilterType[chan];
                    //Fetch order
                    updateFilterOrder = filterSettings.values.bandPassFilterOrder[chan];
                    break;
            }

            //Apply changes to UI objects after fetching data
            onOffButtons[chan].setColorBackground(updateColor);
            firstColumnTextfields[chan].setText(firstColumnTFValue);
            secondColumnTextfields[chan].setText(secondColumnTFValue);
            filterTypeDropdowns[chan].getCaptionLabel().setText(updateFilterType.getString());
            filterOrderDropdowns[chan].getCaptionLabel().setText(updateFilterOrder.getString());

        }
    }

    private void createOnOffButtons() {
        createMasterOnOffButton("masterOnOffButton", "All", lg_spacer + textfieldWidth/2 - onOff_diameter/2, headerHeight*2 + sm_spacer, onOff_diameter, onOff_diameter);
        for (int chan = 0; chan < filterSettings.getChannelCount(); chan++) {
            createOnOffButton("onOffButton"+chan, str(chan+1), chan, lg_spacer + textfieldWidth/2 - onOff_diameter/2, headerHeight*2 + sm_spacer*(chan+3) + onOff_diameter*(chan+1) + expanderH, onOff_diameter, onOff_diameter);
        }
    }

    private void createOnOffButton(String name, final String text, final int chan, int _x, int _y, int _w, int _h) {
        onOffButtons[chan] = createButton(cp5, name, text, _x, _y, _w, _h, 0, h2, 16, channelColors[chan%8], WHITE, BUTTON_HOVER, BUTTON_PRESSED, (Integer) null, -2);
        onOffButtons[chan].setCircularButton(true);
        onOffButtons[chan].onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                //println("[" + text + "] onOff released");
                switch (filterSettings.values.brainFlowFilter) {
                    case BANDSTOP:
                        if (filterSettings.values.bandStopFilterActive[chan].isActive()) {
                            filterSettings.values.bandStopFilterActive[chan] = FilterActiveOnChannel.OFF;
                            onOffButtons[chan].setColorBackground(BUTTON_PRESSED_DARKGREY);
                        } else {
                            filterSettings.values.bandStopFilterActive[chan] = FilterActiveOnChannel.ON;
                            onOffButtons[chan].setColorBackground(channelColors[chan%8]);
                        }
                        break;
                    case BANDPASS:
                        if (filterSettings.values.bandPassFilterActive[chan].isActive()) {
                            filterSettings.values.bandPassFilterActive[chan] = FilterActiveOnChannel.OFF;
                            onOffButtons[chan].setColorBackground(BUTTON_PRESSED_DARKGREY);
                        } else {
                            filterSettings.values.bandPassFilterActive[chan] = FilterActiveOnChannel.ON;
                            onOffButtons[chan].setColorBackground(channelColors[chan%8]);
                        }
                        break;
                }
                filterSettingWasModifiedOnChannel(chan);
                //printArray(filterSettings.values.bandStopFilterActive);
                //printArray(filterSettings.values.bandPassFilterActive);
            }
        });
    }

    private void createTextfields() {
        masterFirstColumnTextfield = createMasterColumnTextfield("masterFirstColumnTextfield", 0, lg_spacer*2 + headerObjWidth, headerHeight*2 + sm_spacer, headerObjWidth, uiObjectHeight);
        masterSecondColumnTextfield = createMasterColumnTextfield("masterSecondColumnTextfield", 0, lg_spacer*3 + headerObjWidth*2, headerHeight*2 + sm_spacer, headerObjWidth, uiObjectHeight);
        for (int chan = 0; chan < filterSettings.getChannelCount(); chan++) {
            firstColumnTextfields[chan] = createChannelTextfield("firstColumnTextfield"+chan, chan, 0, lg_spacer*2 + headerObjWidth, headerHeight*2 + sm_spacer*(chan+2) + uiObjectHeight*(chan+1), headerObjWidth, uiObjectHeight);
            secondColumnTextfields[chan] = createChannelTextfield("secondColumnTextfield"+chan, chan, 0, lg_spacer*3 + headerObjWidth*2, headerHeight*2 + sm_spacer*(chan+2) + uiObjectHeight*(chan+1), headerObjWidth, uiObjectHeight);
        }
    }

    private Textfield createTextfield(final String name, int intValue, int _x, int _y, int _w, int _h) {
        //Create these textfields under cp5_widget base instance so because they are always visible
        final Textfield myTextfield = cp5.addTextfield(name)
            .setPosition(_x, _y)
            .setCaptionLabel("")
            .setSize(_w, _h)
            .setFont(createFont("Arial",12,true))
            .setFocus(false)
            .setColor(color(26, 26, 26))
            .setColorBackground(color(255, 255, 255)) // text field bg color
            .setColorValueLabel(OPENBCI_DARKBLUE)  // text color
            .setColorForeground(color(210))  // border color when not selected - grey
            .setColorActive(isSelected_color)  // border color when selected - green
            .setColorCursor(color(26, 26, 26))
            .setText(Integer.toString(intValue)) //set the text
            .align(5, 10, 20, 40)
            .setAutoClear(false)
            .setIsCentered(true)
            ; //Don't clear textfield when pressing Enter key
        myTextfield.getValueLabel().align(CENTER, CENTER);
        //Clear textfield on double click
        myTextfield.onDoublePress(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                output("Custom Filtering: Enter your custom filter frequency.");
                myTextfield.clear();
            }
        });
        return myTextfield;
    }

    private Textfield createMasterColumnTextfield(final String name, int intValue, int _x, int _y, int _w, int _h) {
        final Textfield myTextfield = createTextfield(name, intValue, _x, _y, _w, _h);
        //Autogenerate session name if user presses Enter key and textfield value is null
        myTextfield.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                float myTextfieldValue = 0;
                boolean isFirstColumn = name.startsWith("masterFirstColumn");
                //TODO: Set to default value if the textfield would be blank
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST && myTextfield.getText().equals("")) {
                    myTextfieldValue = getDefaultMasterFilterValueAsInt(isFirstColumn);
                    setMasterFilterValueFromTextfield(isFirstColumn, myTextfieldValue);
                }
                //Pressing ENTER in the Textfield triggers a "Broadcast"
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                    //Try to clean up typing accidents from user input in Textfield
                    String rcvString = theEvent.getController().getStringValue().replaceAll("[A-Za-z!@#$%^&()=/*_]","");
                    myTextfieldValue = NumberUtils.toFloat(rcvString);
                    if (myTextfieldValue <= 0) {
                        myTextfieldValue = 0; //Only positive values will be used here
                    }
                    String valToSet = df.format(myTextfieldValue);
                    myTextfield.setText(valToSet);
                    setMasterFilterValueFromTextfield(isFirstColumn, myTextfieldValue);
                }
                if (myTextfield.isActive()) {
                    if (isFirstColumn) {
                        masterFirstColumnTextfieldWasActive = true; 
                    } else {
                        masterSecondColumnTextfieldWasActive = true;
                    }
                }
            }
        });
        //Autogenerate session name if user leaves textfield and value is null
        myTextfield.onReleaseOutside(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                boolean isFirstColumn = name.startsWith("masterFirstColumn");
                if (!myTextfield.isActive() && myTextfield.getText().equals("")) {
                    float myTextfieldValue = getDefaultMasterFilterValueAsInt(isFirstColumn);
                    String valToSet = df.format(myTextfieldValue);
                    myTextfield.setText(valToSet);
                    setMasterFilterSettingWasModified();
                } else {
                    /// If released outside textfield and a state change has occured, submit, clean, and set the value
                    if (isFirstColumn) {
                        if (masterFirstColumnTextfieldWasActive != masterFirstColumnTextfield.isActive()) {
                            myTextfield.submit();
                            masterFirstColumnTextfieldWasActive = false;
                        }
                    } else {
                        if (masterSecondColumnTextfieldWasActive != masterSecondColumnTextfield.isActive()) {
                            myTextfield.submit();
                            masterSecondColumnTextfieldWasActive = false;
                        }
                    }
                }
            }
        });
        return myTextfield;
    }

    private Textfield createChannelTextfield(final String name, final int channel, int intValue, int _x, int _y, int _w, int _h) {
        final Textfield myTextfield = createTextfield(name, intValue, _x, _y, _w, _h);
        //Autogenerate session name if user presses Enter key and textfield value is null
        myTextfield.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                float myTextfieldValue = 0;
                boolean isFirstColumn = name.startsWith("firstColumn");
                //TODO: Set to default value if the textfield would be blank
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST && myTextfield.getText().equals("")) {
                    myTextfieldValue = getDefaultFilterValueAsInt(isFirstColumn, channel);
                    setFilterValueFromTextfield(isFirstColumn, channel, myTextfieldValue);
                }
                //Pressing ENTER in the Textfield triggers a "Broadcast"
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                    //Try to clean up typing accidents from user input in Textfield
                    String rcvString = theEvent.getController().getStringValue().replaceAll("[A-Za-z!@#$%^&()=/*_]","");
                    myTextfieldValue = NumberUtils.toFloat(rcvString);
                    if (myTextfieldValue <= 0) {
                        myTextfieldValue = 0; //Only positive values will be used here
                    }
                    String valToSet = df.format(myTextfieldValue);
                    myTextfield.setText(valToSet);
                    setFilterValueFromTextfield(isFirstColumn, channel, myTextfieldValue);
                }
                if (myTextfield.isActive()) {
                    if (isFirstColumn) {
                        firstColumnTextfieldWasActive[channel] = true; 
                    } else {
                        secondColumnTextfieldWasActive[channel] = true;
                    }
                }
            }
        });
        //Autogenerate session name if user leaves textfield and value is null
        myTextfield.onReleaseOutside(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                boolean isFirstColumn = name.startsWith("firstColumn");
                if (!myTextfield.isActive() && myTextfield.getText().equals("")) {
                    float myTextfieldValue = getDefaultFilterValueAsInt(isFirstColumn, channel);
                    String valToSet = df.format(myTextfieldValue);
                    myTextfield.setText(valToSet);
                    filterSettingWasModifiedOnChannel(channel);
                } else {
                    /// If released outside textfield and a state change has occured, submit, clean, and set the value
                    if (isFirstColumn) {
                        if (firstColumnTextfieldWasActive[channel] != firstColumnTextfields[channel].isActive()) {
                            myTextfield.submit();
                            firstColumnTextfieldWasActive[channel] = false;
                        }
                    } else {
                        if (secondColumnTextfieldWasActive[channel] != secondColumnTextfields[channel].isActive()) {
                            myTextfield.submit();
                            secondColumnTextfieldWasActive[channel] = false;
                        }
                    }
                }
            }
        });
        return myTextfield;
    }

    private float getDefaultMasterFilterValueAsInt(boolean isFirstColumn) {
        double val = 0;
        switch (filterSettings.values.brainFlowFilter) {
            case BANDSTOP:
                if (isFirstColumn) {
                    val = filterSettings.defaultValues.masterBandStopStartFreq;
                } else {
                    val = filterSettings.defaultValues.masterBandStopStopFreq;
                }
                break;
            case BANDPASS:
                if (isFirstColumn) {
                    val = filterSettings.defaultValues.masterBandPassStartFreq;
                } else {
                    val = filterSettings.defaultValues.masterBandPassStopFreq;
                }
                break;
        }
        float valAsFloat = (float)val;
        return valAsFloat;
    }

    private void setMasterFilterValueFromTextfield(boolean isFirstColumn, float val) {
        Double valAsDouble = Double.valueOf(val);
        switch (filterSettings.values.brainFlowFilter) {
            case BANDSTOP:
                if (isFirstColumn) {
                    filterSettings.values.masterBandStopStartFreq = valAsDouble;
                    Arrays.fill(filterSettings.values.bandStopStartFreq, filterSettings.values.masterBandStopStartFreq);
                } else {
                    filterSettings.values.masterBandStopStopFreq = valAsDouble;
                    Arrays.fill(filterSettings.values.bandStopStopFreq, filterSettings.values.masterBandStopStopFreq);
                }
                break;
            case BANDPASS:
                if (isFirstColumn) {
                    filterSettings.values.masterBandPassStartFreq = valAsDouble;
                    Arrays.fill(filterSettings.values.bandPassStartFreq, filterSettings.values.masterBandPassStartFreq);
                } else {
                    filterSettings.values.masterBandPassStopFreq = valAsDouble;
                    Arrays.fill(filterSettings.values.bandPassStopFreq, filterSettings.values.masterBandPassStopFreq);
                }
                break;
        }
        updateChannelCp5Objects();
        setMasterFilterSettingWasModified();
        //println(isFirstColumn, chan, val);
        //printArray(filterSettings.values.bandPassStartFreq);
        //printArray(filterSettings.values.bandPassStopFreq);
    }

    private float getDefaultFilterValueAsInt(boolean isFirstColumn, int chan) {
        double val = 0;
        switch (filterSettings.values.brainFlowFilter) {
            case BANDSTOP:
                if (isFirstColumn) {
                    val = filterSettings.defaultValues.bandStopStartFreq[chan];
                } else {
                    val = filterSettings.defaultValues.bandStopStopFreq[chan];
                }
                break;
            case BANDPASS:
                if (isFirstColumn) {
                    val = filterSettings.defaultValues.bandPassStartFreq[chan];
                } else {
                    val = filterSettings.defaultValues.bandPassStopFreq[chan];
                }
                break;
        }
        float valAsFloat = (float)val;
        return valAsFloat;
    }
    
    private void setFilterValueFromTextfield(boolean isFirstColumn, int chan, float val) {
        Double valAsDouble = Double.valueOf(val);
        switch (filterSettings.values.brainFlowFilter) {
            case BANDSTOP:
                if (isFirstColumn) {
                    filterSettings.values.bandStopStartFreq[chan] = valAsDouble;
                } else {
                    filterSettings.values.bandStopStopFreq[chan] = valAsDouble;
                }
                break;
            case BANDPASS:
                if (isFirstColumn) {
                    filterSettings.values.bandPassStartFreq[chan] = valAsDouble;
                } else {
                    filterSettings.values.bandPassStopFreq[chan] = valAsDouble;
                }
                break;
        }
        filterSettingWasModifiedOnChannel(chan);
        //println(isFirstColumn, chan, val);
        //printArray(filterSettings.values.bandPassStartFreq);
        //printArray(filterSettings.values.bandPassStopFreq);
    }

    private ScrollableList createDropdown(String name, final int chan, int _x, int _y, int _w, FilterSettingsEnum e, FilterSettingsEnum[] eValues) {
        int dropdownH = uiObjectHeight;
        ScrollableList list = cp5.addScrollableList(name)
            .setPosition(_x, _y)
            .setOpen(false)
            .setColorBackground(WHITE) // text field bg color
            .setColorValueLabel(OPENBCI_DARKBLUE)       // text color
            .setColorCaptionLabel(OPENBCI_DARKBLUE)
            .setColorForeground(color(125))    // border color when not selected
            .setColorActive(BUTTON_PRESSED)       // border color when selected
            .setOutlineColor(OBJECT_BORDER_GREY)
            .setSize(_w, dropdownH * (eValues.length + 1))//temporary size
            .setBarHeight(dropdownH) //height of top/primary bar
            .setItemHeight(dropdownH) //height of all item/dropdown bars
            .setVisible(true)
            ;
        // for each entry in the enum, add it to the dropdown.
        for (FilterSettingsEnum value : eValues) {
            // this will store the *actual* enum object inside the dropdown!
            list.addItem(value.getString(), value);
        }
        //Style the text in the ScrollableList
        list.getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(e.getString())
            .setFont(h5)
            .setSize(12)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        list.getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(e.getString())
            .setFont(p6)
            .setSize(10) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
        list.addCallback(new SLCallbackListener(chan));
        return list;
    }

    private class SLCallbackListener implements CallbackListener {
        private int chan;
        SLCallbackListener(int _chan)  {
            chan = _chan;
        }
        public void controlEvent(CallbackEvent theEvent) {
            //Selecting an item from ScrollableList triggers Broadcast
            if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) { 
                int val = (int)(theEvent.getController()).getValue();
                Map bob = ((ScrollableList)theEvent.getController()).getItem(val);
                FilterSettingsEnum myEnum = (FilterSettingsEnum)bob.get("value");
                //println("FilterSettings: " + (theEvent.getController()).getName() + " == " + myEnum.getString());

                if (theEvent.getController().getName().startsWith("masterFilter")) {
                    if (myEnum instanceof BrainFlowFilterType) {
                        switch (filterSettings.values.brainFlowFilter) {
                            case BANDSTOP:
                                filterSettings.values.masterBandStopFilterType = (BrainFlowFilterType)myEnum;
                                Arrays.fill(filterSettings.values.bandStopFilterType, filterSettings.values.masterBandStopFilterType);
                                break;
                            case BANDPASS:
                                filterSettings.values.masterBandPassFilterType = (BrainFlowFilterType)myEnum;
                                Arrays.fill(filterSettings.values.bandPassFilterType, filterSettings.values.masterBandPassFilterType);
                                break;
                        }
                    } else if (myEnum instanceof BrainFlowFilterOrder) {
                        switch (filterSettings.values.brainFlowFilter) {
                            case BANDSTOP:
                                filterSettings.values.masterBandStopFilterOrder = (BrainFlowFilterOrder)myEnum;
                                Arrays.fill(filterSettings.values.bandStopFilterOrder, filterSettings.values.masterBandStopFilterOrder);
                                break;
                            case BANDPASS:
                                filterSettings.values.masterBandPassFilterOrder = (BrainFlowFilterOrder)myEnum;
                                Arrays.fill(filterSettings.values.bandPassFilterOrder, filterSettings.values.masterBandPassFilterOrder);
                                break;
                        }
                    }
                    updateChannelCp5Objects();
                    setMasterFilterSettingWasModified();
                    return;
                }

                if (myEnum instanceof BFFilter) {
                    filterSettings.values.brainFlowFilter = (BFFilter)myEnum;
                    updateChannelCp5Objects();
                } else if (myEnum instanceof GlobalEnvironmentalFilter) {
                    filterSettings.values.globalEnvFilter = (GlobalEnvironmentalFilter)myEnum;
                } else if (myEnum instanceof BrainFlowFilterType) {
                    switch (filterSettings.values.brainFlowFilter) {
                        case BANDSTOP:
                            filterSettings.values.bandStopFilterType[chan] = (BrainFlowFilterType)myEnum;
                            break;
                        case BANDPASS:
                            filterSettings.values.bandPassFilterType[chan] = (BrainFlowFilterType)myEnum;
                            break;
                    }
                    filterSettingWasModifiedOnChannel(chan);
                } else if (myEnum instanceof BrainFlowFilterOrder) {
                    switch (filterSettings.values.brainFlowFilter) {
                        case BANDSTOP:
                            filterSettings.values.bandStopFilterOrder[chan] = (BrainFlowFilterOrder)myEnum;
                            break;
                        case BANDPASS:
                            filterSettings.values.bandPassFilterOrder[chan] = (BrainFlowFilterOrder)myEnum;
                            break;
                    }
                    filterSettingWasModifiedOnChannel(chan);
                }
            }
        }
    }

    private void createTypeDropdowns() {
        //Make these dropdowns in reverse so the top ones draw above the lower ones
        for (int chan = filterSettings.getChannelCount() - 1; chan >= 0; chan--) {
            filterTypeDropdowns[chan] = createDropdown("filterType"+chan, chan, lg_spacer*4 + textfieldWidth*3, headerHeight*2 + sm_spacer*(chan+2) + uiObjectHeight*(chan+1), typeDropdownWidth, filterSettings.values.masterBandPassFilterType, BrainFlowFilterType.values());
        }
        masterFilterTypeDropdown = createDropdown("masterFilterTypeDropdown", -1, lg_spacer*4 + textfieldWidth*3, headerHeight*2 + sm_spacer, typeDropdownWidth, filterSettings.values.masterBandPassFilterType, BrainFlowFilterType.values());
        cp5ElementsToCheck.add(masterFilterTypeDropdown);
    }

    private void createOrderDropdowns() {
        for (int chan = filterSettings.getChannelCount() - 1; chan >= 0; chan--) {
            filterOrderDropdowns[chan] = createDropdown("filterOrder"+chan, chan, lg_spacer*5 + textfieldWidth*3 + typeDropdownWidth, headerHeight*2 + sm_spacer*(chan+2) + uiObjectHeight*(chan+1), orderDropdownWidth, filterSettings.values.masterBandPassFilterOrder, BrainFlowFilterOrder.values());
        }
        masterFilterOrderDropdown = createDropdown("masterFilterOrderDropdown", -1, lg_spacer*5 + textfieldWidth*3 + typeDropdownWidth, headerHeight*2 + sm_spacer, orderDropdownWidth, filterSettings.values.masterBandPassFilterOrder, BrainFlowFilterOrder.values());
        cp5ElementsToCheck.add(masterFilterOrderDropdown);
    }

    private void createFilterSettingsSaveButton(String name, String text, int _x, int _y, int _w, int _h) {
        saveButton = createButton(cp5, name, text, _x, _y, _w, _h, h5, 12, colorNotPressed, OPENBCI_DARKBLUE);
        saveButton.setBorderColor(OBJECT_BORDER_GREY);
        saveButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                filterSettings.storeSettings();
            }
        });
    }

    private void createFilterSettingsLoadButton(String name, String text, int _x, int _y, int _w, int _h) {
        loadButton = createButton(cp5, name, text, _x, _y, _w, _h, h5, 12, colorNotPressed, OPENBCI_DARKBLUE);
        loadButton.setBorderColor(OBJECT_BORDER_GREY);
        loadButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                filterSettings.loadSettings();
            }
        });
    }

    private void createFilterSettingsDefaultButton(String name, String text, int _x, int _y, int _w, int _h) {
        defaultButton = createButton(cp5, name, text, _x, _y, _w, _h, h5, 12, colorNotPressed, OPENBCI_DARKBLUE);
        defaultButton.setBorderColor(OBJECT_BORDER_GREY);
        defaultButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                filterSettings.revertAllChannelsToDefaultValues();
                filterSettingsWereLoadedFromFile = true;
            }
        });
    }

    private void createMasterOnOffButton(String name, final String text, int _x, int _y, int _w, int _h) {
        masterOnOffButton = createButton(cp5, name, text, _x, _y, _w, _h, 0, h2, 16, SUBNAV_LIGHTBLUE, WHITE, BUTTON_HOVER, BUTTON_PRESSED, (Integer) null, -2);
        masterOnOffButton.setCircularButton(true);
        masterOnOffButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                //println("[" + name + "] onOff released");
                switch (filterSettings.values.brainFlowFilter) {
                    case BANDSTOP:
                        if (filterSettings.values.masterBandStopFilterActive == FilterActiveOnChannel.ON) {
                            filterSettings.values.masterBandStopFilterActive = FilterActiveOnChannel.OFF;
                            //masterOnOffButton.setColorBackground(BUTTON_PRESSED_DARKGREY);
                        } else {
                            filterSettings.values.masterBandStopFilterActive = FilterActiveOnChannel.ON;
                            //masterOnOffButton.setColorBackground(TURN_ON_GREEN);
                        }
                        //Now, update all channels based on this state
                        Arrays.fill(filterSettings.values.bandStopFilterActive, filterSettings.values.masterBandStopFilterActive);
                        break;
                    case BANDPASS:
                        if (filterSettings.values.masterBandPassFilterActive == FilterActiveOnChannel.ON) {
                            filterSettings.values.masterBandPassFilterActive = FilterActiveOnChannel.OFF;
                            //masterOnOffButton.setColorBackground(BUTTON_PRESSED_DARKGREY);
                        } else {
                            filterSettings.values.masterBandPassFilterActive = FilterActiveOnChannel.ON;
                            //masterOnOffButton.setColorBackground(TURN_ON_GREEN);
                        }
                        Arrays.fill(filterSettings.values.bandPassFilterActive, filterSettings.values.masterBandPassFilterActive);
                        break;
                }
                //Update all channel cp5 objects, including master "all" channel, with new values
                updateChannelCp5Objects();
                setMasterFilterSettingWasModified();
                //printArray(filterSettings.values.bandStopFilterActive);
                //printArray(filterSettings.values.bandPassFilterActive);
            }
        });
    }

    private void setUItoChannelMode(FilterChannelSelect myEnum) {
        int numChans = filterSettings.getChannelCount();
        boolean showAllChannels = myEnum == FilterChannelSelect.CUSTOM_CHANNELS;
        newVariableHeight =  showAllChannels ? maxHeight : shortHeight;

        for (int chan = 0; chan < numChans; chan++) {
            onOffButtons[chan].setVisible(showAllChannels);
            firstColumnTextfields[chan].setVisible(showAllChannels);
            secondColumnTextfields[chan].setVisible(showAllChannels);
            filterTypeDropdowns[chan].setVisible(showAllChannels);
            filterOrderDropdowns[chan].setVisible(showAllChannels);
        }

        setFooterObjYPosition(myEnum);
        saveButton.setPosition(footerObjX[0], footerObjY);
        loadButton.setPosition(footerObjX[1], footerObjY);

        needToResizePopup = true;
    }

    private void setFooterObjYPosition(FilterChannelSelect myEnum) {
        boolean showAllChannels = myEnum == FilterChannelSelect.CUSTOM_CHANNELS;
        int numChans = filterSettings.getChannelCount();
        int footerMaxHeightY = headerHeight*2 + sm_spacer*(numChans+4) + uiObjectHeight*(numChans+1) + lg_spacer*2 + expanderH;
        int footerMinHeightY = headerHeight*2 + sm_spacer*4 + uiObjectHeight + lg_spacer + expanderH;
        footerObjY = showAllChannels ? footerMaxHeightY : footerMinHeightY;
    }

    private void filterSettingWasModifiedOnChannel(int chan) {
        filterSettingsWereModified[chan] = true;
        filterSettingsWereModifiedFadeCounter[chan] = millis();
    }

    private void setMasterFilterSettingWasModified() {
        masterFilterSettingWasModified = true;
        masterFilterSettingWasModifiedFadeCounter = millis();
    }

    private void checkIfExpanderWasClicked() {
        setUItoChannelMode(filterSettings.values.filterChannelSelect);
    }

    private void lockExpanderOnOverlapCheck(List<controlP5.ScrollableList> listOfControllers) { 
        for (controlP5.ScrollableList c : listOfControllers) {
            if (c == null) {
                continue; //Gracefully skip over a controller if it is null
            }
            if (c.isOpen()) {
                ignoreExpanderInteraction = true;
                return;
            } else {
                ignoreExpanderInteraction = false;
            }
        }
    }
}



public class FixedStack<T> extends Stack<T> {
    private int maxSize;

    public FixedStack(int size) {
        super();
        this.maxSize = size;
    }

    public FixedStack() {
        super();
        maxSize = 1000;
    }

    // not thread safe with push but its temporary
    public void setSize(int size) {
        maxSize = size;
    }

    public void fill(T object) {
        for (int i = 0; i < maxSize; i++) {
            push(object);
        }
    }

    @Override
    public T push(T object) {
        while (this.size() >= maxSize) {
            this.remove(0);
        }
        return super.push(object);
    }
}
/// Here are the enums used by the Focus Widget, found in W_Focus.pde 

// color enums
public enum FocusColors {
    GREEN, CYAN, ORANGE
}

public enum FocusXLim implements IndexingInterface
{
    FIVE (0, 5, "5 sec"),
    TEN (1, 10, "10 sec"),
    TWENTY (2, 20, "20 sec");

    private int index;
    private int value;
    private String label;
    private static FocusXLim[] vals = values();

    FocusXLim(int _index, int _value, String _label) {
        this.index = _index;
        this.value = _value;
        this.label = _label;
    }

    public int getValue() {
        return value;
    }

    @Override
    public String getString() {
        return label;
    }

    @Override
    public int getIndex() {
        return index;
    }

    public static List<String> getEnumStringsAsList() {
        List<String> enumStrings = new ArrayList<String>();
        for (IndexingInterface val : vals) {
            enumStrings.add(val.getString());
        }
        return enumStrings;
    }
}

public enum FocusMetric implements IndexingInterface
{
    CONCENTRATION (0, "Concentration", BrainFlowMetrics.MINDFULNESS, "Concentrating"),
    RELAXATION (1, "Relaxation", BrainFlowMetrics.RESTFULNESS, "Relaxing");

    private int index;
    private String label;
    private BrainFlowMetrics metric;
    private String idealState;
    private static FocusMetric[] vals = values();

    FocusMetric(int _index, String _label, BrainFlowMetrics _metric, String _idealState) {
        this.index = _index;
        this.label = _label;
        this.metric = _metric;
        this.idealState = _idealState;
    }

    @Override
    public String getString() {
        return label;
    }

    @Override
    public int getIndex() {
        return index;
    }

    public BrainFlowMetrics getMetric() {
        return metric;
    }

    public String getIdealStateString() {
        return idealState;
    }

    public static List<String> getEnumStringsAsList() {
        List<String> enumStrings = new ArrayList<String>();
        for (IndexingInterface val : vals) {
            enumStrings.add(val.getString());
        }
        return enumStrings;
    }
}

public enum FocusClassifier implements IndexingInterface
{
    REGRESSION (0, "Regression", BrainFlowClassifiers.DEFAULT_CLASSIFIER);

    private int index;
    private int value;
    private String label;
    private BrainFlowClassifiers classifier;

    private static FocusClassifier[] vals = values();

    FocusClassifier(int _index, String _label, BrainFlowClassifiers _classifier) {
        this.index = _index;
        this.label = _label;
        this.classifier = _classifier;
    }

    @Override
    public String getString() {
        return label;
    }

    @Override
    public int getIndex() {
        return index;
    }

    public BrainFlowClassifiers getClassifier() {
        return classifier;
    }

    public static List<String> getEnumStringsAsList() {
        List<String> enumStrings = new ArrayList<String>();
        for (IndexingInterface val : vals) {
            enumStrings.add(val.getString());
        }
        return enumStrings;
    }
}

public enum FocusThreshold implements IndexingInterface
{
    FIVE_TENTHS (0, .5f, "0.5"),
    SIX_TENTHS (1, .6f, "0.6"),
    SEVEN_TENTHS (2, .7f, "0.7"),
    EIGHT_TENTHS (3, .8f, "0.8"),
    NINE_TENTHS (4, .9f, "0.9");

    private int index;
    private float value;
    private String label;

    private static FocusThreshold[] vals = values();

    FocusThreshold(int _index, float _value, String _label) {
        this.index = _index;
        this.value = _value;
        this.label = _label;
    }

    public float getValue() {
        return value;
    }

    @Override
    public String getString() {
        return label;
    }

    @Override
    public int getIndex() {
        return index;
    }

    public static List<String> getEnumStringsAsList() {
        List<String> enumStrings = new ArrayList<String>();
        for (IndexingInterface val : vals) {
            enumStrings.add(val.getString());
        }
        return enumStrings;
    }
}
/*
// EXAMPLE USAGE -- WORKS!!!!!

    String n1, n2;
    // String to copy to clipboard
    n1 = "Harry Potter";
    // Copy to clipboard
    //GClip.copy(n1);
    
    // Get clipboard contents into another string
    n2 = GClip.paste();
    // Display new string
    println(n2);
/*


/*
Part of the GUI for Processing library
    http://www.lagers.org.uk/g4p/index.html
    http://gui4processing.googlecode.com/svn/trunk/

    Copyright (c) 2008-09 Peter Lager

The actual code to create the clipbaord, copy and paste were
taken taken from a similar GUI library Interfascia ALPHA 002 --
http://superstable.net/interfascia/  produced by Brenden Berg
The main change is to provide static copy and paste methods to
separate the clipboard logic from the component logic and provide
global access.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General
Public License along with this library; if not, write to the
Free Software Foundation, Inc., 59 Temple Place, Suite 330,
Boston, MA  02111-1307  USA
*/








/*
* I wanted to implement copying and pasting to the clipboard using static
* methods to simplify the sharing of a single clipboard over all classes.
* The need to implement the ClipboardOwner interface requires an object so
* this class creates an object the first time an attempt to copy or paste
* is used.
*
* All methods are private except copy() and paste() - lostOwnership()
* has to be public because of the Clipboard owner interface.
*
* @author Peter Lager
*
*/

/**
* This provides clipboard functionality for text and is currently only used by the
* GTextField class.
*
* @author Peter Lager
*/
public static class GClip implements ClipboardOwner {
    /**
    * Static reference to enforce singleton pattern
    */
    private static GClip gclip = null;

    /**
    * Class attribute to reference the programs clipboard
    */
    private Clipboard clipboard = null;

    /**
    * Copy a string to the clipboard
    * @param chars
    */
    public static boolean copy(String chars) {
        if (gclip == null) gclip = new GClip();
        return gclip.copyString(chars);
    }

    /**
    * Get a string from the clipboard
    * @return the string on the clipboard
    */
    public static String paste() {
        if (gclip == null) gclip = new GClip();
        return gclip.pasteString();
    }

    /**
    * Ctor is private so clipboard is only created when a copy or paste is
    * attempted and one does not exist already.
    */
    private GClip() {
        if (clipboard == null) {
            makeClipboardObject();
        }
    }

    /**
    * If security permits use the system clipboard otherwise create
    * our own application clipboard.
    */
    private void makeClipboardObject() {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        try {
            ///security.checkPermission(AWTPermission("accessEventQueue"));
            clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        } catch (SecurityException e) {
            clipboard = new Clipboard("Application Clipboard");
        }
    }
    else {
        try {
            clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        } catch (Exception e) {
            // THIS IS DUMB - true but is there another way - I think not
        }
    }
    }

    /**
    * Copy a string to the clipboard. If the Clipboard has not been created
    * then create it.
    * @return true for a successful copy to clipboard
    */
    private boolean copyString(String chars) {
        if (clipboard == null) {
            makeClipboardObject();
        }
        if (clipboard != null) {
            StringSelection fieldContent = new StringSelection (chars);
            clipboard.setContents (fieldContent, this);
            return true;
        }
        return false;
    }

    /**
    * Gets a string from the clipboard. If there is no Clipboard
    * then create it.
    * @return
    */
    private String pasteString() {
        // If there is no clipboard then there is nothing to paste
        if (clipboard == null) {
            makeClipboardObject();
            return "";
        }
        // We have a clipboard so get the string if we can
        Transferable clipboardContent = clipboard.getContents(this);
        if ((clipboardContent != null) &&
            (clipboardContent.isDataFlavorSupported(DataFlavor.stringFlavor))) {
            try {
                String tempString;
                tempString = (String) clipboardContent.getTransferData(DataFlavor.stringFlavor);
                return tempString;
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
        return "";
    }

    /**
    * Reqd by ClipboardOwner interface
    */
    public void lostOwnership(Clipboard clipboard, Transferable contents) {

    }
}

class Grid {
    private int numRows;
    private int numCols;

    private int[] colOffset;
    private int[] rowOffset;
    private int rowHeight;
    private boolean horizontallyCenterTextInCells = false;
    private boolean drawTableBorder = false;
    private boolean drawTableInnerLines = true;

    private int x, y, w;
    private int pad_horiz = 5;
    private int pad_vert = 5;

    private PFont tableFont = p5;
    private int tableFontSize = 12;

    private int[][] textColors;

    private String[][] strings;

    Grid(int _numRows, int _numCols, int _rowHeight) {
        numRows = _numRows;
        numCols = _numCols;
        rowHeight = _rowHeight;

        colOffset = new int[numCols];
        rowOffset = new int[numRows];

        strings = new String[numRows][numCols];
        textColors = new int[numRows][numCols];

        int defaultTextColor = OPENBCI_DARKBLUE;
        for (int[] row: textColors) {
            Arrays.fill(row, defaultTextColor);
        }
    }

    public void draw() {
        pushStyle();
        textAlign(LEFT);        
        stroke(OPENBCI_DARKBLUE);
        textFont(p5, 12);

        if (drawTableInnerLines) {
            // draw row lines
            for (int i = 0; i < numRows - 1; i++) {
                line(x, y + rowOffset[i], x + w, y + rowOffset[i]);
            }

            // draw column lines
            for (int i = 1; i < numCols; i++) {
                line(x + colOffset[i], y, x + colOffset[i], y + rowOffset[numRows - 1]);
            }
        }

        // draw cell strings
        for (int row = 0; row < numRows; row++) {
            for (int col = 0; col < numCols; col++) {
                if (strings[row][col] != null) {
                    fill(textColors[row][col]);
                    textAlign(horizontallyCenterTextInCells ? CENTER : LEFT);
                    text(strings[row][col], x + colOffset[col] + pad_horiz, y + rowOffset[row] - pad_vert);
                }
            }
        }

        if (drawTableBorder) {
            noFill();
            stroke(OPENBCI_DARKBLUE);
            rect(x, y, w, rowOffset[numRows - 1]);
        }
        
        popStyle();
    }

    public RectDimensions getCellDims(int row, int col) {
        RectDimensions result = new RectDimensions();
        result.x = x + colOffset[col] + 1; // +1 accounts for line thickness
        result.y = y + rowOffset[row] - rowHeight;
        result.w = w / numCols - 1; // -1 account for line thickness
        result.h = rowHeight;

        return result;
    }

    public void setDim(int _x, int _y, int _w) {
        x = _x;
        y = _y;
        w = _w;
        
        final float colFraction = 1.f / numCols;

        for (int i = 0; i < numCols; i++) {
            colOffset[i] = round(w * colFraction * i);
        }

        for (int i = 0; i < numRows; i++) {
            rowOffset[i] = rowHeight * (i + 1);
        }
    }

    public void setString(String s, int row, int col) {
        strings[row][col] = s;
    }

    public void setTableFontAndSize(PFont _font, int _fontSize) {
        tableFont = _font;
        tableFontSize = _fontSize;
    }

    public void setRowHeight(int _height) {
        rowHeight = _height;
    }
    
    //This overrides the rowHeight and rowOffset when setting the total height of the Grid.
    public void setTableHeight(int _height) {
        rowHeight = _height / numRows;
        for (int i = 0; i < numRows; i++) {
            rowOffset[i] = rowHeight * (i + 1);
        }
    }

    public void setTextColor(int c, int row, int col) {
        textColors[row][col] = c;
    }

    //Change vertical padding for all cells based on the string/text height from a given cell
    public void dynamicallySetTextVerticalPadding(int row, int col) {
        float _textH = getFontStringHeight(tableFont, strings[row][col]);
        pad_vert =  PApplet.parseInt( (rowHeight - _textH) / 2); //Force round down here
    }

    public void setHorizontalCenterTextInCells(boolean b) {
        horizontallyCenterTextInCells = b;
        pad_horiz = b ? getCellDims(0,0).w/2 : 5;
    }

    public void setDrawTableBorder(boolean b) {
        drawTableBorder = b;
    }

    public void setDrawTableInnerLines(boolean b) {
        drawTableInnerLines = b;
    }
}







interface GuiSettingsEnum {
    public String getName();
}

enum ExpertModeEnum implements GuiSettingsEnum {
    ON("Active", true),
    OFF("Inactive", false);

    private String name;
    private boolean val;

    ExpertModeEnum(String _name, boolean _val) {
        this.name = _name;
        this.val = _val;
    }

    @Override
    public String getName() {
        return name;
    }

    public boolean getBooleanValue() {
        return val;
    }
}

public class GuiSettingsValues {
    public ExpertModeEnum expertMode = ExpertModeEnum.OFF;
    public boolean showCytonSmoothingPopup = true;

    public GuiSettingsValues() {
    }
}

class GuiSettings {

    private GuiSettingsValues values;
    private String filename;
    private List<String> valueKeys = Arrays.asList("expertMode", "showCytonSmoothingPopup");

    GuiSettings(String settingsDirectory) {

        values = new GuiSettingsValues();
        StringBuilder settingsFilename = new StringBuilder(settingsDirectory);
        settingsFilename.append("GuiWideSettings.json");
        filename = settingsFilename.toString();
        File fileToCheck = new File(filename);
        boolean fileExists = fileToCheck.exists();
        if (fileExists) {
            loadSettingsValues();
        } else {
            println("OpenBCI_GUI::Settings: Creating new GUI-wide Settings file.");
            saveToFile();
        }
    }

    public boolean loadSettingsValues() {
        try {

            File file = new File(filename);
            StringBuilder fileContents = new StringBuilder((int)file.length());        
            Scanner scanner = new Scanner(file);

            while(scanner.hasNextLine()) {
                fileContents.append(scanner.nextLine() + System.lineSeparator());
            }

            //Check for incompatible or old settings
            if (validateJsonKeys(fileContents.toString())) {
                Gson gson = new Gson();
                values = gson.fromJson(fileContents.toString(), GuiSettingsValues.class);
                println("OpenBCI_GUI::Settings: Found and loaded existing GUI-wide Settings from file.");
            } else {
                println("OpenBCI_GUI::Settings: Incompatible GUI-wide Settings found. Creating new file and resetting defaults.");
                saveToFile();
            }
            
            return true;

        } catch (IOException e) {
            e.printStackTrace();
            outputWarn("OpenBCI_GUI::Settings: Error loading GUI-wide settings from file. Attempting to create a new one.");
            //If there is an error, attempt to overwrite the file or create a new one
            saveToFile();
            return false;
        }      
    }

    public String getJson() {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        return gson.toJson(values);
    }

    public boolean saveToFile() {
        String json = getJson();

        try {
            final File file = new File(filename);
            final File parent_directory = file.getParentFile();

            if (null != parent_directory)
            {
                parent_directory.mkdirs();
            }
        } catch (Exception e) {
            e.printStackTrace();
            outputWarn("OpenBCI_GUI::Settings: Error creating /Documents/OpenBCI_GUI/Settings/ folder. Please make an issue on GitHub.");
            return false;
        }
 
        try {
            FileWriter writer = new FileWriter(filename);
            writer.write(json);
            writer.close();
            println("OpenBCI_GUI::Settings: Successfully saved GUI-wide settings to file!");
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            outputWarn("OpenBCI_GUI::Settings: Error saving GUI-wide settings to file. Please make an issue on GitHub.");
            return false;
        }
    }

    private boolean validateJsonKeys(String stringToSearch) {
        List<String> foundKeys = new ArrayList<String>();
        Gson gson = new Gson();
        Map<String, Object> map = gson.fromJson(stringToSearch, new TypeToken<Map<String, Object>>() {}.getType());
        for (String mapKey : map.keySet()) {
            foundKeys.add(mapKey);
        }

        Collections.sort(valueKeys);
        Collections.sort(foundKeys);

        boolean isEqual = valueKeys.equals(foundKeys);

        return isEqual;
    }

    //Call this method at the end of GUI main Setup in OpenBCI_GUI.pde to make sure everything exists
    //Has to be in this class to make sure other classes exist
    public void applySettings() {
        topNav.configSelector.toggleExpertModeFrontEnd(getExpertModeBoolean());
    }

    public void setExpertMode(ExpertModeEnum val) {
        values.expertMode = val;
        saveToFile();
    }
    
    public boolean getExpertModeBoolean() {
        return values.expertMode.getBooleanValue();
    }

    public void setShowCytonSmoothingPopup(boolean b) {
        values.showCytonSmoothingPopup = b;
        saveToFile();
    }

    public boolean getShowCytonSmoothingPopup() {
        return values.showCytonSmoothingPopup;
    }
}

interface ImpedanceSettingsBoard {

    public void setCheckingImpedance(int channel, boolean active);
    public boolean isCheckingImpedance(int channel);
    public Integer isCheckingImpedanceOnChannel();
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  This file contains all key commands for interactivity with GUI & OpenBCI
//  Created by Chip Audette, Joel Murphy, & Conor Russomanno
//  - Extracted from OpenBCI_GUI because it was getting too klunky
//  - Refactored Nov. 2020 - Richard Waltman
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

//interpret a keypress...the key pressed comes in as "key"
public synchronized void keyPressed() {
    // don't allow key presses until setup is complete and the UI is initialized
    if (!setupComplete) {
        return;
    }

    //note that the Processing variable "key" is the keypress as an ASCII character
    //note that the Processing variable "keyCode" is the keypress as a JAVA keycode.  This differs from ASCII
    //println("OpenBCI_GUI: keyPressed: key = " + key + ", int(key) = " + int(key) + ", keyCode = " + keyCode);

    //Check for Copy/Paste text keyboard shortcuts before anything else.
    if (copyPaste.checkIfPressedAllOS()) {
        return;
    }

    boolean anyActiveTextfields = textfieldUpdateHelper.getAnyTextfieldsActive();

    if(!controlPanel.isOpen && !anyActiveTextfields){ //don't parse the key if the control panel is open
        if (guiSettings.getExpertModeBoolean() || key == ' ') { //Check if Expert Mode is On or Spacebar has been pressed
            if ((PApplet.parseInt(key) >=32) && (PApplet.parseInt(key) <= 126)) {  //32 through 126 represent all the usual printable ASCII characters
                parseKey(key);
            }
        }
    }

    if(key==27){
        key=0; //disable 'esc' quitting program
    }
}

public synchronized void keyReleased() {
    copyPaste.checkIfReleasedAllOS();
}

public void parseKey(char val) {
    //assumes that val is a usual printable ASCII character (ASCII 32 through 126)
    switch (val) {
        case ' ':
            // space to start/stop the stream
            topNav.stopButtonWasPressed();
            return;
        case ',':
            drawContainers = !drawContainers;
            return;
        case '{':
            if(colorScheme == COLOR_SCHEME_DEFAULT){
                colorScheme = COLOR_SCHEME_ALTERNATIVE_A;
            } else if(colorScheme == COLOR_SCHEME_ALTERNATIVE_A) {
                colorScheme = COLOR_SCHEME_DEFAULT;
            }
            //topNav.updateNavButtonsBasedOnColorScheme();
            output("New Dark color scheme coming soon!");
            return;

        //deactivate channels 1-4
        case '1':
            currentBoard.setEXGChannelActive(1-1, false);
            return;
        case '2':
            currentBoard.setEXGChannelActive(2-1, false);
            return;
        case '3':
            currentBoard.setEXGChannelActive(3-1, false);
            return;
        case '4':
            currentBoard.setEXGChannelActive(4-1, false);
            return;

        //activate channels 1-4
        case '!':
            currentBoard.setEXGChannelActive(1-1, true);
            return;
        case '@':
            currentBoard.setEXGChannelActive(2-1, true);
            return;
        case '#':
            currentBoard.setEXGChannelActive(3-1, true);
            return;
        case '$':
            currentBoard.setEXGChannelActive(4-1, true);
            return;

        //other controls
        case 's':
            stopRunning();
            return;

        case 'b':
            startRunning();
            return;

        ///////////////////// Save User settings lowercase n
        case 'n':
            println("Interactivity: Save key pressed!");
            settings.save(settings.getPath("User", eegDataSource, nchan));
            outputSuccess("Settings Saved! Using Expert Mode, you can load these settings using 'N' key. Click \"Default\" to revert to factory settings.");
            return;

        ///////////////////// Load User settings uppercase N
        case 'N':
            println("Interactivity: Load key pressed!");
            settings.loadKeyPressed();
            return;

        case '?':
            if(currentBoard instanceof BoardCyton) {
                ((BoardCyton)currentBoard).printRegisters();
            }
            return;

        case 'd':   
            return;

        case 'm':
            String picfname = "OpenBCI-" + directoryManager.getFileNameDateTime() + ".jpg";
            //println("OpenBCI_GUI: 'm' was pressed...taking screenshot:" + picfname);
            saveFrame(directoryManager.getGuiDataPath() + "Screenshots" + System.getProperty("file.separator") + picfname);    // take a shot of that!
            output("Screenshot captured! Saved to /Documents/OpenBCI_GUI/Screenshots/" + picfname);
            return;
        default:
            break;
    }

    if (nchan > 4) {
        switch (val) {
            case '5':
                currentBoard.setEXGChannelActive(5-1, false);
                return;
            case '6':
                currentBoard.setEXGChannelActive(6-1, false);
                return;
            case '7':
                currentBoard.setEXGChannelActive(7-1, false);
                return;
            case '8':
                currentBoard.setEXGChannelActive(8-1, false);
                return;
            case '%':
                currentBoard.setEXGChannelActive(5-1, true);
                return;
            case '^':
                currentBoard.setEXGChannelActive(6-1, true);
                return;
            case '&':
                currentBoard.setEXGChannelActive(7-1, true);
                return;
            case '*':
                currentBoard.setEXGChannelActive(8-1, true);
                return;
            default:
                break;
        }
    }

    if (nchan > 8) {
        switch (val) {
            case 'q':
                currentBoard.setEXGChannelActive(9-1, false);
                return;
            case 'w':
                currentBoard.setEXGChannelActive(10-1, false);
                return;
            case 'e':
                currentBoard.setEXGChannelActive(11-1, false);
                return;
            case 'r':
                currentBoard.setEXGChannelActive(12-1, false);
                return;
            case 't':
                currentBoard.setEXGChannelActive(13-1, false);
                return;
            case 'y':
                currentBoard.setEXGChannelActive(14-1, false);
                return;
            case 'u':
                currentBoard.setEXGChannelActive(15-1, false);
                return;
            case 'i':
                currentBoard.setEXGChannelActive(16-1, false);
                return;
            case 'Q':
                currentBoard.setEXGChannelActive(9-1, true);
                return;
            case 'W':
                currentBoard.setEXGChannelActive(10-1, true);
                return;
            case 'E':
                currentBoard.setEXGChannelActive(11-1, true);
                return;
            case 'R':
                currentBoard.setEXGChannelActive(12-1, true);
                return;
            case 'T':
                currentBoard.setEXGChannelActive(13-1, true);
                return;
            case 'Y':
                currentBoard.setEXGChannelActive(14-1, true);
                return;
            case 'U':
                currentBoard.setEXGChannelActive(15-1, true);
                return;
            case 'I':
                currentBoard.setEXGChannelActive(16-1, true);
                return;
            default:
                break;
        }
    }
    
    // Fixes #976. These keyboard shortcuts enable synthetic square waves on Ganglion and Cyton
    if (currentBoard instanceof BoardGanglion || currentBoard instanceof BoardCyton) {
        if (val == '[' ||  val == ']') {
            println("Expert Mode: '" + val + "' pressed. Sending to Ganglion...");
            Boolean success = ((Board)currentBoard).sendCommand(str(val)).getKey();
            if (success) {
                outputSuccess("Expert Mode: Success sending '" + val + "' to Ganglion!");
            } else {
                outputWarn("Expert Mode: Error sending '" + val + "' to Ganglion. Try again with data stream stopped.");
            }
            return;
        }
    }

    if (currentBoard instanceof Board) {
        output("Expert Mode: '" + key + "' pressed. This is not assigned or applicable to current setup.");
        //((Board)currentBoard).sendCommand(str(key));
    }
}

public void mouseDragged() {

    if (systemMode >= SYSTEMMODE_POSTINIT) {

        //calling mouse dragged inly outside of Control Panel
        if (controlPanel.isOpen == false) {
            wm.mouseDragged();
        }
    }
}
//switch yard if a click is detected
public synchronized void mousePressed() {
    // don't allow mouse clicks until setup is complete and the UI is initialized
    if (!setupComplete) {
        return;
    }
    // verbosePrint("OpenBCI_GUI: mousePressed: mouse pressed");
    // println("systemMode" + systemMode);

    //if not before "START SESSION" ... i.e. after initial setup
    if (systemMode >= SYSTEMMODE_POSTINIT) {

        //limit interactivity of main GUI if control panel is open
        if (controlPanel.isOpen == false) {
            //was the stopButton pressed?

            wm.mousePressed();

        }
    }

    //topNav is always clickable
    topNav.mousePressed();

    //interacting with control panel
    if (controlPanel.isOpen) {
        //close control panel if you click outside...
        if (systemMode == SYSTEMMODE_POSTINIT) {
            if (mouseX > 0 && mouseX < controlPanel.w && mouseY > 0 && mouseY < controlPanel.initBox.y+controlPanel.initBox.h) {
                println("OpenBCI_GUI: mousePressed: clicked in CP box");
            }
            //if clicked out of panel
            else {
                println("OpenBCI_GUI: mousePressed: outside of CP clicked");
                controlPanel.close();
                topNav.controlPanelCollapser.setOff();
            }
        }
    }
}

public synchronized void mouseReleased() {
    // don't allow mouse clicks until setup is complete and the UI is initialized
    if (!setupComplete) {
        return;
    }

    // gui.mouseReleased();
    topNav.mouseReleased();

    if (systemMode >= SYSTEMMODE_POSTINIT) {

        // GUIWidgets_mouseReleased(); // to replace GUI_Manager version (above) soon... cdr 7/25/16
        wm.mouseReleased();
    }
}

//Global function used to open a url in default browser, usually after pressing a button
public void openURLInBrowser(String _url){
    try {
        //Set your page url in this string. For eg, I m using URL for Google Search engine
        java.awt.Desktop.getDesktop().browse(java.net.URI.create(_url));
        output("Opening URL: " + _url);
    }
    catch (java.io.IOException e) {
            //println(e.getMessage());
            println("Error launching url in browser: " + _url);
    }
}
///////////////////////////////////////////////////////////////////////////////
//
// This class configures and manages the connection to the Serial port for
// the Arduino.
//
// Created: Chip Audette, Oct 2013
// Modified: through April 2014
// Modified again: Conor Russomanno Sept-Oct 2014
// Modified for Daisy (16-chan) OpenBCI V3: Conor Russomanno Nov 2014
// Modified Daisy Behaviors: Chip Audette Dec 2014
// Modified For Wifi Addition: AJ Keller July 2017
//
// Note: this class now expects the data format produced by OpenBCI V3.
//
// Update Nov 2020 (RW):
//      - Large Portions of this are DEPRECATED
//      - Code in interfaceSerial.pde should be seen as old, clunky, messy code
//      - Do not copy any style or build upon this code
//      - serialEvent() is still used when checking Cyton status from Control Panel in Manual Radio Config
//      - This code should be refactored to work in a predictable way to provide Radio Config with board_message from Cyton
//
/////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
//                       Global Variables & Instances
//------------------------------------------------------------------------

int _myCounter;
int newPacketCounter = 0;
boolean no_start_connection = false;
byte inByte = -1;    // Incoming serial data
boolean isOpenBCI;
boolean isGettingPoll = false;
boolean spaceFound = false;
int hexToInt = 0;
boolean currentlySyncing = false;
long timeSinceStopRunning = 1000;

//these variables are used for "Kill Spikes" ... duplicating the last received data packet if packets were droppeds
boolean werePacketsDroppedSerial = false;
int numPacketsDroppedSerial = 0;

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------
public void serialEvent(processing.serial.Serial port){
    //check to see which serial port it is
    if (iSerial.isOpenBCISerial(port)) {

        boolean echoBytes;

        if (iSerial.isStateNormal() != true) {  // || printingRegisters == true){
            echoBytes = true;
        } else {
            echoBytes = false;
        }
        iSerial.read(echoBytes);
        if (iSerial.get_isNewDataPacketAvailable()) {
            println("woo got a new packet");
            //copy packet into buffer of data packets

            iSerial.set_isNewDataPacketAvailable(false); //resets isNewDataPacketAvailable to false

            newPacketCounter++;
        }
    } else {

        //Used for serial communications, primarily everything in no_start_connection
        if (no_start_connection) {


            if (board_message == null || _myCounter>2) {
                board_message = new StringBuilder();
                _myCounter = 0;
            }

            inByte = PApplet.parseByte(port.read());
            print(inByte);
            if (PApplet.parseChar(inByte) == 'S' || PApplet.parseChar(inByte) == 'F') isOpenBCI = true;

            // print(char(inByte));
            if (inByte != -1) {
                if (isGettingPoll) {
                    if (inByte != '$') {
                        if (!spaceFound) board_message.append(PApplet.parseChar(inByte));
                        else hexToInt = Integer.parseInt(String.format("%02X", inByte), 16);

                        if (PApplet.parseChar(inByte) == ' ') spaceFound = true;
                    } else _myCounter++;
                } else {
                    if (inByte != '$') board_message.append(PApplet.parseChar(inByte));
                    else _myCounter++;
                }
            }
        } else {
            //println("Recieved serial data not from OpenBCI"); //this is a bit of a lie
            inByte = PApplet.parseByte(port.read());
            if (isOpenBCI) {

                if (board_message == null || _myCounter >2) {
                    board_message = new StringBuilder();
                    _myCounter=0;
                }
                if(inByte != '$'){
                    board_message.append(PApplet.parseChar(inByte));
                } else { _myCounter++; }
            } else if(PApplet.parseChar(inByte) == 'S' || PApplet.parseChar(inByte) == 'F'){
                isOpenBCI = true;
                if(board_message == null){
                    board_message = new StringBuilder();
                    board_message.append(PApplet.parseChar(inByte));
                }
            }
        }
    }
}

//------------------------------------------------------------------------
//                       Classes
//------------------------------------------------------------------------

class InterfaceSerial {

    //here is the serial port for this OpenBCI board
    private processing.serial.Serial serial_openBCI = null;
    private boolean portIsOpen = false;

    //final static int DATAMODE_TXT = 0;
    final static int DATAMODE_BIN = 2;
    final static int DATAMODE_BIN_WAUX = 1;  //switched to this value so that receiving Accel data is now the default
    //final static int DATAMODE_BIN_4CHAN = 4;

    final static int STATE_NOCOM = 0;
    final static int STATE_COMINIT = 1;
    final static int STATE_SYNCWITHHARDWARE = 2;
    final static int STATE_NORMAL = 3;
    final static int STATE_STOPPED = 4;
    final static int COM_INIT_MSEC = 3000; //you may need to vary this for your computer or your Arduino

    //int[] measured_packet_length = {0,0,0,0,0};
    //int measured_packet_length_ind = 0;
    //int known_packet_length_bytes = 0;

    final static byte BYTE_START = (byte)0xA0;
    final static byte BYTE_END = (byte)0xC0;

    int prefered_datamode = DATAMODE_BIN_WAUX;

    private int state = STATE_NOCOM;
    int dataMode = -1;
    int prevState_millis = 0;

    private int nEEGValuesPerPacket = 8; //defined by the data format sent by cyton boards
    private int nAuxValuesPerPacket = 3; //defined by the data format sent by cyton boards

    public int [] validAuxValues = {0, 0, 0};
    public boolean[] freshAuxValuesAvailable = {false, false, false};
    public boolean freshAuxValues = false;
    //DataPacket_ADS1299 prevDataPacket;

    private int nAuxValues;
    private boolean isNewDataPacketAvailable = false;
    private OutputStream output; //for debugging  WEA 2014-01-26
    private int serialErrorCounter = 0;

    private final float fs_Hz = 250.0f;  //sample rate used by OpenBCI board...set by its Arduino code
    private final float ADS1299_Vref = 4.5f;  //reference voltage for ADC in ADS1299.  set by its hardware
    private float ADS1299_gain = 24.0f;  //assumed gain setting for ADS1299.  set by its Arduino code
    private float openBCI_series_resistor_ohms = 2200; // Ohms. There is a series resistor on the 32 bit board.
    private float scale_fac_uVolts_per_count = ADS1299_Vref / ((float)(pow(2, 23)-1)) / ADS1299_gain  * 1000000.f; //ADS1299 datasheet Table 7, confirmed through experiment
    //float LIS3DH_full_scale_G = 4;  // +/- 4G, assumed full scale setting for the accelerometer
    private final float scale_fac_accel_G_per_count = 0.002f / ((float)pow(2, 4));  //assume set to +/4G, so 2 mG per digit (datasheet). Account for 4 bits unused
    //final float scale_fac_accel_G_per_count = 1.0;
    private final float leadOffDrive_amps = 6.0e-9f;  //6 nA, set by its Arduino code
    private final String failureMessage = "Failure: Communications timeout - Device failed to poll Host";

    boolean isBiasAuto = true; //not being used?

    //data related to Conor's setup for V3 boards
    final char[] EOT = {'$', '$', '$'};
    char[] prev3chars = {'#', '#', '#'};
    private boolean readyToSend = false; //system waits for $$$ after requesting information from OpenBCI board
    private long timeOfLastCommand = 0; //used when sync'ing to hardware

    //wait for $$$ to iterate... applies to commands expecting a response
    public boolean isReadyToSend() {
        return readyToSend;
    }
    public void setReadyToSend(boolean _readyToSend) {
        readyToSend = _readyToSend;
    }
    public int get_state() {
        return state;
    };
    public boolean get_isNewDataPacketAvailable() {
        return isNewDataPacketAvailable;
    }
    public void set_isNewDataPacketAvailable(boolean _isNewDataPacketAvailable) {
        isNewDataPacketAvailable = _isNewDataPacketAvailable;
    }

    //constructors
    InterfaceSerial() {
    };  //only use this if you simply want access to some of the constants
    InterfaceSerial(PApplet applet, String comPort, int baud, int nEEGValuesPerOpenBCI, boolean useAux, int nAuxValuesPerOpenBCI) {
        //choose data mode
        println("InterfaceSerial: prefered_datamode = " + prefered_datamode + ", nValuesPerPacket = " + nEEGValuesPerPacket);
        if (prefered_datamode == DATAMODE_BIN_WAUX) {
            if (!useAux) {
                //must be requesting the aux data, so change the referred data mode
                prefered_datamode = DATAMODE_BIN;
                nAuxValues = 0;
                //println("InterfaceSerial: nAuxValuesPerPacket = " + nAuxValuesPerPacket + " so setting prefered_datamode to " + prefered_datamode);
            }
        }

        dataMode = prefered_datamode;
    }

    // //manage the serial port
    public int openSerialPort(PApplet applet, String comPort, int baud) {

        output("Attempting to open Serial/COM port: " + openBCI_portName);
        try {
            println("InterfaceSerial: openSerialPort: attempting to open serial port: " + openBCI_portName);
            serial_openBCI = new processing.serial.Serial(applet, comPort, baud); //open the com port
            serial_openBCI.clear(); // clear anything in the com port's buffer
            portIsOpen = true;
            println("InterfaceSerial: openSerialPort: port is open (t)? ... " + portIsOpen);
            changeState(STATE_COMINIT);
            return 0;
        }
        catch (RuntimeException e) {
            if (e.getMessage().contains("<init>")) {
                serial_openBCI = null;
                System.out.println("InterfaceSerial: openSerialPort: port in use, trying again later...");
                portIsOpen = false;
            } else {
                println("RunttimeException: " + e);
                output("Error connecting to selected Serial/COM port. Make sure your board is powered up and your dongle is plugged in.");
                //abandonInit = true; //global variable in OpenBCI_GUI.pde
            }
            return 0;
        }
    }

    public int changeState(int newState) {
        state = newState;
        prevState_millis = millis();
        return 0;
    }

    public int finalizeCOMINIT() {
        changeState(STATE_NORMAL);
        return 0;
    }

    public int closeSDandSerialPort() {
        int returnVal=0;

        readyToSend = false;
        returnVal = closeSerialPort();
        prevState_millis = 0;  //reset Serial state clock to use as a conditional for timing at the beginnign of systemUpdate()

        return returnVal;
    }

    public int closeSerialPort() {
        portIsOpen = false;
        if (serial_openBCI != null) {
            serial_openBCI.stop();
        }
        serial_openBCI = null;
        state = STATE_NOCOM;
        println("InterfaceSerial: closeSerialPort: closed");
        return 0;
    }

    public void updateSyncState(int sdSetting) {
        //Has it been 3000 milliseconds since we initiated the serial port?
        //We want to make sure we wait for the OpenBCI board to finish its setup()

        if ( (millis() - prevState_millis > COM_INIT_MSEC) && (prevState_millis != 0) && (state == STATE_COMINIT) ) {
            state = STATE_SYNCWITHHARDWARE;
            timeOfLastCommand = millis();
            serial_openBCI.clear();
            println("InterfaceSerial: systemUpdate: [0] Sending 'v' to OpenBCI to reset hardware in case of 32bit board...");
            serial_openBCI.write('v');
        }

        //if we are in SYNC WITH HARDWARE state ... trigger a command
        if ( (state == STATE_SYNCWITHHARDWARE) && (currentlySyncing == false) ) {
            if (millis() - timeOfLastCommand > 200 && readyToSend == true) {
                println("sdSetting: " + sdSetting);
                timeOfLastCommand = millis();
            }
        }
    }

    public void sendChar(char val) {
        if (isSerialPortOpen()) {
            println("sending out: " + val);
            serial_openBCI.write(val);//send the value as ascii (with a newline character?)
        } else {
            println("nope no out: " + val);

        }
    }

    public void write(String msg) {
        if (isSerialPortOpen()) {
            serial_openBCI.write(msg);
        }
    }

    public boolean isSerialPortOpen() {
        if (portIsOpen & (serial_openBCI != null)) {
            return true;
        } else {
            return false;
        }
    }
    public boolean isOpenBCISerial(processing.serial.Serial port) {
        if (serial_openBCI == port) {
            return true;
        } else {
            return false;
        }
    }

    public void clear() {
        if (serial_openBCI != null) {
            serial_openBCI.clear();
        }
    }

    //read from the serial port
    public int read() {
        return read(false);
    }
    public int read(boolean echoChar) {
        //println("InterfaceSerial: read(): State: " + state);
        //get the byte
        byte inByte;
        if (isSerialPortOpen()) {
            inByte = PApplet.parseByte(serial_openBCI.read());
        } else {
            println("InterfaceSerial port not open aborting.");
            return 0;
        }
        print(inByte);
        //write the most recent char to the console
        // If the GUI is in streaming mode then echoChar will be false
        if (echoChar) {  //if not in interpret binary (NORMAL) mode
            // print("hardwareSyncStep: "); println(hardwareSyncStep);
            // print(".");
            char inASCII = PApplet.parseChar(inByte);
            if (currentBoard.isStreaming() == false && (millis() - timeSinceStopRunning) > 500) {
                print(PApplet.parseChar(inByte));
            }

            //keep track of previous three chars coming from OpenBCI
            prev3chars[0] = prev3chars[1];
            prev3chars[1] = prev3chars[2];
            prev3chars[2] = inASCII;

            //if the last three chars are $$$, it means we are moving on to the next stage of initialization
            if (prev3chars[0] == EOT[0] && prev3chars[1] == EOT[1] && prev3chars[2] == EOT[2]) {
                verbosePrint(" > EOT detected...");
                // Added for V2 system down rejection line

                // hardwareSyncStep++;
                prev3chars[2] = '#';

                readyToSend = true;
                // println(hardwareSyncStep);
            }
        }

        //write raw unprocessed bytes to a binary data dump file
        if (output != null) {
            try {
                output.write(inByte);   //for debugging  WEA 2014-01-26
            }
            catch (IOException e) {
                println("InterfaceSerial: read(): Caught IOException: " + e.getMessage());
                //do nothing
            }
        }

        interpretBinaryStream(inByte);  //new 2014-02-02 WEA
        return PApplet.parseInt(inByte);
    }

    /* **** Borrowed from Chris Viegl from his OpenBCI parser for BrainBay
    Modified by Joel Murphy and Conor Russomanno to read OpenBCI data
    Packet Parser for OpenBCI (1-N channel binary format):
    3-byte data values are stored in 'little endian' formant in AVRs
    so this protocol parser expects the lower bytes first.
    Start Indicator: 0xA0
    EXPECTING STANDARD PACKET LENGTH DON'T NEED: Packet_length  : 1 byte  (length = 4 bytes framenumber + 4 bytes per active channel + (optional) 4 bytes for 1 Aux value)
    Framenumber     : 1 byte (Sequential counter of packets)
    Channel 1 data  : 3 bytes
    ...
    Channel 8 data  : 3 bytes
    Aux Values      : UP TO 6 bytes
    End Indcator    : 0xC0
    TOTAL OF 33 bytes ALL DAY
    ********************************************************************* */
    private int nDataValuesInPacket = 0;
    private int localByteCounter=0;
    private int localChannelCounter=0;
    private int PACKET_readstate = 0;
    // byte[] localByteBuffer = {0,0,0,0};
    private byte[] localAdsByteBuffer = {0, 0, 0};
    private byte[] localAccelByteBuffer = {0, 0};

    public void interpretBinaryStream(byte actbyte) {
        boolean flag_copyRawDataToFullData = false;

        //println("InterfaceSerial: interpretBinaryStream: PACKET_readstate " + PACKET_readstate);
        switch (PACKET_readstate) {
        case 0:
            //look for header byte
            if (actbyte == PApplet.parseByte(0xA0)) {          // look for start indicator
                // println("InterfaceSerial: interpretBinaryStream: found 0xA0");
                PACKET_readstate++;
            }
            break;
        case 1:
            //check the packet counter
            // println("case 1");
            byte inByte = actbyte;

            localByteCounter=0;//prepare for next usage of localByteCounter
            localChannelCounter=0; //prepare for next usage of localChannelCounter
            PACKET_readstate++;
            break;
        case 2:
            // get ADS channel values
            // println("case 2");
            localAdsByteBuffer[localByteCounter] = actbyte;
            localByteCounter++;
            if (localByteCounter==3) {
                localChannelCounter++;
                if (localChannelCounter==8) { //nDataValuesInPacket) {
                    // all ADS channels arrived !
                    // println("InterfaceSerial: interpretBinaryStream: localChannelCounter = " + localChannelCounter);
                    PACKET_readstate++;
                    if (prefered_datamode != DATAMODE_BIN_WAUX) PACKET_readstate++;  //if not using AUX, skip over the next readstate
                    localByteCounter = 0;
                    localChannelCounter = 0;
                    //isNewDataPacketAvailable = true;  //tell the rest of the code that the data packet is complete
                } else {
                    //prepare for next data channel
                    localByteCounter=0; //prepare for next usage of localByteCounter
                }
            }
            break;
        case 3:
            // get LIS3DH channel values 2 bytes times 3 axes
            // println("case 3");
            localAccelByteBuffer[localByteCounter] = actbyte;
            localByteCounter++;

            break;
        case 4:
            //look for end byte
            // println("case 4");
            if (actbyte == PApplet.parseByte(0xC0) || actbyte == PApplet.parseByte(0xC1)) {    // if correct end delimiter found:
                // println("... 0xCx found");
                // println("InterfaceSerial: interpretBinaryStream: found end byte. Setting isNewDataPacketAvailable to TRUE");
                isNewDataPacketAvailable = true; //original place for this.  but why not put it in the previous case block
                flag_copyRawDataToFullData = true;  //time to copy the raw data packet into the full data packet (mainly relevant for 16-chan OpenBCI)
            } else {
                serialErrorCounter++;
                println("InterfaceSerial: interpretBinaryStream: Actbyte = " + actbyte);
                println("InterfaceSerial: interpretBinaryStream: expecteding end-of-packet byte is missing.  Discarding packet. (" + serialErrorCounter + ")");
            }
            PACKET_readstate=0;  // either way, look for next packet
            break;
        default:
            println("InterfaceSerial: interpretBinaryStream: Unknown byte: " + actbyte + " .  Continuing...");
            PACKET_readstate=0;  // look for next packet
        }


    } // end of interpretBinaryStream



    //return the state
    public boolean isStateNormal() {
        if (state == STATE_NORMAL) {
            return true;
        } else {
            return false;
        }
    }


};


class PacketRecord {
    public int numLost;
    public int numReceived;

    PacketRecord(int _numLost, int _numReceived) {
        numLost = _numLost;
        numReceived = _numReceived;
    }

    public int getNumExpected() {
        return numLost + numReceived;
    }

    public float getLostPercent() {
        if(getNumExpected() == 0) {
            return 0.f;
        }

        return numLost * 100.f / getNumExpected();
    }

    public void appendAll(List<PacketRecord> toAppend) {
        for (PacketRecord record : toAppend) {
            numLost += record.numLost;
            numReceived += record.numReceived;
        }
    }
}

class PacketLossTracker {

    public boolean silent = false;

    private int sampleIndexChannel;
    private int timestampChannel;
    private double[] lastSample = null;
    private int lastSampleIndexLocation;
    private boolean newStream = false;

    private PacketRecord sessionPacketRecord = new PacketRecord(0, 0);
    private PacketRecord streamPacketRecord = new PacketRecord(0, 0);

    private TimeTrackingQueue<PacketRecord> packetRecords;

    protected ArrayList<Integer> sampleIndexArray = new ArrayList<Integer>();

    // use these vars for notification at the bottom
    private boolean notificationShown = false;
    protected String lostPackagesMsg = "Lost packets detected, open packet loss widget for more info";
    protected String noLostPackagesMsg = "Data streaming is running as usual";
    protected int windowSizeNotificationMs = 5000;
    protected double thresholdNotification = 1.0f;

    PacketLossTracker(int _sampleIndexChannel, int _timestampChannel, int _minSampleIndex, int _maxSampleIndex) {        
        this(_sampleIndexChannel, _timestampChannel,  _minSampleIndex, _maxSampleIndex, new RealTimeProvider());
    }

    PacketLossTracker(int _sampleIndexChannel, int _timestampChannel, int _minSampleIndex, int _maxSampleIndex, TTQTimeProvider _timeProvider) {        
        this(_sampleIndexChannel, _timestampChannel, _timeProvider);

        // add indices to array of indices
        for (int i = _minSampleIndex; i <= _maxSampleIndex; i++) {
            sampleIndexArray.add(i);
        }
    }

    PacketLossTracker(int _sampleIndexChannel, int _timestampChannel, TTQTimeProvider _timeProvider) {
        packetRecords = new TimeTrackingQueue<PacketRecord>(60 * 1000, _timeProvider);
        sampleIndexChannel = _sampleIndexChannel;
        timestampChannel = _timestampChannel;
    }

    public void onStreamStart() {
        streamPacketRecord.numLost = 0;
        streamPacketRecord.numReceived = 0;
        newStream = true;
        reset();
    }

    public PacketRecord getSessionPacketRecord() {
        return sessionPacketRecord;
    }

    public PacketRecord getStreamPacketRecord() {
        return streamPacketRecord;
    }

    public List<PacketRecord> getAllPacketRecordsForLast(int milliseconds) {
        return packetRecords.getLastData(milliseconds);
    }

    public PacketRecord getCumulativePacketRecordForLast(int milliseconds) {
        List<PacketRecord> allRecords = getAllPacketRecordsForLast(milliseconds);
        PacketRecord result = new PacketRecord(0, 0);
        result.appendAll(allRecords);
        return result;
    }

    public void addSamples(List<double[]> newSamples) {
        sessionPacketRecord.numReceived += newSamples.size();
        streamPacketRecord.numReceived += newSamples.size();

        // create packet record for this call, add received count.
        // loss count will be added in the for loop
        PacketRecord currentRecord = new PacketRecord(0, newSamples.size());

        for (double[] sample : newSamples) {
            int currentSampleIndex = (int)(sample[sampleIndexChannel]);
            
            // handle new stream start
            if (newStream) {
                // wait until we restart the sample index array. this handles the case
                // of starting a new stream and there are still samples from the
                // previous stream in the serial buffer
                if (currentSampleIndex == sampleIndexArray.get(0)) {
                    lastSample = sample;
                    lastSampleIndexLocation = 0;
                    newStream = false;
                }
                continue;
            }

            // handle first call
            if (lastSample == null) {
                lastSample = sample;
                lastSampleIndexLocation = sampleIndexArray.indexOf(currentSampleIndex);
                continue;
            }

            incrementLastSampleIndexLocation();

            int numSamplesLost = 0;

            while (sampleIndexArray.get(lastSampleIndexLocation) != currentSampleIndex) {
                incrementLastSampleIndexLocation();
                numSamplesLost++;

                if (numSamplesLost > sampleIndexArray.size()) {
                    // we looped the entire array, the new sample is not part of the current array
                    println("WARNING: The sample index " + currentSampleIndex + " is not in the list of possible sample indices.");
                    break;
                }
            }

            if (numSamplesLost > 0) {
                sessionPacketRecord.numLost += numSamplesLost;
                streamPacketRecord.numLost += numSamplesLost;
                currentRecord.numLost += numSamplesLost;

                if(!silent) {
                    // print the packet loss event
                    println("WARNING: Lost " + numSamplesLost + " Samples Between "
                        +  (int)lastSample[sampleIndexChannel] + "-" + (int)sample[sampleIndexChannel]);
                }
            }

            lastSample = sample;
        }

        packetRecords.push(currentRecord);
        checkCurrentStreamStatus();
    }

    private void incrementLastSampleIndexLocation() {
        // increment index location, advance through list of indexes
        // make sure to loop around if we reach the end of the list
        lastSampleIndexLocation ++;
        lastSampleIndexLocation = lastSampleIndexLocation % sampleIndexArray.size();
    }

    protected void reset() {
        lastSample = null;
    }

    protected void checkCurrentStreamStatus() {
        PacketRecord lastMillisPacketRecord = getCumulativePacketRecordForLast(windowSizeNotificationMs);
        if (lastMillisPacketRecord.getLostPercent() > thresholdNotification) {
            if (!notificationShown) {
                notificationShown = true;
                outputWarn(lostPackagesMsg);
            }
        }
        else {
            if (notificationShown) {
                notificationShown = false;
                outputInfo(noLostPackagesMsg);
            }
        }
    }
}

// sample index range 1-255, odd numbers only (skips evens)
class PacketLossTrackerCytonSerialDaisy extends PacketLossTracker {

    PacketLossTrackerCytonSerialDaisy(int _sampleIndexChannel, int _timestampChannel) {
        this(_sampleIndexChannel, _timestampChannel, new RealTimeProvider());
    }

    PacketLossTrackerCytonSerialDaisy(int _sampleIndexChannel, int _timestampChannel, TTQTimeProvider _timeProvider) {
        super(_sampleIndexChannel, _timestampChannel, _timeProvider);

        // add indices to array of indices
        // 0-254, event numbers only (skips odds)
        int firstIndex = 0;
        int lastIndex = 254;
        for (int i = firstIndex; i <= lastIndex; i += 2) {
            sampleIndexArray.add(i);
        }
    }
}

// with accel: sample index range 0-100, all sample indexes are duplicated except for zero.
// eg 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, ... , 99, 99, 100, 100, 0, 1, 1, 2, 2, 3, 3, ...
// without acceL: sample 0, then 101-200
class PacketLossTrackerGanglionBLE extends PacketLossTracker {

    ArrayList<Integer> sampleIndexArrayAccel = new ArrayList<Integer>();
    ArrayList<Integer> sampleIndexArrayNoAccel = new ArrayList<Integer>();

    PacketLossTrackerGanglionBLE(int _sampleIndexChannel, int _timestampChannel) {
        this(_sampleIndexChannel, _timestampChannel, new RealTimeProvider());
    }

    PacketLossTrackerGanglionBLE(int _sampleIndexChannel, int _timestampChannel, TTQTimeProvider _timeProvider) {
        super(_sampleIndexChannel, _timestampChannel, _timeProvider);

        {
            // add indices to array of indices
            //  With accel: 0-100, all sample indexes are duplicated except for zero
            sampleIndexArrayAccel.add(0);
            int firstIndex = 1;
            int lastIndex = 100;
            for (int i = firstIndex; i <= lastIndex; i++) {
                sampleIndexArrayAccel.add(i);
                sampleIndexArrayAccel.add(i);
            }
        }

        {
            // add indices to array of indices
            // Without accel: 0, then 101 to 200, all sample indexes are duplicated except for zero
            sampleIndexArrayNoAccel.add(0);
            int firstIndex = 101;
            int lastIndex = 200;
            for (int i = firstIndex; i <= lastIndex; i++) {
                sampleIndexArrayNoAccel.add(i);
                sampleIndexArrayNoAccel.add(i);
            }
        }

        setAccelerometerActive(true);
    }

    public void setAccelerometerActive(boolean active) {
        // choose correct array based on wether accel is active or not
        if (active) {
            sampleIndexArray = sampleIndexArrayAccel;
        }
        else {
            sampleIndexArray = sampleIndexArrayNoAccel;
        }

        reset();
    }
}



// Instantiate this class to show a popup message

class PopupMessage extends PApplet implements Runnable {
    private final int defaultWidth = 500;
    private final int defaultHeight = 250;

    private final int headerHeight = 55;
    private final int padding = 20;

    private final int buttonWidth = 120;
    private final int buttonHeight = 40;

    private String message = "Empty Popup";
    private String headerMessage = "Error";
    private String buttonMessage = "OK";
    private String buttonLink = null;

    private int headerColor = OPENBCI_BLUE;
    private int buttonColor = OPENBCI_BLUE;
    private int backgroundColor = GREY_235;
    
    private ControlP5 cp5;

    public PopupMessage(String header, String msg) {
        super();

        headerMessage = header;
        message = msg;

        Thread t = new Thread(this);
        t.start();        
    }

    public PopupMessage(String header, String msg, String btnMsg, String btnLink) {
        super();

        headerMessage = header;
        message = msg;
        buttonMessage = btnMsg;
        buttonLink = btnLink;

        Thread t = new Thread(this);
        t.start();        
    }

    @Override
    public void run() {
        PApplet.runSketch(new String[] {headerMessage}, this);
    }

    @Override public 
    void settings() {
        size(defaultWidth, defaultHeight);
    }

    @Override public 
    void setup() {
        surface.setTitle(headerMessage);
        surface.setAlwaysOnTop(false);
        surface.setResizable(false);

        Frame frame = ( (PSurfaceAWT.SmoothCanvas) ((PSurfaceAWT)surface).getNative()).getFrame();
        frame.toFront();
        frame.requestFocus();

        cp5 = new ControlP5(this);

        cp5.addButton("onButtonPressed")
            .setPosition(width/2 - buttonWidth/2, height - buttonHeight - padding)
            .setSize(buttonWidth, buttonHeight)
            .setColorLabel(color(255))
            .setColorForeground(buttonColor)
            .setColorBackground(buttonColor);
        cp5.getController("onButtonPressed")
            .getCaptionLabel()
            .setFont(p1)
            .toUpperCase(false)
            .setSize(20)
            .setText(buttonMessage)
            .getStyle()
            .setMarginTop(-2);
    }

    @Override public 
    void draw() {
        final int w = defaultWidth;
        final int h = defaultHeight;

        pushStyle();

        // draw bg
        background(OPENBCI_DARKBLUE);
        stroke(204);
        fill(backgroundColor);
        rect((width - w)/2, (height - h)/2, w, h);

        // draw header
        noStroke();
        fill(headerColor);
        rect((width - w)/2, (height - h)/2, w, headerHeight);

        //draw header text
        textFont(p0, 24);
        fill(WHITE);
        textAlign(LEFT, CENTER);
        text(headerMessage, (width - w)/2 + padding, headerHeight/2);

        //draw message
        textFont(p3, 16);
        fill(102);
        textAlign(LEFT, TOP);
        text(message, (width - w)/2 + padding, (height - h)/2 + padding + headerHeight, w-padding*2, h-padding*2-headerHeight);

        popStyle();
        
        cp5.draw();
    }

    @Override public 
    void mousePressed() {

    }

    @Override public 
    void mouseReleased() {

    }

    @Override public 
    void exit() {
        dispose();
    }

    public void onButtonPressed() {
        if (buttonLink != null) {
            link(buttonLink);
        }
        noLoop();
        Frame frame = ( (PSurfaceAWT.SmoothCanvas) ((PSurfaceAWT)surface).getNative()).getFrame();
        frame.dispose();
        exit();
    }
};
/////////////////////////////////////////////////////////////////////////////////
//
//  Radio_Config allows users to manually configure Cyton and Dongle
//
//  Created: Colin Fausnaught, July 2016
//
//  Handles interactions between the radio system and OpenBCI systems
//  using a direct Serial co
//
//  Modified by Joel Murphy, January 2017
//
//  Modified by Richard Waltman, May 2020
//
////////////////////////////////////////////////////////////////////////////////

class RadioConfig {

    private processing.serial.Serial serial_direct_board;
    private final int NUM_RADIO_CHAN = 26;
    private String rcStringReceived = "";
    private boolean autoscanPressed = false;
    private boolean overridePressed = false;

    RadioConfig() {

    }
    //=========== AUTO-SCAN ============
    //= Scans through channels until a success message has been found
    //= Used to align Cyton and Dongle on the same radio channel, in case there is a mismatch.
    public void scan_channels(RadioConfigBox rcConfig){
        println("Radios_Config: scan_channels");
        autoscanPressed = true;
        if(serial_direct_board == null){
            if(!connect_to_portName(rcConfig)){
                return;
            }
        }
        for(int i = 1; i < NUM_RADIO_CHAN; i++){
            set_channel_over(rcConfig,i);
            system_status(rcConfig);
            if (board_message != null && board_message.toString().toLowerCase().contains("success")) {
                return;
            }
        }
        autoscanPressed = false;
        closeSerialPort();
    }
    
    public boolean scan_channels(){
        verbosePrint("Cyton Auto-Connect Button: scan_channels");
        if(serial_direct_board == null){
            if(!connect_to_portName()){
                return false;
            }
        }
        for(int i = 1; i < NUM_RADIO_CHAN; i++){
            set_channel_over(i);
            get_channel();
            if (board_message != null && board_message.toString().toLowerCase().contains("success")) {
                autoscanPressed = false;
                closeSerialPort();
                return true;
            }
        }
        autoscanPressed = false;
        closeSerialPort();
        return false;
    }

    //=========== GET SYSTEM STATUS ============
    //= Get's the current status of the system
    //=
    //= First writes 0xF0 to let the board know
    //= a command is coming, then writes the
    //= command (0x07).
    //=
    //= After a short delay it then prints bytes
    //= from the board.
    //==========================================

    public void system_status(RadioConfigBox rcConfig){
        println("Radios_Config: system_status");
        rcStringReceived = "";
        serial_direct_board = null;
        if(!connect_to_portName(rcConfig)){
            return;
        }
        serial_direct_board = new processing.serial.Serial(ourApplet, openBCI_portName, openBCI_baud); //force open the com port
        if(serial_direct_board != null){
            serial_direct_board.write(0xF0);
            serial_direct_board.write(0x07);
            delay(50);
            if(print_bytes(rcConfig)){
                String[] s = split(rcStringReceived, ':');
                if (s[0].equals("Success")) {
                    outputSuccess("Successfully connected to Cyton using " + openBCI_portName);
                } else {
                    outputError("Failed to connect using " + openBCI_portName + ". Check hardware or try pressing 'Auto-Scan'.");
                }
            }
        } else {
            println("Error, no board connected");
            rcConfig.print_onscreen("No board connected!");
        }
        closeSerialPort();
    }

    public boolean system_status(){
        verbosePrint("Cyton Auto-Connect Button: system_status");
        rcStringReceived = "";
        serial_direct_board = null;
        if(!connect_to_portName()){
            return false;
        }
        serial_direct_board = new processing.serial.Serial(ourApplet, openBCI_portName, openBCI_baud); //force open the com port
        if(serial_direct_board != null){
            serial_direct_board.write(0xF0);
            serial_direct_board.write(0x07);
            delay(50);
            if(!print_bytes()){
                closeSerialPort();
                return false;
            } else {
                String[] s = split(rcStringReceived, ':');
                closeSerialPort();
                if (s[0].equals("Success")) {
                    verbosePrint("Cyton Auto-Connect Button: Successfully connected to Cyton using " + openBCI_portName);
                    return true;
                } else {
                    verbosePrint("Cyton Auto-Connect Button: Failed to connect using " + openBCI_portName + ". Check hardware or try pressing 'Auto-Scan'.");
                    return false;
                }
            }
        } else {
            println("Error, no board connected");
            return false;
        }
    }

    //============== GET CHANNEL ===============
    //= Gets channel information from the radio.
    //=
    //= First writes 0xF0 to let the board know
    //= a command is coming, then writes the
    //= command (0x00).
    //=
    //= After a short delay it then prints bytes
    //= from the board.
    //==========================================

    public void get_channel(RadioConfigBox rcConfig){
        println("Radios_Config: get_channel");
        if(serial_direct_board == null){
            if(!connect_to_portName(rcConfig)){
                return;
            }
        }
        serial_direct_board = new processing.serial.Serial(ourApplet, openBCI_portName, openBCI_baud); //force open the com port
        if(serial_direct_board != null){
            serial_direct_board.write(0xF0);
            serial_direct_board.write(0x00);
            delay(100);
            print_bytes(rcConfig);
        }
        else {
            println("Error, no board connected");
            rcConfig.print_onscreen("No board connected!");
        }
        closeSerialPort();
    }

    public boolean get_channel(){
        verbosePrint("Cyton Auto-Connect Button: get_channel");
        if(serial_direct_board == null){
            if(!connect_to_portName()){
                return false;
            }
        }
        serial_direct_board = new processing.serial.Serial(ourApplet, openBCI_portName, openBCI_baud); //force open the com port
        if(serial_direct_board != null){
            serial_direct_board.write(0xF0);
            serial_direct_board.write(0x00);
            delay(50);
            if(!print_bytes()){
                closeSerialPort();
                return false;
            } else {
                String[] s = split(rcStringReceived, ':');
                closeSerialPort();
                if (s[0].equals("Success")) {
                    println(rcStringReceived + ". Using COM port: " + openBCI_portName);
                    return true;
                } else {
                    verbosePrint("Failed to connect using " + openBCI_portName + ". Check hardware or try pressing 'Auto-Scan'.");
                    return false;
                }
            }
        } else {
            println("Error, no board connected");
            return false;
        }
    }

    //============== SET CHANNEL ===============
    //= Sets the radio and board channel.
    //=
    //= First writes 0xF0 to let the board know
    //= a command is coming, then writes the
    //= command (0x01) followed by the number to
    //= set the board and radio to. Channels can
    //= only be 1-25.
    //=
    //= After a short delay it then prints bytes
    //= from the board.
    //==========================================

    public void set_channel(RadioConfigBox rcConfig, int channel_number){
        println("Radios_Config: set_channel");
        if(serial_direct_board == null){
            if(!connect_to_portName(rcConfig)){
                return;
            }
        }
        serial_direct_board = new processing.serial.Serial(ourApplet, openBCI_portName, openBCI_baud); //force open the com port
        if(serial_direct_board != null){
            if(channel_number > 0){
                serial_direct_board.write(0xF0);
                serial_direct_board.write(0x01);
                serial_direct_board.write(PApplet.parseByte(channel_number));
                delay(1000);
                print_bytes(rcConfig);
            }
            else rcConfig.print_onscreen("Please Select a Channel.");
        }
        else {
            println("Error, no board connected");
            rcConfig.print_onscreen("No board connected!");
        }
        closeSerialPort();
    }

    //========== SET CHANNEL OVERRIDE ===========
    //= Sets the radio channel only
    //=
    //= First writes 0xF0 to let the board know
    //= a command is coming, then writes the
    //= command (0x02) followed by the number to
    //= set the board and radio to. Channels can
    //= only be 1-25.
    //=
    //= After a short delay it then prints bytes
    //= from the board.
    //==========================================

    public void set_channel_over(RadioConfigBox rcConfig, int channel_number){
        println("Radios_Config: set_ovr_channel");
        overridePressed = true;
        if(serial_direct_board == null){
            if(!connect_to_portName(rcConfig)){
                return;
            }
        }
        serial_direct_board = new processing.serial.Serial(ourApplet, openBCI_portName, openBCI_baud); //force open the com port
        if(serial_direct_board != null){
            if(channel_number > 0){
                serial_direct_board.write(0xF0);
                serial_direct_board.write(0x02);
                serial_direct_board.write(PApplet.parseByte(channel_number));
                delay(300);
                print_bytes(rcConfig);
            }

            else rcConfig.print_onscreen("Please Select a Channel.");
        }
        else {
            println("Error, no board connected");
            rcConfig.print_onscreen("No board connected!");
        }
        overridePressed = false;
        closeSerialPort();
    }

    public void set_channel_over(int channel_number){
        verbosePrint("Cyton Auto-Connect BUtton: set_ovr_channel");
        overridePressed = true;
        if(serial_direct_board == null){
            if(!connect_to_portName()){
                return;
            }
        }
        serial_direct_board = new processing.serial.Serial(ourApplet, openBCI_portName, openBCI_baud); //force open the com port
        if(serial_direct_board != null){
            if(channel_number > 0){
                serial_direct_board.write(0xF0);
                serial_direct_board.write(0x02);
                serial_direct_board.write(PApplet.parseByte(channel_number));
                delay(100);
                print_bytes();
            }
        }
        else {
            println("Error, no board connected");
        }
        overridePressed = false;
        closeSerialPort();
    }

    /**** Function to connect to a selected port ****/  // JAM 1/2017
    //    Needs to be connected to something to perform the Radio_Config tasks
   private boolean connect_to_portName(RadioConfigBox rcConfig){
        if(openBCI_portName != "N/A"){
            output("Attempting to open Serial/COM port: " + openBCI_portName);
            try {
                println("Radios_Config: connect_to_portName: Attempting to open serial port: " + openBCI_portName);
                serial_output = new processing.serial.Serial(ourApplet, openBCI_portName, openBCI_baud); //open the com port
                serial_output.clear(); // clear anything in the com port's buffer
                // portIsOpen = true;
                println("Radios_Config: connect_to_portName: Port is open!");
                serial_output.stop();
                return true;
            }
            catch (RuntimeException e){
                if (e.getMessage().contains("Port busy")) {
                    rcConfig.print_onscreen("Port Busy.\n\nTry a different port?");
                    outputError("Radios_Config: Serial Port in use. Try another port or unplug/plug dongle.");
                    // portIsOpen = false;
                } else {
                    println("Error connecting to selected Serial/COM port. Make sure your board is powered up and your dongle is plugged in.");
                    rcConfig.print_onscreen("Error connecting to Serial port.\n\nTry a different port?");
                }
                closeSerialPort();
                println("Failed to connect using " + openBCI_portName);
                return false;
            }
        } else {
            outputWarn("No Serial/COM port selected. Please select your Serial/COM port and retry.");
            rcConfig.print_onscreen("Select a Serial/COM port, then try again.");
            return false;
        }
    }

    private boolean connect_to_portName(){
        if(openBCI_portName != "N/A"){
            verbosePrint("Attempting to open Serial/COM port: " + openBCI_portName);
            try {
                verbosePrint("Radios_Config: connect_to_portName: Attempting to open serial port: " + openBCI_portName);
                serial_output = new processing.serial.Serial(ourApplet, openBCI_portName, openBCI_baud); //open the com port
                serial_output.clear(); // clear anything in the com port's buffer
                // portIsOpen = true;
                verbosePrint("Radios_Config: connect_to_portName: Port is open!");
                serial_output.stop();
                return true;
            }
            catch (RuntimeException e){
                if (e.getMessage().contains("Port busy")) {
                    serial_output = null;
                    outputError("Radios_Config: Serial Port in use. Try another port or unplug/plug dongle.");
                    // portIsOpen = false;
                } else {
                    println("Error connecting to selected Serial/COM port. Make sure your board is powered up and your dongle is plugged in.");
                }
                closeSerialPort();
                println("Failed to connect using " + openBCI_portName);
                return false;
            }
        } else {
            outputWarn("No Serial/COM port selected. Please select your Serial/COM port and retry.");
            return false;
        }
    }

    /**** Helper function to read from the serial ****/
    private boolean print_bytes(RadioConfigBox rc){
        if(board_message != null){
            println("Radios_Config: " + board_message.toString());
            rcStringReceived = board_message.toString();
            if(rcStringReceived.equals("Failure: System is Down")) {
                rcStringReceived = "Cyton dongle could not connect to the board. Perhaps they are on different channels? \n\nTry pressing Auto-Scan.";
            } else if (rcStringReceived.equals("Success: System is Up")) {
                rcStringReceived = "Success: Cyton and Dongle are paired. \n\nReady to Start Session!";
            } else if (!overridePressed && autoscanPressed && rcStringReceived.startsWith("Success: Host override")) {
                rcStringReceived = "Please press Auto-Scan one more time.";
            }
            rc.print_onscreen(rcStringReceived);
            return true;
        } else {
            println("Radios_Config: Error reading from Serial/COM port");
            rc.print_onscreen("Error reading from Serial port.\n\nTry a different port?");
            return false;
        }
    }

    private boolean print_bytes(){
        if(board_message != null){
            verbosePrint("Radios_Config: " + board_message.toString());
            rcStringReceived = board_message.toString();
            if(rcStringReceived.equals("Failure: System is Down")) {
                rcStringReceived = "Cyton dongle could not connect to the board. Perhaps they are on different channels? Try pressing Auto-Scan.";
            } else if (rcStringReceived.equals("Success: System is Up")) {
                rcStringReceived = "Success: Cyton and Dongle are paired. \n\nReady to Start Session!";
            } else if (rcStringReceived.startsWith("Success: Host override")) {
                rcStringReceived = "Please press Auto-Scan one more time.";
            }
            return true;
        } else {
            println("CytonAutoConnect: Error reading from Serial/COM port");
            return false;
        }
    }

    public void closeSerialPort() {
        if (serial_direct_board != null) {
            serial_direct_board.stop();
        }
        serial_direct_board = null;
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
//                       This sketch saves and loads User Settings that appear during Sessions.
//                       -- All Time Series widget settings in Live, Playback, and Synthetic modes
//                       -- All FFT widget settings
//                       -- Default Layout, Board Mode, and other Global Settings
//                       -- Networking Mode and All settings for active networking protocol
//                       -- Accelerometer, Analog Read, Head Plot, Band Power, and Spectrogram
//                       -- Widget/Container Pairs
//                       -- OpenBCI Data Format Settings (.txt and .csv)
//                       Created: Richard Waltman - May/June 2018
//
//    -- Start System first!
//    -- Lowercase 'n' to Save
//    -- Capital 'N' to Load
//    -- Functions saveGUIsettings() and loadGUISettings() are called:
//        - during system initialization between checkpoints 4 and 5
//        - in Interactivty.pde with the rest of the keyboard shortcuts
//        - in TopNav.pde when "Config" --> "Save Settings" || "Load Settings" is clicked
//    -- This allows User to store snapshots of most GUI settings in Users/.../Documents/OpenBCI_GUI/Settings/
//    -- After loading, only a few actions are required: start/stop the data stream and networking streams, open/close serial port
//
//      Tips on adding a new setting:
//      -- figure out if the setting is Global, in an existing widget, or in a new class or widget
//      -- read the comments
//      -- once you find the right place to add your setting, you can copy the surrounding style
//      -- uses JSON keys
//      -- Example2: GUI version and settings version
//      -- Requires new JSON key 'version` and settingsVersion
//
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////
//   SessionSettings Class    //
/////////////////////////////////
class SessionSettings {
    //Current version to save to JSON
    String settingsVersion = "3.0.0";
    //for screen resizing
    boolean screenHasBeenResized = false;
    float timeOfLastScreenResize = 0;
    int widthOfLastScreen = 0;
    int heightOfLastScreen = 0;
    //default layout variables
    int currentLayout;
    //Used to time the GUI intro animation
    int introAnimationInit = 0;
    final int introAnimationDuration = 2500;
    //Max File Size #461, default option 4 -> 60 minutes
    public final String[] fileDurations = {"5 Minutes", "15 minutes", "30 Minutes", "60 Minutes", "120 Minutes", "No Limit"};
    public final int[] fileDurationInts = {5, 15, 30, 60, 120, -1};
    public final int defaultOBCIMaxFileSize = 3; //4th option from the above list
    private boolean logFileIsOpen = false;
    private long logFileStartTime;
    private long logFileMaxDurationNano = -1;
    //this is a global CColor that determines the style of all widget dropdowns ... this should go in WidgetManager.pde
    CColor dropdownColors = new CColor();
    ///These `Save` vars are set to default when each widget instantiates
    ///and updated every time user selects from dropdown
    //Accelerometer settings
    int accVertScaleSave;
    int accHorizScaleSave;
    //FFT plot settings,
    int fftMaxFrqSave;
    int fftMaxuVSave;
    int fftLogLinSave;
    int fftSmoothingSave;
    int fftFilterSave;
    //Analog Read settings
    int arVertScaleSave;
    int arHorizScaleSave;
    //Headplot settings
    int hpIntensitySave;
    int hpPolaritySave;
    int hpContoursSave;
    int hpSmoothingSave;
    //default data types for streams 1-4 in Networking widget
    int nwDataType1;
    int nwDataType2;
    int nwDataType3;
    int nwDataType4;
    String nwSerialPort;
    int nwProtocolSave;
    //Used to check if a playback file has data
    int minNumRowsPlaybackFile = PApplet.parseInt(currentBoard.getSampleRate());
    //Spectrogram Widget settings
    int spectMaxFrqSave;
    int spectSampleRateSave;
    int spectLogLinSave;

    //default configuration settings file location and file name variables
    private String sessionPath = "";
    final String[] userSettingsFiles = {
        "CytonUserSettings.json",
        "DaisyUserSettings.json",
        "GanglionUserSettings.json",
        "PlaybackUserSettings.json",
        "SynthFourUserSettings.json",
        "SynthEightUserSettings.json",
        "SynthSixteenUserSettings.json"
        };
    final String[] defaultSettingsFiles = {
        "CytonDefaultSettings.json",
        "DaisyDefaultSettings.json",
        "GanglionDefaultSettings.json",
        "PlaybackDefaultSettings.json",
        "SynthFourDefaultSettings.json",
        "SynthEightDefaultSettings.json",
        "SynthSixteenDefaultSettings.json"
        };

    //Used to print the status of each channel in the console when loading settings
    String[] channelsActiveArray = {"Active", "Not Active"};
    String[] gainSettingsArray = { "x1", "x2", "x4", "x6", "x8", "x12", "x24"};
    String[] inputTypeArray = { "Normal", "Shorted", "BIAS_MEAS", "MVDD", "Temp.", "Test", "BIAS_DRP", "BIAS_DRN"};
    String[] biasIncludeArray = {"Don't Include", "Include"};
    String[] srb2SettingArray = {"Off", "On"};
    String[] srb1SettingArray = {"Off", "On"};

    //Used to set text in dropdown menus when loading FFT settings
    String[] fftMaxFrqArray = {"20 Hz", "40 Hz", "60 Hz", "100 Hz", "120 Hz", "250 Hz", "500 Hz", "800 Hz"};
    String[] fftVertScaleArray = {"10 uV", "50 uV", "100 uV", "1000 uV"};
    String[] fftLogLinArray = {"Log", "Linear"}; //share this with spectrogram also
    String[] fftSmoothingArray = {"0.0", "0.5", "0.75", "0.9", "0.95", "0.98", "0.99", "0.999"};
    String[] fftFilterArray = {"Filtered", "Unfilt."};

    //Used to set text in dropdown menus when loading Accelerometer settings
    String[] accVertScaleArray = {"Auto","1 g", "2 g", "4 g"};
    String[] accHorizScaleArray = {"Sync", "1 sec", "3 sec", "5 sec", "10 sec", "20 sec"};

    //Used to set text in dropdown menus when loading Analog Read settings
    String[] arVertScaleArray = {"Auto", "50", "100", "200", "400", "1000", "10000"};
    String[] arHorizScaleArray = {"Sync", "1 sec", "3 sec", "5 sec", "10 sec", "20 sec"};

    //Used to set text in dropdown menus when loading Head Plot settings
    String[] hpIntensityArray = {"4x", "2x", "1x", "0.5x", "0.2x", "0.02x"};
    String[] hpPolarityArray = {"+/-", " + "};
    String[] hpContoursArray = {"ON", "OFF"};
    String[] hpSmoothingArray = {"0.0", "0.5", "0.75", "0.9", "0.95", "0.98"};

    //Used to set text in dropdown menus when loading Spectrogram Setings
    String[] spectMaxFrqArray = {"20 Hz", "40 Hz", "60 Hz", "100 Hz", "120 Hz", "250 Hz"};
    String[] spectSampleRateArray = {"30 Min.", "6 Min.", "3 Min.", "1.5 Min.", "1 Min."};

    //Load Accel. dropdown variables
    int loadAccelVertScale;
    int loadAccelHorizScale;

    //Load Analog Read dropdown variables
    int loadAnalogReadVertScale;
    int loadAnalogReadHorizScale;

    //Load FFT dropdown variables
    int fftMaxFrqLoad;
    int fftMaxuVLoad;
    int fftLogLinLoad;
    int fftSmoothingLoad;
    int fftFilterLoad;

    //Load Headplot dropdown variables
    int hpIntensityLoad;
    int hpPolarityLoad;
    int hpContoursLoad;
    int hpSmoothingLoad;

    //Band Power widget settings
    //smoothing and filter dropdowns are linked to FFT, so no need to save again
    List<Integer> loadBPActiveChans = new ArrayList<Integer>();

    //Spectrogram widget settings
    List<Integer> loadSpectActiveChanTop = new ArrayList<Integer>();
    List<Integer> loadSpectActiveChanBot = new ArrayList<Integer>();
    int spectMaxFrqLoad;
    int spectSampleRateLoad;
    int spectLogLinLoad;

    //Networking Settings save/load variables
    int nwProtocolLoad;
    //OSC load variables
    String nwOscIp1Load;  String nwOscIp2Load;  String nwOscIp3Load;  String nwOscIp4Load;
    String nwOscPort1Load;  String nwOscPort2Load;  String nwOscPort3Load;  String nwOscPort4Load;
    //UDP load variables
    String nwUdpIp1Load;  String nwUdpIp2Load;  String nwUdpIp3Load;
    String nwUdpPort1Load;  String nwUdpPort2Load;  String nwUdpPort3Load;
    //LSL load variables
    String nwLSLName1Load;  String nwLSLName2Load;  String nwLSLName3Load;
    String nwLSLType1Load;  String nwLSLType2Load;  String nwLSLType3Load;
    //Serial load variables
    int nwSerialBaudRateLoad;

    //EMG Widget
    List<Integer> loadEmgActiveChannels = new ArrayList<Integer>();

    //EMG Joystick Widget
    int loadEmgJoystickSmoothing;
    List<Integer> loadEmgJoystickInputs = new ArrayList<Integer>();

    //Primary JSON objects for saving and loading data
    private JSONObject saveSettingsJSONData;
    private JSONObject loadSettingsJSONData;

    private final String kJSONKeyDataInfo = "dataInfo";
    private final String kJSONKeyTimeSeries = "timeSeries";
    private final String kJSONKeySettings = "settings";
    private final String kJSONKeyFFT = "fft";
    private final String kJSONKeyAccel = "accelerometer";
    private final String kJSONKeyNetworking = "networking";
    private final String kJSONKeyHeadplot = "headplot";
    private final String kJSONKeyBandPower = "bandPower";
    private final String kJSONKeyWidget = "widget";
    private final String kJSONKeyVersion = "version";
    private final String kJSONKeySpectrogram = "spectrogram";
    private final String kJSONKeyEmg = "emg";
    private final String kJSONKeyEmgJoystick = "emgJoystick";

    //used only in this class to count the number of channels being used while saving/loading, this gets updated in updateToNChan whenever the number of channels being used changes
    int slnchan;
    int numChanloaded;
    boolean chanNumError = false;
    int numLoadedWidgets;
    String [] loadedWidgetsArray;
    int loadFramerate;
    int loadDatasource;
    boolean dataSourceError = false;

    String saveDialogName; //Used when Save button is pressed
    String loadDialogName; //Used when Load button is pressed
    String controlEventDataSource; //Used for output message on system start
    Boolean errorUserSettingsNotFound = false; //For error catching
    int loadErrorTimerStart;
    int loadErrorTimeWindow = 5000; //Time window in milliseconds to apply channel settings to Cyton board. This is to avoid a GUI crash at ~ 4500-5000 milliseconds.
    Boolean loadErrorCytonEvent = false;
    final int initTimeoutThreshold = 12000; //Timeout threshold in milliseconds

    SessionSettings() {
        //Instantiated on app start in OpenBCI_GUI.pde
        dropdownColors.setActive((int)BUTTON_PRESSED); //bg color of box when pressed
        dropdownColors.setForeground((int)BUTTON_HOVER); //when hovering over any box (primary or dropdown)
        dropdownColors.setBackground((int)color(255)); //bg color of boxes (including primary)
        dropdownColors.setCaptionLabel((int)color(1, 18, 41)); //color of text in primary box
        // dropdownColors.setValueLabel((int)color(1, 18, 41)); //color of text in all dropdown boxes
        dropdownColors.setValueLabel((int)color(100)); //color of text in all dropdown boxes

        setLogFileDurationChoice(defaultOBCIMaxFileSize);
    }

    ///////////////////////////////////
    // OpenBCI Data Format Functions //
    ///////////////////////////////////

    public void setLogFileIsOpen (boolean _toggle) {
        logFileIsOpen = _toggle;
    }

    public boolean isLogFileOpen() {
        return logFileIsOpen;
    }

    public void setLogFileStartTime(long _time) {
        logFileStartTime = _time;
        verbosePrint("Settings: LogFileStartTime = " + _time);
    }

    public void setLogFileDurationChoice(int choice) {
        logFileMaxDurationNano = fileDurationInts[choice] * 1000000000L * 60;
        println("Settings: LogFileMaxDuration = " + fileDurationInts[choice] + " minutes");
    }

    //Only called during live mode && using OpenBCI Data Format
    public boolean maxLogTimeReached() {
        if (logFileMaxDurationNano < 0) {
            return false;
        } else {
            return (System.nanoTime() - logFileStartTime) > (logFileMaxDurationNano);
        }
    }

    public void setSessionPath (String _path) {
        sessionPath = _path;
    }

    public String getSessionPath() {
        //println("SESSIONPATH==",sessionPath, millis());
        return sessionPath;
    }

    ////////////////////////////////////////////////////////////////
    //               Init GUI Software Settings                   //
    //                                                            //
    //  - Called during system initialization in OpenBCI_GUI.pde  //
    ////////////////////////////////////////////////////////////////
    public void init() {
        String defaultSettingsFileToSave = getPath("Default", eegDataSource, nchan);
        int defaultNumChanLoaded = 0;
        int defaultLoadedDataSource = 0;
        String defaultSettingsVersion = "";
        String defaultGUIVersion = "";

        //Take a snapshot of the default GUI settings on every system init
        println("InitSettings: Saving Default Settings to file!");
        try {
            this.save(defaultSettingsFileToSave); //to avoid confusion with save() image
        } catch (Exception e) {
            outputError("Failed to save Default Settings during Init. Please submit an Issue on GitHub.");
            e.printStackTrace();
        }
    }

    ///////////////////////////////
    //      Save GUI Settings    //
    ///////////////////////////////
    public void save(String saveGUISettingsFileLocation) {

        //Set up a JSON array
        saveSettingsJSONData = new JSONObject();

        //Save the number of channels being used and eegDataSource in the first object
        JSONObject saveNumChannelsData = new JSONObject();
        saveNumChannelsData.setInt("Channels", slnchan);
        saveNumChannelsData.setInt("Data Source", eegDataSource);
        //println("Settings: NumChan: " + slnchan);
        saveSettingsJSONData.setJSONObject(kJSONKeyDataInfo, saveNumChannelsData);

        //Make a new JSON Object for Time Series Settings
        JSONObject saveTSSettings = new JSONObject();
        saveTSSettings.setInt("Time Series Vert Scale", w_timeSeries.getTSVertScale().getIndex());
        saveTSSettings.setInt("Time Series Horiz Scale", w_timeSeries.getTSHorizScale().getIndex());
        //Save data from the Active channel checkBoxes
        JSONArray saveActiveChanTS = new JSONArray();
        int numActiveTSChan = w_timeSeries.tsChanSelect.activeChan.size();
        for (int i = 0; i < numActiveTSChan; i++) {
            int activeChan = w_timeSeries.tsChanSelect.activeChan.get(i);
            saveActiveChanTS.setInt(i, activeChan);
        }
        saveTSSettings.setJSONArray("activeChannels", saveActiveChanTS);
        saveSettingsJSONData.setJSONObject(kJSONKeyTimeSeries, saveTSSettings);

        //Make a second JSON object within our JSONArray to store Global settings for the GUI
        JSONObject saveGlobalSettings = new JSONObject();
        saveGlobalSettings.setInt("Current Layout", currentLayout);
        saveGlobalSettings.setInt("Analog Read Vert Scale", arVertScaleSave);
        saveGlobalSettings.setInt("Analog Read Horiz Scale", arHorizScaleSave);
        if (currentBoard instanceof SmoothingCapableBoard) {
            saveGlobalSettings.setBoolean("Data Smoothing", ((SmoothingCapableBoard)currentBoard).getSmoothingActive());
        }
        saveSettingsJSONData.setJSONObject(kJSONKeySettings, saveGlobalSettings);

        /////Setup JSON Object for gui version and settings Version
        JSONObject saveVersionInfo = new JSONObject();
        saveVersionInfo.setString("gui", localGUIVersionString);
        saveVersionInfo.setString("settings", settingsVersion);
        saveSettingsJSONData.setJSONObject(kJSONKeyVersion, saveVersionInfo);

        ///////////////////////////////////////////////Setup new JSON object to save FFT settings
        JSONObject saveFFTSettings = new JSONObject();

        //Save FFT_Max Freq Setting. The max frq variable is updated every time the user selects a dropdown in the FFT widget
        saveFFTSettings.setInt("FFT_Max Freq", fftMaxFrqSave);
        //Save FFT_Max uV Setting. The max uV variable is updated also when user selects dropdown in the FFT widget
        saveFFTSettings.setInt("FFT_Max uV", fftMaxuVSave);
        //Save FFT_LogLin Setting. Same thing happens for LogLin
        saveFFTSettings.setInt("FFT_LogLin", fftLogLinSave);
        //Save FFT_Smoothing Setting
        saveFFTSettings.setInt("FFT_Smoothing", fftSmoothingSave);
        //Save FFT_Filter Setting
        if (isFFTFiltered == true)  fftFilterSave = 0;
        if (isFFTFiltered == false)  fftFilterSave = 1;
        saveFFTSettings.setInt("FFT_Filter",  fftFilterSave);
        //Set the FFT JSON Object
        saveSettingsJSONData.setJSONObject(kJSONKeyFFT, saveFFTSettings); //next object will be set to slnchan+3, etc.

        ///////////////////////////////////////////////Setup new JSON object to save Accelerometer settings
        JSONObject saveAccSettings = new JSONObject();
        saveAccSettings.setInt("Accelerometer Vert Scale", accVertScaleSave);
        saveAccSettings.setInt("Accelerometer Horiz Scale", accHorizScaleSave);
        saveSettingsJSONData.setJSONObject(kJSONKeyAccel, saveAccSettings);

        ///////////////////////////////////////////////Setup new JSON object to save Networking settings
        JSONObject saveNetworkingSettings = new JSONObject();
        //Save Protocol
        saveNetworkingSettings.setInt("Protocol", nwProtocolSave);//***Save User networking protocol mode
        switch(nwProtocolSave) {
            case 3:
                for (int i = 1; i <= 4; i++) {
                    saveNetworkingSettings.setInt("OSC_DataType"+i, (Integer) w_networking.getCP5Map().get(w_networking.dataTypeNames.get(i-1)));
                    saveNetworkingSettings.setString("OSC_ip"+i, (String) w_networking.getCP5Map().get("OSC_ip"+i));
                    saveNetworkingSettings.setString("OSC_port"+i, (String) w_networking.getCP5Map().get("OSC_port"+i));
                }
                break;
            case 2:
                for (int i = 1; i <= 3; i++) {
                    saveNetworkingSettings.setInt("UDP_DataType"+i, (Integer) w_networking.getCP5Map().get(w_networking.dataTypeNames.get(i-1)));
                    saveNetworkingSettings.setString("UDP_ip"+i, (String) w_networking.getCP5Map().get("UDP_ip"+i));
                    saveNetworkingSettings.setString("UDP_port"+i, (String) w_networking.getCP5Map().get("UDP_port"+i));
                }
                break;
            case 1:
                for (int i = 1; i <= 3; i++) {
                    saveNetworkingSettings.setInt("LSL_DataType"+i, (Integer) w_networking.getCP5Map().get(w_networking.dataTypeNames.get(i-1)));
                    saveNetworkingSettings.setString("LSL_name"+i, (String) w_networking.getCP5Map().get("LSL_name"+i));
                    saveNetworkingSettings.setString("LSL_type"+i, (String) w_networking.getCP5Map().get("LSL_type"+i));
                }
                break;
            case 0:
                saveNetworkingSettings.setInt("Serial_DataType1", (Integer) w_networking.getCP5Map().get("dataType1"));
                saveNetworkingSettings.setInt("Serial_baudrate", (Integer) w_networking.getCP5Map().get("baud_rate"));
                saveNetworkingSettings.setString("Serial_portName", (String) w_networking.getCP5Map().get("port_name"));
                break;
        }//end of networking proctocol switch
        //Set Networking Settings JSON Object
        saveSettingsJSONData.setJSONObject(kJSONKeyNetworking, saveNetworkingSettings);

        ///////////////////////////////////////////////Setup new JSON object to save Headplot settings
        JSONObject saveHeadplotSettings = new JSONObject();

        //Save Headplot Intesity
        saveHeadplotSettings.setInt("HP_intensity", hpIntensitySave);
        //Save Headplot Polarity
        saveHeadplotSettings.setInt("HP_polarity", hpPolaritySave);
        //Save Headplot contours
        saveHeadplotSettings.setInt("HP_contours", hpContoursSave);
        //Save Headplot Smoothing Setting
        saveHeadplotSettings.setInt("HP_smoothing", hpSmoothingSave);
        //Set the Headplot JSON Object
        saveSettingsJSONData.setJSONObject(kJSONKeyHeadplot, saveHeadplotSettings);

        ///////////////////////////////////////////////Setup new JSON object to save Band Power settings
        JSONObject saveBPSettings = new JSONObject();

        //Save data from the Active channel checkBoxes
        JSONArray saveActiveChanBP = new JSONArray();
        int numActiveBPChan = w_bandPower.bpChanSelect.activeChan.size();
        for (int i = 0; i < numActiveBPChan; i++) {
            int activeChan = w_bandPower.bpChanSelect.activeChan.get(i);
            saveActiveChanBP.setInt(i, activeChan);
        }
        saveBPSettings.setJSONArray("activeChannels", saveActiveChanBP);
        saveSettingsJSONData.setJSONObject(kJSONKeyBandPower, saveBPSettings);

        ///////////////////////////////////////////////Setup new JSON object to save Spectrogram settings
        JSONObject saveSpectrogramSettings = new JSONObject();
        //Save data from the Active channel checkBoxes - Top
        JSONArray saveActiveChanSpectTop = new JSONArray();
        int numActiveSpectChanTop = w_spectrogram.spectChanSelectTop.activeChan.size();
        for (int i = 0; i < numActiveSpectChanTop; i++) {
            int activeChan = w_spectrogram.spectChanSelectTop.activeChan.get(i);
            saveActiveChanSpectTop.setInt(i, activeChan);
        }
        saveSpectrogramSettings.setJSONArray("activeChannelsTop", saveActiveChanSpectTop);
        //Save data from the Active channel checkBoxes - Bottom
        JSONArray saveActiveChanSpectBot = new JSONArray();
        int numActiveSpectChanBot = w_spectrogram.spectChanSelectBot.activeChan.size();
        for (int i = 0; i < numActiveSpectChanBot; i++) {
            int activeChan = w_spectrogram.spectChanSelectBot.activeChan.get(i);
            saveActiveChanSpectBot.setInt(i, activeChan);
        }
        saveSpectrogramSettings.setJSONArray("activeChannelsBot", saveActiveChanSpectBot);
        //Save Spectrogram_Max Freq Setting. The max frq variable is updated every time the user selects a dropdown in the spectrogram widget
        saveSpectrogramSettings.setInt("Spectrogram_Max Freq", spectMaxFrqSave);
        saveSpectrogramSettings.setInt("Spectrogram_Sample Rate", spectSampleRateSave);
        saveSpectrogramSettings.setInt("Spectrogram_LogLin", spectLogLinSave);
        saveSettingsJSONData.setJSONObject(kJSONKeySpectrogram, saveSpectrogramSettings);

        ///////////////////////////////////////////////Setup new JSON object to save EMG Settings
        JSONObject saveEMGSettings = new JSONObject();

        //Save data from the Active channel checkBoxes
        JSONArray saveActiveChanEMG = new JSONArray();
        int numActiveEMGChan = w_emg.emgChannelSelect.activeChan.size();
        for (int i = 0; i < numActiveEMGChan; i++) {
            int activeChan = w_emg.emgChannelSelect.activeChan.get(i);
            saveActiveChanEMG.setInt(i, activeChan);
        }
        saveEMGSettings.setJSONArray("activeChannels", saveActiveChanEMG);
        saveSettingsJSONData.setJSONObject(kJSONKeyEmg, saveEMGSettings);

        ///////////////////////////////////////////////Setup new JSON object to save EMG Joystick Settings
        JSONObject saveEmgJoystickSettings = new JSONObject();
        saveEmgJoystickSettings.setInt("smoothing", w_emgJoystick.joystickSmoothing.getIndex());
        JSONArray saveEmgJoystickInputs = new JSONArray();
        int numEmgJoystickInputs = w_emgJoystick.emgJoystickInputs.length;
        for (int i = 0; i < numEmgJoystickInputs; i++) {
            saveEmgJoystickInputs.setInt(i, w_emgJoystick.emgJoystickInputs[i].getIndex());
        }
        saveEmgJoystickSettings.setJSONArray("joystickInputs", saveEmgJoystickInputs);
        saveSettingsJSONData.setJSONObject(kJSONKeyEmgJoystick, saveEmgJoystickSettings);

        ///////////////////////////////////////////////Setup new JSON object to save Widgets Active in respective Containers
        JSONObject saveWidgetSettings = new JSONObject();

        int numActiveWidgets = 0;
        //Save what Widgets are active and respective Container number (see Containers.pde)
        for (int i = 0; i < wm.widgets.size(); i++) { //increment through all widgets
            if (wm.widgets.get(i).getIsActive()) { //If a widget is active...
                numActiveWidgets++; //increment numActiveWidgets
                //println("Widget" + i + " is active");
                // activeWidgets.add(i); //keep track of the active widget
                int containerCountsave = wm.widgets.get(i).currentContainer;
                //println("Widget " + i + " is in Container " + containerCountsave);
                saveWidgetSettings.setInt("Widget_"+i, containerCountsave);
            } else if (!wm.widgets.get(i).getIsActive()) { //If a widget is not active...
                saveWidgetSettings.remove("Widget_"+i); //remove non-active widget from JSON
                //println("widget"+i+" is not active");
            }
        }
        println("SessionSettings: " + numActiveWidgets + " active widgets saved!");
        //Print what widgets are in the containers used by current layout for only the number of active widgets
        //for (int i = 0; i < numActiveWidgets; i++) {
            //int containerCounter = wm.layouts.get(currentLayout).containerInts[i];
            //println("Container " + containerCounter + " is available"); //For debugging
        //}
        saveSettingsJSONData.setJSONObject(kJSONKeyWidget, saveWidgetSettings);

        /////////////////////////////////////////////////////////////////////////////////
        ///ADD more global settings above this line in the same formats as above/////////

        //Let's save the JSON array to a file!
        saveJSONObject(saveSettingsJSONData, saveGUISettingsFileLocation);

    }  //End of Save GUI Settings function

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                                                Load GUI Settings                                                       //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public void load(String loadGUISettingsFileLocation) throws Exception {
        //Load all saved User Settings from a JSON file if it exists
        loadSettingsJSONData = loadJSONObject(loadGUISettingsFileLocation);

        verbosePrint(loadSettingsJSONData.toString());

        //Check the number of channels saved to json first!
        JSONObject loadDataSettings = loadSettingsJSONData.getJSONObject(kJSONKeyDataInfo);
        numChanloaded = loadDataSettings.getInt("Channels");
        //Print error if trying to load a different number of channels
        if (numChanloaded != slnchan) {
            println("Channels being loaded from " + loadGUISettingsFileLocation + " don't match channels being used!");
            chanNumError = true;
            throw new Exception();
        } else {
            chanNumError = false;
        }
        //Check the Data Source integer next: Cyton = 0, Ganglion = 1, Playback = 2, Synthetic = 3
        loadDatasource = loadDataSettings.getInt("Data Source");
        verbosePrint("loadGUISettings: Data source loaded: " + loadDatasource + ". Current data source: " + eegDataSource);
        //Print error if trying to load a different data source (ex. Live != Synthetic)
        if (loadDatasource != eegDataSource) {
            println("Data source being loaded from " + loadGUISettingsFileLocation + " doesn't match current data source.");
            dataSourceError = true;
            throw new Exception();
        } else {
            dataSourceError = false;
        }

        //get the global settings JSON object
        JSONObject loadGlobalSettings = loadSettingsJSONData.getJSONObject(kJSONKeySettings);
        //Store loaded layout to current layout variable
        currentLayout = loadGlobalSettings.getInt("Current Layout");
        loadAnalogReadVertScale = loadGlobalSettings.getInt("Analog Read Vert Scale");
        loadAnalogReadHorizScale = loadGlobalSettings.getInt("Analog Read Horiz Scale");
        //Load more global settings after this line, if needed
        Boolean loadDataSmoothingSetting = (currentBoard instanceof SmoothingCapableBoard) ? loadGlobalSettings.getBoolean("Data Smoothing") : null;

        //get the FFT settings
        JSONObject loadFFTSettings = loadSettingsJSONData.getJSONObject(kJSONKeyFFT);
        fftMaxFrqLoad = loadFFTSettings.getInt("FFT_Max Freq");
        fftMaxuVLoad = loadFFTSettings.getInt("FFT_Max uV");
        fftLogLinLoad = loadFFTSettings.getInt("FFT_LogLin");
        fftSmoothingLoad = loadFFTSettings.getInt("FFT_Smoothing");
        fftFilterLoad = loadFFTSettings.getInt("FFT_Filter");

        //get the Accelerometer settings
        JSONObject loadAccSettings = loadSettingsJSONData.getJSONObject(kJSONKeyAccel);
        loadAccelVertScale = loadAccSettings.getInt("Accelerometer Vert Scale");
        loadAccelHorizScale = loadAccSettings.getInt("Accelerometer Horiz Scale");

        //get the Networking Settings
        JSONObject loadNetworkingSettings = loadSettingsJSONData.getJSONObject(kJSONKeyNetworking);
        nwProtocolLoad = loadNetworkingSettings.getInt("Protocol");
        switch (nwProtocolLoad)  {
            case 3:
                nwDataType1 = loadNetworkingSettings.getInt("OSC_DataType1");
                nwDataType2 = loadNetworkingSettings.getInt("OSC_DataType2");
                nwDataType3 = loadNetworkingSettings.getInt("OSC_DataType3");
                nwDataType4 = loadNetworkingSettings.getInt("OSC_DataType4");
                nwOscIp1Load = loadNetworkingSettings.getString("OSC_ip1");
                nwOscIp2Load = loadNetworkingSettings.getString("OSC_ip2");
                nwOscIp3Load = loadNetworkingSettings.getString("OSC_ip3");
                nwOscIp4Load = loadNetworkingSettings.getString("OSC_ip4");
                nwOscPort1Load = loadNetworkingSettings.getString("OSC_port1");
                nwOscPort2Load = loadNetworkingSettings.getString("OSC_port2");
                nwOscPort3Load = loadNetworkingSettings.getString("OSC_port3");
                nwOscPort4Load = loadNetworkingSettings.getString("OSC_port4");
                break;
            case 2:
                nwDataType1 = loadNetworkingSettings.getInt("UDP_DataType1");
                nwDataType2 = loadNetworkingSettings.getInt("UDP_DataType2");
                nwDataType3 = loadNetworkingSettings.getInt("UDP_DataType3");
                nwUdpIp1Load = loadNetworkingSettings.getString("UDP_ip1");
                nwUdpIp2Load = loadNetworkingSettings.getString("UDP_ip2");
                nwUdpIp3Load = loadNetworkingSettings.getString("UDP_ip3");
                nwUdpPort1Load = loadNetworkingSettings.getString("UDP_port1");
                nwUdpPort2Load = loadNetworkingSettings.getString("UDP_port2");
                nwUdpPort3Load = loadNetworkingSettings.getString("UDP_port3");
                break;
            case 1:
                nwDataType1 = loadNetworkingSettings.getInt("LSL_DataType1");
                nwDataType2 = loadNetworkingSettings.getInt("LSL_DataType2");
                nwDataType3 = loadNetworkingSettings.getInt("LSL_DataType3");
                nwLSLName1Load = loadNetworkingSettings.getString("LSL_name1");
                nwLSLName2Load = loadNetworkingSettings.getString("LSL_name2");
                nwLSLName3Load = loadNetworkingSettings.getString("LSL_name3");
                nwLSLType1Load = loadNetworkingSettings.getString("LSL_type1");
                nwLSLType2Load = loadNetworkingSettings.getString("LSL_type2");
                nwLSLType3Load = loadNetworkingSettings.getString("LSL_type3");
                break;
            case 0:
                nwDataType1 = loadNetworkingSettings.getInt("Serial_DataType1");
                nwSerialBaudRateLoad = loadNetworkingSettings.getInt("Serial_baudrate");
                nwSerialPort = loadNetworkingSettings.getString("Serial_portName");
                break;
        } //end switch case for all networking types

        //get the  Headplot settings
        JSONObject loadHeadplotSettings = loadSettingsJSONData.getJSONObject(kJSONKeyHeadplot);
        hpIntensityLoad = loadHeadplotSettings.getInt("HP_intensity");
        hpPolarityLoad = loadHeadplotSettings.getInt("HP_polarity");
        hpContoursLoad = loadHeadplotSettings.getInt("HP_contours");
        hpSmoothingLoad = loadHeadplotSettings.getInt("HP_smoothing");

        //Get Band Power widget settings
        loadBPActiveChans.clear();
        JSONObject loadBPSettings = loadSettingsJSONData.getJSONObject(kJSONKeyBandPower);
        JSONArray loadBPChan = loadBPSettings.getJSONArray("activeChannels");
        for (int i = 0; i < loadBPChan.size(); i++) {
            loadBPActiveChans.add(loadBPChan.getInt(i));
        }
        //println("Settings: band power active chans loaded = " + loadBPActiveChans );

        try {
            //Get Spectrogram widget settings
            loadSpectActiveChanTop.clear();
            loadSpectActiveChanBot.clear();
            JSONObject loadSpectSettings = loadSettingsJSONData.getJSONObject(kJSONKeySpectrogram);
            JSONArray loadSpectChanTop = loadSpectSettings.getJSONArray("activeChannelsTop");
            for (int i = 0; i < loadSpectChanTop.size(); i++) {
                loadSpectActiveChanTop.add(loadSpectChanTop.getInt(i));
            }
            JSONArray loadSpectChanBot = loadSpectSettings.getJSONArray("activeChannelsBot");
            for (int i = 0; i < loadSpectChanBot.size(); i++) {
                loadSpectActiveChanBot.add(loadSpectChanBot.getInt(i));
            }
            spectMaxFrqLoad = loadSpectSettings.getInt("Spectrogram_Max Freq");
            spectSampleRateLoad = loadSpectSettings.getInt("Spectrogram_Sample Rate");
            spectLogLinLoad = loadSpectSettings.getInt("Spectrogram_LogLin");
            //println(loadSpectActiveChanTop, loadSpectActiveChanBot);
        } catch (Exception e) {
            e.printStackTrace();
        }

        //Get EMG widget settings
        loadEmgActiveChannels.clear();
        JSONObject loadEmgSettings = loadSettingsJSONData.getJSONObject(kJSONKeyEmg);
        JSONArray loadEmgChan = loadEmgSettings.getJSONArray("activeChannels");
        for (int i = 0; i < loadEmgChan.size(); i++) {
            loadEmgActiveChannels.add(loadEmgChan.getInt(i));
        }

        //Get EMG Joystick widget settings
        JSONObject loadEmgJoystickSettings = loadSettingsJSONData.getJSONObject(kJSONKeyEmgJoystick);
        loadEmgJoystickSmoothing = loadEmgJoystickSettings.getInt("smoothing");
        loadEmgJoystickInputs.clear();
        JSONArray loadJoystickInputsJson = loadEmgJoystickSettings.getJSONArray("joystickInputs");
        for (int i = 0; i < loadJoystickInputsJson.size(); i++) {
            loadEmgJoystickInputs.add(loadJoystickInputsJson.getInt(i));
        }

        //get the  Widget/Container settings
        JSONObject loadWidgetSettings = loadSettingsJSONData.getJSONObject(kJSONKeyWidget);
        //Apply Layout directly before loading and applying widgets to containers
        wm.setNewContainerLayout(currentLayout);
        verbosePrint("LoadGUISettings: Layout " + currentLayout + " Loaded!");
        numLoadedWidgets = loadWidgetSettings.size();


        //int numActiveWidgets = 0; //reset the counter
        for (int w = 0; w < wm.widgets.size(); w++) { //increment through all widgets
            if (wm.widgets.get(w).getIsActive()) { //If a widget is active...
                verbosePrint("Deactivating widget [" + w + "]");
                wm.widgets.get(w).setIsActive(false);
                //numActiveWidgets++; //counter the number of de-activated widgets
            }
        }

        //Store the Widget number keys from JSON to a string array
        loadedWidgetsArray = (String[]) loadWidgetSettings.keys().toArray(new String[loadWidgetSettings.size()]);
        //printArray(loadedWidgetsArray);
        int widgetToActivate = 0;
        for (int w = 0; w < numLoadedWidgets; w++) {
                String [] loadWidgetNameNumber = split(loadedWidgetsArray[w], '_');
                //Store the value of the widget to be activated
                widgetToActivate = Integer.valueOf(loadWidgetNameNumber[1]);
                //Load the container for the current widget[w]
                int containerToApply = loadWidgetSettings.getInt(loadedWidgetsArray[w]);

                wm.widgets.get(widgetToActivate).setIsActive(true);//activate the new widget
                wm.widgets.get(widgetToActivate).setContainer(containerToApply);//map it to the container that was loaded!
                println("LoadGUISettings: Applied Widget " + widgetToActivate + " to Container " + containerToApply);
        }//end case for all widget/container settings

        /////////////////////////////////////////////////////////////
        //    Load more widget settings above this line as above   //
        /////////////////////////////////////////////////////////////

        /////////////////////////////////////////////////////////////
        //              Apply Settings below this line             //
        /////////////////////////////////////////////////////////////

        //Apply Data Smoothing for capable boards
        if (currentBoard instanceof SmoothingCapableBoard) {
            ((SmoothingCapableBoard)currentBoard).setSmoothingActive(loadDataSmoothingSetting);
            topNav.updateSmoothingButtonText();
        }

        //Load and apply all of the settings that are in dropdown menus. It's a bit much, so it has it's own function below.
        loadApplyWidgetDropdownText();

        //Apply Time Series Settings Last!!!
        loadApplyTimeSeriesSettings();

        //Force headplot to redraw if it is active
        int hpWidgetNumber;
        if (eegDataSource == DATASOURCE_GANGLION) {
            hpWidgetNumber = 6;
        } else {
            hpWidgetNumber = 5;
        }
        if (wm.widgets.get(hpWidgetNumber).getIsActive()) {
            w_headPlot.headPlot.setPositionSize(w_headPlot.headPlot.hp_x, w_headPlot.headPlot.hp_y, w_headPlot.headPlot.hp_w, w_headPlot.headPlot.hp_h, w_headPlot.headPlot.hp_win_x, w_headPlot.headPlot.hp_win_y);
            println("Headplot is active: Redrawing");
        }
    } //end of loadGUISettings
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private void loadApplyWidgetDropdownText() {

        ////////Apply Time Series dropdown settings in loadApplyTimeSeriesSettings() instead of here

        ////////Apply FFT settings
        MaxFreq(fftMaxFrqLoad); //This changes the back-end
            w_fft.cp5_widget.getController("MaxFreq").getCaptionLabel().setText(fftMaxFrqArray[fftMaxFrqLoad]); //This changes front-end... etc.

        VertScale(fftMaxuVLoad);
            w_fft.cp5_widget.getController("VertScale").getCaptionLabel().setText(fftVertScaleArray[fftMaxuVLoad]);

        LogLin(fftLogLinLoad);
            w_fft.cp5_widget.getController("LogLin").getCaptionLabel().setText(fftLogLinArray[fftLogLinLoad]);

        Smoothing(fftSmoothingLoad);
            w_fft.cp5_widget.getController("Smoothing").getCaptionLabel().setText(fftSmoothingArray[fftSmoothingLoad]);

        UnfiltFilt(fftFilterLoad);
            w_fft.cp5_widget.getController("UnfiltFilt").getCaptionLabel().setText(fftFilterArray[fftFilterLoad]);

        ////////Apply Accelerometer settings;
        accelVertScale(loadAccelVertScale);
            w_accelerometer.cp5_widget.getController("accelVertScale").getCaptionLabel().setText(accVertScaleArray[loadAccelVertScale]);

        accelDuration(loadAccelHorizScale);
            w_accelerometer.cp5_widget.getController("accelDuration").getCaptionLabel().setText(accHorizScaleArray[loadAccelHorizScale]);

        ////////Apply Anolog Read dropdowns to Live Cyton Only
        if (eegDataSource == DATASOURCE_CYTON) {
            ////////Apply Analog Read settings
            VertScale_AR(loadAnalogReadVertScale);
                w_analogRead.cp5_widget.getController("VertScale_AR").getCaptionLabel().setText(arVertScaleArray[loadAnalogReadVertScale]);

            Duration_AR(loadAnalogReadHorizScale);
                w_analogRead.cp5_widget.getController("Duration_AR").getCaptionLabel().setText(arHorizScaleArray[loadAnalogReadHorizScale]);
        }

        ////////////////////////////Apply Headplot settings
        Intensity(hpIntensityLoad);
            w_headPlot.cp5_widget.getController("Intensity").getCaptionLabel().setText(hpIntensityArray[hpIntensityLoad]);

        Polarity(hpPolarityLoad);
            w_headPlot.cp5_widget.getController("Polarity").getCaptionLabel().setText(hpPolarityArray[hpPolarityLoad]);

        ShowContours(hpContoursLoad);
            w_headPlot.cp5_widget.getController("ShowContours").getCaptionLabel().setText(hpContoursArray[hpContoursLoad]);

        SmoothingHeadPlot(hpSmoothingLoad);
            w_headPlot.cp5_widget.getController("SmoothingHeadPlot").getCaptionLabel().setText(hpSmoothingArray[hpSmoothingLoad]);

        //Force redraw headplot on load. Fixes issue where heaplot draws outside of the widget.
        w_headPlot.headPlot.setPositionSize(w_headPlot.headPlot.hp_x, w_headPlot.headPlot.hp_y, w_headPlot.headPlot.hp_w, w_headPlot.headPlot.hp_h, w_headPlot.headPlot.hp_win_x, w_headPlot.headPlot.hp_win_y);

        ////////////////////////////Apply Band Power settings
        try {
            //apply channel checkbox settings
            w_bandPower.bpChanSelect.deactivateAllButtons();;
            for (int i = 0; i < loadBPActiveChans.size(); i++) {
                w_bandPower.bpChanSelect.setToggleState(loadBPActiveChans.get(i), true);
            }
        } catch (Exception e) {
            println("Settings: Exception caught applying band power settings " + e);
        }
        verbosePrint("Settings: Band Power Active Channels: " + loadBPActiveChans);

        ////////////////////////////Apply Spectrogram settings
        //Apply Max Freq dropdown
        SpectrogramMaxFreq(spectMaxFrqLoad);
            w_spectrogram.cp5_widget.getController("SpectrogramMaxFreq").getCaptionLabel().setText(spectMaxFrqArray[spectMaxFrqLoad]);
        SpectrogramSampleRate(spectSampleRateLoad);
            w_spectrogram.cp5_widget.getController("SpectrogramSampleRate").getCaptionLabel().setText(spectSampleRateArray[spectSampleRateLoad]);
        SpectrogramLogLin(spectLogLinLoad);
            w_spectrogram.cp5_widget.getController("SpectrogramLogLin").getCaptionLabel().setText(fftLogLinArray[spectLogLinLoad]);
        try {
            //apply channel checkbox settings
            w_spectrogram.spectChanSelectTop.deactivateAllButtons();
            w_spectrogram.spectChanSelectBot.deactivateAllButtons();
            for (int i = 0; i < loadSpectActiveChanTop.size(); i++) {
                w_spectrogram.spectChanSelectTop.setToggleState(loadSpectActiveChanTop.get(i), true);
            }
            for (int i = 0; i < loadSpectActiveChanBot.size(); i++) {
                w_spectrogram.spectChanSelectBot.setToggleState(loadSpectActiveChanBot.get(i), true);
            }
        } catch (Exception e) {
            println("Settings: Exception caught applying spectrogram settings channel bar " + e);
        }
        println("Settings: Spectrogram Active Channels: TOP - " + loadSpectActiveChanTop + " || BOT - " + loadSpectActiveChanBot);

        ///////////Apply Networking Settings
        //Update protocol with loaded value
        Protocol(nwProtocolLoad);
        //Update dropdowns and textfields in the Networking widget with loaded values
        w_networking.cp5_widget.getController("Protocol").getCaptionLabel().setText(w_networking.protocols.get(nwProtocolLoad)); //Reference the dropdown from the appropriate widget
        switch (nwProtocolLoad) {
            case 3:  //Apply OSC if loaded
                println("Apply OSC Networking Mode");
                w_networking.cp5_networking_dropdowns.getController("dataType1").getCaptionLabel().setText(w_networking.dataTypes.get(nwDataType1)); //Set text on frontend
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setValue(nwDataType1); //Set value in backend
                w_networking.cp5_networking_dropdowns.getController("dataType2").getCaptionLabel().setText(w_networking.dataTypes.get(nwDataType2)); //etc...
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setValue(nwDataType2);
                w_networking.cp5_networking_dropdowns.getController("dataType3").getCaptionLabel().setText(w_networking.dataTypes.get(nwDataType3));
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setValue(nwDataType3);
                w_networking.cp5_networking_dropdowns.getController("dataType4").getCaptionLabel().setText(w_networking.dataTypes.get(nwDataType4));
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").setValue(nwDataType4);
                w_networking.cp5_networking.get(Textfield.class, "OSC_ip1").setText(nwOscIp1Load); //Simply set the text for text boxes
                w_networking.cp5_networking.get(Textfield.class, "OSC_ip2").setText(nwOscIp2Load); //The strings are referenced on command
                w_networking.cp5_networking.get(Textfield.class, "OSC_ip3").setText(nwOscIp3Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_ip4").setText(nwOscIp4Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_port1").setText(nwOscPort1Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_port2").setText(nwOscPort2Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_port3").setText(nwOscPort3Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_port4").setText(nwOscPort4Load);
                break;
            case 2:  //Apply UDP if loaded
                println("Apply UDP Networking Mode");
                w_networking.cp5_networking_dropdowns.getController("dataType1").getCaptionLabel().setText(w_networking.dataTypes.get(nwDataType1)); //Set text on frontend
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setValue(nwDataType1); //Set value in backend
                w_networking.cp5_networking_dropdowns.getController("dataType2").getCaptionLabel().setText(w_networking.dataTypes.get(nwDataType2)); //etc...
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setValue(nwDataType2);
                w_networking.cp5_networking_dropdowns.getController("dataType3").getCaptionLabel().setText(w_networking.dataTypes.get(nwDataType3));
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setValue(nwDataType3);
                w_networking.cp5_networking.get(Textfield.class, "UDP_ip1").setText(nwUdpIp1Load);
                w_networking.cp5_networking.get(Textfield.class, "UDP_ip2").setText(nwUdpIp2Load);
                w_networking.cp5_networking.get(Textfield.class, "UDP_ip3").setText(nwUdpIp3Load);
                w_networking.cp5_networking.get(Textfield.class, "UDP_port1").setText(nwUdpPort1Load);
                w_networking.cp5_networking.get(Textfield.class, "UDP_port2").setText(nwUdpPort2Load);
                w_networking.cp5_networking.get(Textfield.class, "UDP_port3").setText(nwUdpPort3Load);
                break;
            case 1:  //Apply LSL if loaded
                println("Apply LSL Networking Mode");
                w_networking.cp5_networking_dropdowns.getController("dataType1").getCaptionLabel().setText(w_networking.dataTypes.get(nwDataType1)); //Set text on frontend
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setValue(nwDataType1); //Set value in backend
                w_networking.cp5_networking_dropdowns.getController("dataType2").getCaptionLabel().setText(w_networking.dataTypes.get(nwDataType2)); //etc...
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setValue(nwDataType2);
                w_networking.cp5_networking_dropdowns.getController("dataType3").getCaptionLabel().setText(w_networking.dataTypes.get(nwDataType3));
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setValue(nwDataType3);
                w_networking.cp5_networking.get(Textfield.class, "LSL_name1").setText(nwLSLName1Load);
                w_networking.cp5_networking.get(Textfield.class, "LSL_name2").setText(nwLSLName2Load);
                w_networking.cp5_networking.get(Textfield.class, "LSL_name3").setText(nwLSLName3Load);
                w_networking.cp5_networking.get(Textfield.class, "LSL_type1").setText(nwLSLType1Load);
                w_networking.cp5_networking.get(Textfield.class, "LSL_type2").setText(nwLSLType2Load);
                w_networking.cp5_networking.get(Textfield.class, "LSL_type3").setText(nwLSLType3Load);
                break;
            case 0:  //Apply Serial if loaded
                println("Apply Serial Networking Mode");
                w_networking.cp5_networking_dropdowns.getController("dataType1").getCaptionLabel().setText(w_networking.dataTypes.get(nwDataType1)); //Set text on frontend
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setValue(nwDataType1); //Set value in backend
                w_networking.cp5_networking_baudRate.getController("baud_rate").getCaptionLabel().setText(w_networking.baudRates.get(nwSerialBaudRateLoad)); //Set text
                w_networking.cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").setValue(nwSerialBaudRateLoad); //Set value in backend

                //Look for the portName in the dropdown list
                int listSize = w_networking.cp5_networking_portName.get(ScrollableList.class, "port_name").getItems().size();
                for (int i = 0; i < listSize; i++) {
                    String s = w_networking.cp5_networking_portName.get(ScrollableList.class, "port_name").getItem(i).get("name").toString();
                    if (s.equals(nwSerialPort)) {
                        verbosePrint("Settings: NWSerial: Found com port " + s + " !");
                        w_networking.cp5_networking_portName.getController("port_name").getCaptionLabel().setText(s);
                        w_networking.cp5_networking_portName.get(ScrollableList.class, "port_name").setValue(i);
                        break;
                    } else {
                        if (i == listSize - 1) verbosePrint("Settings: NWSerial: Port not found...");
                    }
                }
                break;
        }//end switch-case for networking settings for all networking protocols

        ////////////////////////////Apply EMG widget settings
        try {
            //apply channel checkbox settings
            w_emg.emgChannelSelect.deactivateAllButtons();;
            for (int i = 0; i < loadEmgActiveChannels.size(); i++) {
                w_emg.emgChannelSelect.setToggleState(loadEmgActiveChannels.get(i), true);
            }
        } catch (Exception e) {
            println("Settings: Exception caught applying EMG widget settings " + e);
        }
        verbosePrint("Settings: EMG Widget Active Channels: " + loadEmgActiveChannels);

        ////////////////////////////Apply EMG Joystick settings
        w_emgJoystick.setJoystickSmoothing(loadEmgJoystickSmoothing);
        w_emgJoystick.cp5_widget.getController("emgJoystickSmoothingDropdown").getCaptionLabel()
                .setText(EmgJoystickSmoothing.getEnumStringsAsList().get(loadEmgJoystickSmoothing));
        try {
            for (int i = 0; i < loadEmgJoystickInputs.size(); i++) {
                w_emgJoystick.updateJoystickInput(i, loadEmgJoystickInputs.get(i));
            }
        } catch (Exception e) {
            println("Settings: Exception caught applying EMG Joystick settings " + e);
        }

        ////////////////////////////////////////////////////////////
        //    Apply more loaded widget settings above this line   //

    } //end of loadApplyWidgetDropdownText()

    private void loadApplyTimeSeriesSettings() {

        JSONObject loadTimeSeriesSettings = loadSettingsJSONData.getJSONObject(kJSONKeyTimeSeries);
        ////////Apply Time Series widget settings
        w_timeSeries.setTSVertScale(loadTimeSeriesSettings.getInt("Time Series Vert Scale"));
        w_timeSeries.cp5_widget.getController("VertScale_TS").getCaptionLabel().setText(w_timeSeries.getTSVertScale().getString()); //changes front-end
        
        w_timeSeries.setTSHorizScale(loadTimeSeriesSettings.getInt("Time Series Horiz Scale"));
        w_timeSeries.cp5_widget.getController("Duration").getCaptionLabel().setText(w_timeSeries.getTSHorizScale().getString());

        JSONArray loadTSChan = loadTimeSeriesSettings.getJSONArray("activeChannels");
        w_timeSeries.tsChanSelect.deactivateAllButtons();
        try {
            for (int i = 0; i < loadTSChan.size(); i++) {
                w_timeSeries.tsChanSelect.setToggleState(loadTSChan.getInt(i), true);
            }
        } catch (Exception e) {
            println("Settings: Exception caught applying time series settings " + e);
        }
        verbosePrint("Settings: Time Series Active Channels: " + loadBPActiveChans);
            
    } //end loadApplyTimeSeriesSettings

    /**
      * @description Used in TopNav when user clicks ClearSettings->AreYouSure->Yes
      * @params none
      * Output Success message to bottom of GUI when done
      */
    public void clearAll() {
        for (File file: new File(directoryManager.getSettingsPath()).listFiles())
            if (!file.isDirectory())
                file.delete();
        controlPanel.recentPlaybackBox.rpb_cp5.get(ScrollableList.class, "recentPlaybackFilesCP").clear();
        controlPanel.recentPlaybackBox.shortFileNames.clear();
        controlPanel.recentPlaybackBox.longFilePaths.clear();
        outputSuccess("All settings have been cleared!");
    }

    /**
      * @description Used in System Init, TopNav, and Interactivity
      * @params mode="User"or"Default", dataSource, and number of channels
      * @returns {String} - filePath or Error if mode not specified correctly
      */
    public String getPath(String _mode, int dataSource, int _nchan) {
        String filePath = directoryManager.getSettingsPath();
        String[] fileNames = new String[7];
        if (_mode.equals("Default")) {
            fileNames = defaultSettingsFiles;
        } else if (_mode.equals("User")) {
            fileNames = userSettingsFiles;
        } else {
            filePath = "Error";
        }
        if (!filePath.equals("Error")) {
            if (dataSource == DATASOURCE_CYTON) {
                filePath += (_nchan == NCHAN_CYTON) ?
                    fileNames[0] :
                    fileNames[1];
            } else if (dataSource == DATASOURCE_GANGLION) {
                filePath += fileNames[2];
            } else if (dataSource ==  DATASOURCE_PLAYBACKFILE) {
                filePath += fileNames[3];
            } else if (dataSource == DATASOURCE_SYNTHETIC) {
                if (_nchan == NCHAN_GANGLION) {
                    filePath += fileNames[4];
                } else if (_nchan == NCHAN_CYTON) {
                    filePath += fileNames[5];
                } else {
                    filePath += fileNames[6];
                }
            }
        }
        return filePath;
    }

    public void initCheckPointFive() {
        outputSuccess("Session started!");
    }

    public void loadKeyPressed() {
        loadErrorTimerStart = millis();
        String settingsFileToLoad = getPath("User", eegDataSource, nchan);
        try {
            load(settingsFileToLoad);
            errorUserSettingsNotFound = false;
        } catch (Exception e) {
            //println(e.getMessage());
            e.printStackTrace();
            println(settingsFileToLoad + " not found or other error. Save settings with keyboard 'n' or using dropdown menu.");
            errorUserSettingsNotFound = true;
        }
        //Output message when Loading settings is complete
        String err = null;
        if (chanNumError == false && dataSourceError == false && errorUserSettingsNotFound == false && loadErrorCytonEvent == false) {
            outputSuccess("Settings Loaded!");
        } else if (chanNumError) {
            err = "Invalid number of channels";
        } else if (dataSourceError) {
            err = "Invalid data source";
        } else if (errorUserSettingsNotFound) {
            err = settingsFileToLoad + " not found.";
        }

        //Only try to delete file for SettingsNotFound/Broken settings
        if (err != null && (!chanNumError && !dataSourceError)) {
            println("Load Settings Error: " + err);
            File f = new File(settingsFileToLoad);
            if (f.exists()) {
                if (f.delete()) {
                    outputError("Found old/broken GUI settings. Please reconfigure the GUI and save new settings.");
                } else {
                    outputError("SessionSettings: Error deleting old/broken settings file...");
                }
            }
        }
    }

    public void saveButtonPressed() {
        if (saveDialogName == null) {
            selectOutput("Save a custom settings file as JSON:",
                        "saveConfigFile",
                        dataFile(settings.getPath("User", eegDataSource, nchan)));
        } else {
            println("saveSettingsFileName = " + saveDialogName);
            saveDialogName = null;
        }
    }

    public void loadButtonPressed() {
        //Select file to load from dialog box
        if (loadDialogName == null) {
            selectInput("Load a custom settings file from JSON:", "loadConfigFile");
            saveDialogName = null;
        } else {
            println("loadSettingsFileName = " + loadDialogName);
            loadDialogName = null;
        }
    }

    public void defaultButtonPressed() {
        //Revert GUI to default settings that were flashed on system start!
        String defaultSettingsFileToLoad = getPath("Default", eegDataSource, nchan);
        try {
            //Load all saved User Settings from a JSON file to see if it exists
            JSONObject loadDefaultSettingsJSONData = loadJSONObject(defaultSettingsFileToLoad);
            this.load(defaultSettingsFileToLoad);
            outputSuccess("Default Settings Loaded!");
        } catch (Exception e) {
            outputError("Default Settings Error: Valid Default Settings will be saved next system start.");
            File f = new File(defaultSettingsFileToLoad);
            if (f.exists()) {
                if (f.delete()) {
                    println("SessionSettings: Old/Broken Default Settings file succesfully deleted.");
                } else {
                    println("SessionSettings: Error deleting Default Settings file...");
                }
            }
        }
    }

} //end of Software Settings class

//////////////////////////////////////////
//  Global Functions                    //
// Called by Buttons with the same name //
//////////////////////////////////////////
// Select file to save custom settings using dropdown in TopNav.pde
public void saveConfigFile(File selection) {
    if (selection == null) {
        println("SessionSettings: saveConfigFile: Window was closed or the user hit cancel.");
    } else {
        println("SessionSettings: saveConfigFile: User selected " + selection.getAbsolutePath());
        settings.saveDialogName = selection.getAbsolutePath();
        settings.save(settings.saveDialogName); //save current settings to JSON file in SavedData
        outputSuccess("Settings Saved! Using Expert Mode, you can load these settings using 'N' key. Click \"Default\" to revert to factory settings."); //print success message to screen
        settings.saveDialogName = null; //reset this variable for future use
    }
}
// Select file to load custom settings using dropdown in TopNav.pde
public void loadConfigFile(File selection) {
    if (selection == null) {
        println("SessionSettings: loadConfigFile: Window was closed or the user hit cancel.");
    } else {
        println("SessionSettings: loadConfigFile: User selected " + selection.getAbsolutePath());
        //output("You have selected \"" + selection.getAbsolutePath() + "\" to Load custom settings.");
        settings.loadDialogName = selection.getAbsolutePath();
        try {
            settings.load(settings.loadDialogName); //load settings from JSON file in /data/
            //Output success message when Loading settings is complete without errors
            if (settings.chanNumError == false
                && settings.dataSourceError == false
                && settings.loadErrorCytonEvent == false) {
                    outputSuccess("Settings Loaded!");
                }
        } catch (Exception e) {
            println("SessionSettings: Incompatible settings file or other error");
            if (settings.chanNumError == true) {
                outputError("Settings Error:  Channel Number Mismatch Detected");
            } else if (settings.dataSourceError == true) {
                outputError("Settings Error: Data Source Mismatch Detected");
            } else {
                outputError("Error trying to load settings file, possibly from previous GUI. Removing old settings.");
                if (selection.exists()) selection.delete();
            }
        }
        settings.loadDialogName = null; //reset this variable for future use
    }
}
class SignalCheckThresholdUI {

    private Textfield thresholdTF;
    private String name;
    private final int textfieldHeight = 14;
    private int defaultValue_Percentage;
    private int defaultValue_kOhms;
    private int valuePercentage;
    private int valuekOhms;
    private CytonSignalCheckMode signalCheckMode;
    private int textColor = OPENBCI_DARKBLUE;
    private boolean hasUpdatedTextColor = false;

    SignalCheckThresholdUI(ControlP5 _cp5, String _name, int _x, int _y, int _w, int _h, int _textColor, CytonSignalCheckMode _mode) {
        signalCheckMode = _mode;
        name = _name;
        textColor = _textColor;
        defaultValue_Percentage = name.equals("errorThreshold") ? 90 : 75;
        valuePercentage = defaultValue_Percentage;
        defaultValue_kOhms = name == "errorThreshold" ? 2500 : 750;
        valuekOhms = defaultValue_kOhms;
        thresholdTF = createTextfield(_cp5, _name, 0, _x, _y, _w, _h, _textColor);
        updateTextfieldModeChanged(_mode);
        //textfieldHeight = _h;
    }

    public void update() {
        if (!hasUpdatedTextColor) {
            thresholdTF.setColorValueLabel(textColor);
            thresholdTF.setColorActive(textColor);
            hasUpdatedTextColor = true;
        }

        textfieldUpdateHelper.checkTextfield(thresholdTF);
    }

    public void updateTextfieldModeChanged(CytonSignalCheckMode _mode) {
        signalCheckMode = _mode;
        customThreshold(thresholdTF, getTextfieldIntVal());
    }

    private Textfield createTextfield(ControlP5 _cp5, String name, int intValue, int _x, int _y, int _w, int _h, int _textColor) {
        //Create these textfields under cp5_widget base instance so because they are always visible
        final Textfield myTextfield = _cp5.addTextfield(name)
            .setPosition(_x, _y)
            .setCaptionLabel("")
            .setSize(_w, _h)
            .setFont(f5)
            .setFocus(false)
            .setColor(color(26, 26, 26))
            .setColorBackground(color(255, 255, 255)) // text field bg color
            .setColorValueLabel(_textColor)  // text color
            .setColorForeground(color(210))  // border color when not selected - grey
            .setColorActive(isSelected_color)  // border color when selected - green
            .setColorCursor(color(26, 26, 26))
            .setText("%") //set the text
            .align(5, 10, 20, 40)
            .setAutoClear(false)
            ; //Don't clear textfield when pressing Enter key
        //Clear textfield on double click
        myTextfield.onDoublePress(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                output("SessionData: Enter your custom session name.");
                myTextfield.clear();
            }
        });
        //Autogenerate session name if user presses Enter key and textfield value is null
        myTextfield.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST && myTextfield.getText().equals("")) {
                    setTextfieldVal(getDefaultTextfieldIntVal());
                    customThreshold(myTextfield, getDefaultTextfieldIntVal());
                }
                //Pressing ENTER in the Textfield triggers a "Broadcast"
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                    //Try to clean up typing accidents from user input in Textfield
                    String rcvString = theEvent.getController().getStringValue().replaceAll("[A-Za-z!@#$%^&()=/*_]","");
                    int rcvAsInt = NumberUtils.toInt(rcvString);
                    if (rcvAsInt <= 0) {
                        rcvAsInt = 0; //Only positive values will be used here
                    }
                    setTextfieldVal(rcvAsInt);
                    customThreshold(myTextfield, rcvAsInt);
                }
            }
        });
        //Autogenerate session name if user leaves textfield and value is null
        myTextfield.onReleaseOutside(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (!myTextfield.isActive() && myTextfield.getText().equals("")) {
                    setTextfieldVal(getDefaultTextfieldIntVal());
                    customThreshold(myTextfield, getDefaultTextfieldIntVal());
                }
            }
        });
        return myTextfield;
    }
    
    private void customThreshold(Textfield tf, int value) {
        StringBuilder sb = new StringBuilder();
        sb.append(value);
        sb.append(isSignalCheckRailedMode() ? "%" : " k\u2126");
        tf.setText(sb.toString());
    }

    public void setPosition(int _x, int _y) {
        thresholdTF.setPosition(_x, _y);
    }

    private int getDefaultTextfieldIntVal() {
        return isSignalCheckRailedMode() ? defaultValue_Percentage : defaultValue_kOhms;
    }

    private int getTextfieldIntVal() {
        return isSignalCheckRailedMode() ? valuePercentage : valuekOhms;
    }

    private void setTextfieldVal(int val) {
        if (isSignalCheckRailedMode()) {
            if (name == "errorThreshold") {
                for (int i = 0; i < nchan; i++) {
                    is_railed[i].setRailedThreshold((double) val);
                }
            } else {
                for (int i = 0; i < nchan; i++) {
                    is_railed[i].setRailedWarnThreshold((double) val);
                }
            }
            valuePercentage = val;
        } else {
            if (name == "errorThreshold") {
                w_cytonImpedance.updateElectrodeStatusYellowThreshold((double)val);
            } else {
                w_cytonImpedance.updateElectrodeStatusGreenThreshold((double)val);
            }
            valuekOhms = val;
        }
    }

    private boolean isSignalCheckRailedMode() {
        return signalCheckMode == CytonSignalCheckMode.LIVE;
    }
};
interface SmoothingCapableBoard {

    public void setSmoothingActive(boolean active);

    public boolean getSmoothingActive();
};



interface TTQTimeProvider {
    public int getMS();
}

class RealTimeProvider implements TTQTimeProvider {
    public int getMS() {
        return millis();
    }
}

// For unit testing, we can pass this mock TTQTimeProvider
// that controls time
class FakeTimeProvider implements TTQTimeProvider {
    private int ms = 0;

    public int getMS() {
        return ms;
    }

    public void addMS(int _ms) {
        ms += _ms;
    }
}

public class TimeTrackingQueue<T> extends Thread {
    private int maxTimeMillis;
    private LinkedList<Integer> timeList = new LinkedList<Integer>();
    private LinkedList<T> objectList = new LinkedList<T>();
    private TTQTimeProvider timeProvider;

    public TimeTrackingQueue(int _maxTimeMillis) {
        this(_maxTimeMillis, new RealTimeProvider());
    }

    public TimeTrackingQueue (int _maxTimeMillis, TTQTimeProvider _timeProvider) {
        this.maxTimeMillis = _maxTimeMillis;
        this.timeProvider = _timeProvider;
        start(); // start thread the checks expiration
    }

    public synchronized void push(T object) {
        timeList.push(timeProvider.getMS());
        objectList.push(object);
    }

    public void run() {
        while(true) {
            if(!expireLast()) {
                delay(1); // wait one millisecond
            }
        }
    }

    // if we have an item to expire, remove it
    private synchronized boolean expireLast() {
        if (!timeList.isEmpty() && timeList.peekLast() + maxTimeMillis < timeProvider.getMS()) {
            timeList.removeLast();
            objectList.removeLast();
            return true;
        }

        return false;
    }

    public synchronized int size() {
        return objectList.size();
    }

    public synchronized List<T> getLastData(int milliseconds) {
        int endIndex = 0;

        if(objectList.size() == 0) {
            return objectList.subList(0, 0);
        }

        ListIterator<Integer> iter = timeList.listIterator();
        while(iter.hasNext()) {
            int nextIndex = iter.nextIndex();
            if(iter.next() + milliseconds < timeProvider.getMS()) {
                break; // we are done
            }
            else {
                endIndex = nextIndex;
            }
        }

        // sublist excludes the last index so we need to add 1 to be accurate
        List<T> data = objectList.subList(0, endIndex + 1);
        // return a copy of the sublist, because this list can be modified on a separate thread
        return new ArrayList<T>(data);


        
    }
}
///////////////////////////////////////////////////////////////////////////////////////
//
//  Created by Conor Russomanno, 11/3/16
//  Extracting old code Gui_Manager.pde, adding new features for GUI v2 launch
//
//  Edited by Richard Waltman 9/24/18
//  Refactored by Richard Waltman 11/9/2020
//  Added feature to check GUI version using "latest version" tag on Github
///////////////////////////////////////////////////////////////////////////////////////





class TopNav {

    private final int TOPNAV_DARKBLUE = OPENBCI_BLUE;
    private final int SUBNAV_LIGHTBLUE = buttonsLightBlue;
    private int strokeColor = OPENBCI_DARKBLUE;

    private ControlP5 topNav_cp5;

    public Button controlPanelCollapser;

    public Button toggleDataStreamingButton;

    public Button filtersButton;
    public Button smoothingButton;

    public Button debugButton;
    public Button tutorialsButton;
    public Button shopButton;
    public Button issuesButton;
    public Button updateGuiVersionButton;

    public Button layoutButton;
    public Button settingsButton;

    public LayoutSelector layoutSelector;
    public TutorialSelector tutorialSelector;
    public ConfigSelector configSelector;
    private int previousSystemMode = 0;

    private boolean secondaryNavInit = false;

    private final int PAD_3 = 3;
    private final int DEBUG_BUT_W = 33;
    private final int TOPRIGHT_BUT_W = 80;
    private final int DATASTREAM_BUT_W = 170;
    private final int SUBNAV_BUT_Y = 35;
    private final int SUBNAV_BUT_W = 70;
    private final int SUBNAV_BUT_H = 26;
    private final int TOPNAV_BUT_H = SUBNAV_BUT_H;

    private boolean topNavDropdownMenuIsOpen = false;

    TopNav() {
        int controlPanel_W = 256;

        //Instantiate local cp5 for this box
        topNav_cp5 = new ControlP5(ourApplet);
        topNav_cp5.setGraphics(ourApplet, 0, 0);
        topNav_cp5.setAutoDraw(false);

        //TOP LEFT OF GUI
        createControlPanelCollapser("System Control Panel", PAD_3, PAD_3, controlPanel_W, TOPNAV_BUT_H, h3, 16, TOPNAV_DARKBLUE, WHITE);

        //TOP RIGHT OF GUI, FROM LEFT<---Right
        createDebugButton(" ", width - DEBUG_BUT_W - PAD_3, PAD_3, DEBUG_BUT_W, TOPNAV_BUT_H, h3, 16, TOPNAV_DARKBLUE, WHITE);
        createTutorialsButton("Help", (int)debugButton.getPosition()[0] - TOPRIGHT_BUT_W - PAD_3, PAD_3, TOPRIGHT_BUT_W, TOPNAV_BUT_H, h3, 16, TOPNAV_DARKBLUE, WHITE);
        createIssuesButton("Issues", (int)tutorialsButton.getPosition()[0] - TOPRIGHT_BUT_W - PAD_3, PAD_3, TOPRIGHT_BUT_W, TOPNAV_BUT_H, h3, 16, TOPNAV_DARKBLUE, WHITE);
        createShopButton("Shop", (int)issuesButton.getPosition()[0] - TOPRIGHT_BUT_W - PAD_3, PAD_3, TOPRIGHT_BUT_W, TOPNAV_BUT_H, h3, 16, TOPNAV_DARKBLUE, WHITE);
        createUpdateGuiButton("Update", (int)shopButton.getPosition()[0] - TOPRIGHT_BUT_W - PAD_3, PAD_3, TOPRIGHT_BUT_W, TOPNAV_BUT_H, h3, 16, TOPNAV_DARKBLUE, WHITE);

        //SUBNAV TOP RIGHT
        createTopNavSettingsButton("Settings", width - SUBNAV_BUT_W - PAD_3, SUBNAV_BUT_Y, SUBNAV_BUT_W, SUBNAV_BUT_H, h4, 14, SUBNAV_LIGHTBLUE, WHITE);

        layoutSelector = new LayoutSelector();
        tutorialSelector = new TutorialSelector();
        configSelector = new ConfigSelector();

        //updateNavButtonsBasedOnColorScheme();
    }

    public void initSecondaryNav() {

        boolean needToMakeSmoothingButton = (currentBoard instanceof SmoothingCapableBoard) && smoothingButton == null;

        if (!secondaryNavInit) {
            //Buttons on the left side of the GUI secondary nav bar
            createToggleDataStreamButton(stopButton_pressToStart_txt, PAD_3, SUBNAV_BUT_Y, DATASTREAM_BUT_W, SUBNAV_BUT_H, h4, 14, TURN_ON_GREEN, OPENBCI_DARKBLUE);
            createFiltersButton("Filters", PAD_3*2 + toggleDataStreamingButton.getWidth(), SUBNAV_BUT_Y, SUBNAV_BUT_W, SUBNAV_BUT_H, h4, 14, SUBNAV_LIGHTBLUE, WHITE);

            //Appears at Top Right SubNav while in a Session
            createLayoutButton("Layout", width - 3 - 60, SUBNAV_BUT_Y, 60, SUBNAV_BUT_H, h4, 14, SUBNAV_LIGHTBLUE, WHITE);
            secondaryNavInit = true;
        }

        if (needToMakeSmoothingButton) {
            int pos_x = (int)filtersButton.getPosition()[0] + filtersButton.getWidth() + PAD_3;
            //Make smoothing button wider than most other topnav buttons to fit text comfortably
            createSmoothingButton(getSmoothingString(), pos_x, SUBNAV_BUT_Y, SUBNAV_BUT_W + 48, SUBNAV_BUT_H, h4, 14, SUBNAV_LIGHTBLUE, WHITE);
        }
        
        
        //updateSecondaryNavButtonsColor();
    }

    public void update() {
        //ignore settings button when help dropdown is open
        settingsButton.setLock(tutorialSelector.isVisible);

        //Make sure these buttons don't get accidentally locked
        if (systemMode >= SYSTEMMODE_POSTINIT) {
            setLockTopLeftSubNavCp5Objects(controlPanel.isOpen);
        }

        if (previousSystemMode != systemMode) {
            if (systemMode >= SYSTEMMODE_POSTINIT) {
                layoutSelector.update();
                tutorialSelector.update();
                if (PApplet.parseInt(settingsButton.getPosition()[0]) != width - (SUBNAV_BUT_W*2) + 3) {
                    settingsButton.setPosition(width - (SUBNAV_BUT_W*2) + 3, SUBNAV_BUT_Y);
                    verbosePrint("TopNav: Updated Settings Button Position");
                }
            } else {
                if (PApplet.parseInt(settingsButton.getPosition()[0]) != width - 70 - 3) {
                    settingsButton.setPosition(width - 70 - 3, SUBNAV_BUT_Y);
                    verbosePrint("TopNav: Updated Settings Button Position");
                }
            }
            configSelector.update();
            previousSystemMode = systemMode;
        }
        
        boolean topNavSubClassIsOpen = layoutSelector.isVisible || configSelector.isVisible || tutorialSelector.isVisible;
        setDropdownMenuIsOpen(topNavSubClassIsOpen);
    }

    public void draw() {
        PImage logo;
        int topNavBg;
        int subNavBg;
        if (colorScheme == COLOR_SCHEME_ALTERNATIVE_A) {
            topNavBg = OPENBCI_BLUE;
            subNavBg = SUBNAV_LIGHTBLUE;
            logo = logo_white;
        } else {
            topNavBg = color(255);
            subNavBg = color(229);
            logo = logo_black;
        }

        pushStyle();
        //stroke(OPENBCI_DARKBLUE);
        fill(topNavBg);
        rect(0, 0, width, navBarHeight);
        //noStroke();
        stroke(strokeColor);
        fill(subNavBg);
        rect(-1, navBarHeight, width+2, navBarHeight);
        popStyle();

        //hide the center logo if buttons would overlap it
        if (width > 860) {
            //this is the center logo
            image(logo, width/2 - (128/2) - 2, 1, 128, 29);
        }

        //Draw these buttons during a Session
        boolean isSession = systemMode == SYSTEMMODE_POSTINIT;
        if (secondaryNavInit) {
            toggleDataStreamingButton.setVisible(isSession);
            filtersButton.setVisible(isSession);
            layoutButton.setVisible(isSession);
           
        }
        if (smoothingButton != null) {
            smoothingButton.setVisible(isSession);
        }

        //Draw CP5 Objects
        topNav_cp5.draw();

        //Draw everything in these selector boxes above all topnav cp5 objects
        layoutSelector.draw();
        tutorialSelector.draw();
        configSelector.draw();

        //Draw Console Log Image on top of cp5 object
        PImage _logo = (colorScheme == COLOR_SCHEME_DEFAULT) ? consoleImgBlue : consoleImgWhite;
        image(_logo, debugButton.getPosition()[0] + 6, debugButton.getPosition()[1] + 2, 22, 22);        
        

    }

    public void screenHasBeenResized(int _x, int _y) {
        topNav_cp5.setGraphics(ourApplet, 0, 0); //Important!
        debugButton.setPosition(width - debugButton.getWidth() - PAD_3, PAD_3);
        tutorialsButton.setPosition((int)debugButton.getPosition()[0] - TOPRIGHT_BUT_W - PAD_3, PAD_3);
        issuesButton.setPosition(tutorialsButton.getPosition()[0] - tutorialsButton.getWidth() - PAD_3, PAD_3);
        shopButton.setPosition(issuesButton.getPosition()[0] - issuesButton.getWidth() - PAD_3, PAD_3);
        updateGuiVersionButton.setPosition(shopButton.getPosition()[0] - shopButton.getWidth() - PAD_3, PAD_3);
        settingsButton.setPosition(width - settingsButton.getWidth() - PAD_3, SUBNAV_BUT_Y);

        if (systemMode == SYSTEMMODE_POSTINIT) {
            toggleDataStreamingButton.setPosition(PAD_3, SUBNAV_BUT_Y);
            filtersButton.setPosition(PAD_3*2 + toggleDataStreamingButton.getWidth(), SUBNAV_BUT_Y);

            layoutButton.setPosition(width - 3 - layoutButton.getWidth(), SUBNAV_BUT_Y);
            settingsButton.setPosition(width - (settingsButton.getWidth()*2) + PAD_3, SUBNAV_BUT_Y);
            //Make sure to re-position UI in selector boxes
            layoutSelector.screenResized();
        }
        
        tutorialSelector.screenResized();
        configSelector.screenResized();
    }

    public void mousePressed() {
        layoutSelector.mousePressed();     //pass mousePressed along to layoutSelector
        tutorialSelector.mousePressed();
        configSelector.mousePressed();
    }

    public void mouseReleased() {
        layoutSelector.mouseReleased();    //pass mouseReleased along to layoutSelector
        tutorialSelector.mouseReleased();
        configSelector.mouseReleased();
    } //end mouseReleased

    //Load data from the latest release page using Github API and compare to local version
    public Boolean guiVersionIsUpToDate() {
        //Copy the local GUI version from OpenBCI_GUI.pde
        float localVersion = getVersionAsFloat(localGUIVersionString);

        boolean internetIsConnected = pingWebsite(guiLatestVersionGithubAPI);

        if (internetIsConnected) {
            println("TopNav: Internet Connection Successful");
            //Get the latest release version from Github
            String remoteVersionString = getGUIVersionFromInternet(guiLatestVersionGithubAPI);
            float remoteVersion = getVersionAsFloat(remoteVersionString);   
            
            println("Local Version: " + localGUIVersionString + ", Latest Version: " + remoteVersionString);

            if (localVersion < remoteVersion) {
                println("GUI needs to be updated. Download at https://github.com/OpenBCI/OpenBCI_GUI/releases/latest");
                updateGuiVersionButton.setDescription("GUI needs to be updated. -- Local: " + localGUIVersionString +  " GitHub: " + remoteVersionString);
                return false;
            } else {
                println("GUI is up to date!");
                updateGuiVersionButton.setDescription("GUI is up to date! -- Local: " + localGUIVersionString +  " GitHub: " + remoteVersionString);
                return true;
            }
        } else {
            println("TopNav: Internet Connection Not Available");
            println("Local GUI Version: " + localGUIVersionString);
            updateGuiVersionButton.setDescription("Connect to internet to check GUI version. -- Local: " + localGUIVersionString);
            return null;
        }
    }

    private String getGUIVersionFromInternet(String _url) {
        String version = null;
        try {
            GetRequest get = new GetRequest(_url);
            get.send(); // program will wait untill the request is completed
            JSONObject response = parseJSONObject(get.getContent());
            version = response.getString("name");
        } catch (Exception e) {
            outputError("Network Error: Unable to resolve host @ " + _url);
        }
        return version;
    }

    //Convert version string to float using each segment as a digit.
    //Examples: 5.0.0-alpha.2 -> 500.12, 5.0.1-beta.9 -> 501.29, 5.0.1 -> 501.5
    private float getVersionAsFloat(String s) {
        float val = 0f;
        
        //Remove v
        if (s.charAt(0) == 'v') {
            String[] tempArr = split(s, 'v');
            s = tempArr[1];
        }
        
        //Check for minor version
        if (s.length() > 5) {
            String[] minorVersion = split(s, '-'); //separate the string at the dash between "5.0.0" and "alpha.2"
            s = minorVersion[0];
            String[] mv = split(minorVersion[1], '.');
            if (mv[0].equals("alpha")) {
                val += .1f;
            } else if (mv[0].equals("beta")) {
                val += .2f;
            }
            val += Integer.parseInt(mv[1]) * .01f;
        } else {
            val += .5f; //For stable version, add .5 so that it is greater than all alpha and beta versions
        }

        int[] webVersionCompareArray = PApplet.parseInt(split(s, '.'));
        val = webVersionCompareArray[0]*100 + webVersionCompareArray[1]*10 + webVersionCompareArray[2] + val;
        
        return val;
    }

    public void updateSmoothingButtonText() {
        smoothingButton.getCaptionLabel().setText(getSmoothingString());
    }

    private String getSmoothingString() {
        return ((SmoothingCapableBoard)currentBoard).getSmoothingActive() ? "Smoothing On" : "Smoothing Off";
    }

    private Button createTNButton(String name, String text, int _x, int _y, int _w, int _h, PFont _font, int _fontSize, int _bg, int _textColor) {
        return createButton(topNav_cp5, name, text, _x, _y, _w, _h, 0, _font, _fontSize, _bg, _textColor, BUTTON_HOVER, BUTTON_PRESSED, OPENBCI_DARKBLUE, -1);
    }

    private void createControlPanelCollapser(String text, int _x, int _y, int _w, int _h, PFont font, int _fontSize, int _bg, int _textColor) {
        controlPanelCollapser = createTNButton("controlPanelCollapser", text, _x, _y, _w, _h, font, _fontSize, _bg, _textColor);
        controlPanelCollapser.setSwitch(true);
        controlPanelCollapser.setOn();
        controlPanelCollapser.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
               if (controlPanelCollapser.isOn()) {
                   controlPanel.open();
               } else {
                   controlPanel.close();
               }
            }
        });
    }

    private void createToggleDataStreamButton(String text, int _x, int _y, int _w, int _h, PFont font, int _fontSize, int _bg, int _textColor) {
        toggleDataStreamingButton = createTNButton("toggleDataStreamingButton", text, _x, _y, _w, _h, font, _fontSize, _bg, _textColor);
        toggleDataStreamingButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
               stopButtonWasPressed();
            }
        });
        toggleDataStreamingButton.setDescription("Press this button to Stop/Start the data stream. Or press <SPACEBAR>");
    }

    private void createFiltersButton(String text, int _x, int _y, int _w, int _h, PFont font, int _fontSize, int _bg, int _textColor) {
        filtersButton = createTNButton("filtersButton", text, _x, _y, _w, _h, font, _fontSize, _bg, _textColor);
        filtersButton.onRelease(new CallbackListener() {
            public synchronized void controlEvent(CallbackEvent theEvent) {
                if (!filterUIPopupIsOpen) {
                    FilterUIPopup filtersUI = new FilterUIPopup();
                }
            }
        });
        filtersButton.setDescription("Here you can adjust the Filters that are applied to \"Filtered\" data.");
    }

    private void createSmoothingButton(String text, int _x, int _y, int _w, int _h, PFont font, int _fontSize, final int _bg, int _textColor) {
        SmoothingCapableBoard smoothBoard = (SmoothingCapableBoard)currentBoard;
        int bgColor = smoothBoard.getSmoothingActive() ? _bg : BUTTON_LOCKED_GREY;
        smoothingButton = createTNButton("smoothingButton", text, _x, _y, _w, _h, font, _fontSize, bgColor, _textColor);
        smoothingButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                SmoothingCapableBoard smoothBoard = (SmoothingCapableBoard)currentBoard;
                smoothBoard.setSmoothingActive(!smoothBoard.getSmoothingActive());
                smoothingButton.getCaptionLabel().setText(getSmoothingString());
                int _bgColor = smoothBoard.getSmoothingActive() ? _bg : BUTTON_LOCKED_GREY;
                smoothingButton.setColorBackground(_bgColor);
            }
        });
        smoothingButton.setDescription("The default settings for the Cyton Dongle driver can make data appear \"choppy.\" This feature will \"smooth\" the data for you. Click \"Help\" -> \"Cyton Driver Fix\" for more info. Clicking here will toggle this setting.");
    }

    private void createLayoutButton(String text, int _x, int _y, int _w, int _h, PFont font, int _fontSize, int _bg, int _textColor) {
        layoutButton = createTNButton("layoutButton", text, _x, _y, _w, _h, font, _fontSize, _bg, _textColor);
        layoutButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                //make sure that you can't open the layout selector accidentally
                if (!tutorialSelector.isVisible) {
                    //println("TopNav: Layout Dropdown Toggled");
                    layoutSelector.toggleVisibility();
                }
            }
        });
        layoutButton.setDescription("Here you can alter the overall layout of the GUI, allowing for different container configurations with more or less widgets.");
    }

    private void createDebugButton(String text, int _x, int _y, int _w, int _h, PFont font, int _fontSize, int _bg, int _textColor) {
        debugButton = createTNButton("debugButton", text, _x, _y, _w, _h, font, _fontSize, _bg, _textColor);
        debugButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
               ConsoleWindow.display();
            }
        });
        debugButton.setDescription("Click to open the Console Log window.");
    }

    private void createTutorialsButton(String text, int _x, int _y, int _w, int _h, PFont font, int _fontSize, int _bg, int _textColor) {
        tutorialsButton = createTNButton("tutorialsButton", text, _x, _y, _w, _h, font, _fontSize, _bg, _textColor);
        tutorialsButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
               tutorialSelector.toggleVisibility();
            }
        });
        tutorialsButton.setDescription("Click to find links to helpful online tutorials and getting started guides. Also, check out how to create custom widgets for the GUI!");
    }

    private void createIssuesButton(String text, int _x, int _y, int _w, int _h, PFont font, int _fontSize, int _bg, int _textColor) {
        final String helpText = "If you have suggestions or want to share a bug you've found, please create an issue on the GUI's Github repo!";
        issuesButton = createTNButton("issuesButton", text, _x, _y, _w, _h, font, _fontSize, _bg, _textColor);
        issuesButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
               openURLInBrowser("https://github.com/OpenBCI/OpenBCI_GUI/issues");
            }
        });
        issuesButton.setDescription("If you have suggestions or want to share a bug you've found, please create an issue on the GUI's Github repo!");
    }

    private void createShopButton(String text, int _x, int _y, int _w, int _h, PFont font, int _fontSize, int _bg, int _textColor) {
        shopButton = createTNButton("shopButton", text, _x, _y, _w, _h, font, _fontSize, _bg, _textColor);
        shopButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
               openURLInBrowser("https://shop.openbci.com/");
            }
        });
        shopButton.setDescription("Head to our online store to purchase the latest OpenBCI hardware and accessories.");
    }

    private void createUpdateGuiButton(String text, int _x, int _y, int _w, int _h, PFont font, int _fontSize, int _bg, int _textColor) {
        updateGuiVersionButton = createTNButton("updateGuiVersionButton", text, _x, _y, _w, _h, font, _fontSize, _bg, _textColor);
        //Attempt to compare local and remote GUI versions when TopNav is instantiated
        //This will also set the description/help-text for this cp5 button
        //Do this check on app start and store as a global variable
        guiIsUpToDate = guiVersionIsUpToDate();

        updateGuiVersionButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                //Perform check again when button is pressed. User may have connected to internet by now!
                guiIsUpToDate = guiVersionIsUpToDate();

                if (guiIsUpToDate == null) {
                    outputError("Update GUI: Unable to check for new version of GUI. Try again when connected to the internet.");
                    return;
                }

                if (!guiIsUpToDate) {
                    openURLInBrowser(guiLatestReleaseLocation);
                    outputInfo("Update GUI: Opening latest GUI release page using default browser");
                } else {
                    outputSuccess("Update GUI: Local OpenBCI GUI is up-to-date!");
                }
            }
        });

        if (guiIsUpToDate == null) {
            return;
        }

        if (!guiIsUpToDate) {
            outputWarn("Update Available! Press the \"Update\" button at the top of the GUI to download the latest version.");
        }
    }

    private void createTopNavSettingsButton(String text, int _x, int _y, int _w, int _h, PFont font, int _fontSize, int _bg, int _textColor) {
        settingsButton = createTNButton("settingsButton", text, _x, _y, _w, _h, font, _fontSize, _bg, _textColor);
        settingsButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                //make Help button and Settings button mutually exclusive
                if (!tutorialSelector.isVisible) {
                    configSelector.toggleVisibility();
                }
            }
        });
        settingsButton.setDescription("Save and Load GUI Settings! Click Default to revert to factory settings.");
    }

    //Execute this function whenver the stop button is pressed
    public void stopButtonWasPressed() {

        //Exit method if doing Cyton impedance check. Avoids a BrainFlow error.
        if (currentBoard instanceof BoardCyton && w_cytonImpedance != null) {
            Integer checkingImpOnChan = ((ImpedanceSettingsBoard)currentBoard).isCheckingImpedanceOnChannel();
            //println("isCheckingImpedanceOnAnythingEZCHECK==",w_cytonImpedance.isCheckingImpedanceOnAnything);
            if (checkingImpOnChan != null || w_cytonImpedance.cytonMasterImpedanceCheckIsActive() || w_cytonImpedance.isCheckingImpedanceOnAnything) {
                PopupMessage msg = new PopupMessage("Busy Checking Impedance", "Please turn off impedance check to begin recording the data stream.");
                println("OpenBCI_GUI::Cyton: Please turn off impedance check to begin recording the data stream.");
                return;
            }
        }

        //toggle the data transfer state of the ADS1299...stop it or start it...
        if (currentBoard.isStreaming()) {
            output("openBCI_GUI: stopButton was pressed. Stopping data transfer, wait a few seconds.");
            stopRunning();
            if (!currentBoard.isStreaming()) {
                toggleDataStreamingButton.getCaptionLabel().setText(stopButton_pressToStart_txt);
                toggleDataStreamingButton.setColorBackground(TURN_ON_GREEN);
            }
        } else { //not running
            output("openBCI_GUI: startButton was pressed. Starting data transfer, wait a few seconds.");
            startRunning();
            if (currentBoard.isStreaming()) {
                toggleDataStreamingButton.getCaptionLabel().setText(stopButton_pressToStop_txt);
                toggleDataStreamingButton.setColorBackground(TURN_OFF_RED);
                nextPlayback_millis = millis();  //used for synthesizeData and readFromFile.  This restarts the clock that keeps the playback at the right pace.
            }
        }
    }

    public boolean dataStreamingButtonIsActive() {
        return toggleDataStreamingButton.getCaptionLabel().getText().equals(stopButton_pressToStop_txt);
    }

    public void resetStartStopButton() {
        if (toggleDataStreamingButton != null) {
            toggleDataStreamingButton.getCaptionLabel().setText(stopButton_pressToStart_txt);
            toggleDataStreamingButton.setColorBackground(TURN_ON_GREEN);
        }
    }

    public void destroySmoothingButton() {
        topNav_cp5.remove("smoothingButton");
        smoothingButton = null;
    }

    public void setLockTopLeftSubNavCp5Objects(boolean _b) {
        toggleDataStreamingButton.setLock(_b);
        filtersButton.setLock(_b);
    }

    public boolean getDropdownMenuIsOpen() {
        return topNavDropdownMenuIsOpen;
    }

    public void setDropdownMenuIsOpen(boolean b) {
        topNavDropdownMenuIsOpen = b;
    }
}

class LayoutSelector {

    public int x, y, w, h, margin, b_w, b_h;
    public boolean isVisible;
    private ControlP5 layout_cp5;
    public ArrayList<Button> layoutOptions;

    LayoutSelector() {
        w = 180;
        x = width - w - 3;
        y = (navBarHeight * 2) - 3;
        margin = 6;
        b_w = (w - 5*margin)/4;
        b_h = b_w;
        h = margin*4 + b_h*3;

        isVisible = false;
        
        //Instantiate local cp5 for this box
        layout_cp5 = new ControlP5(ourApplet);
        layout_cp5.setGraphics(ourApplet, 0,0);
        layout_cp5.setAutoDraw(false);

        layoutOptions = new ArrayList<Button>();
        addLayoutOptionButtons();
    }

    public void update() {
        if (isVisible) { //only update if visible
            // //close dropdown when mouse leaves
            // if ((mouseX < x || mouseX > x + w || mouseY < y || mouseY > y + h) && !topNav.layoutButton.isMouseHere()){
            //   toggleVisibility();
            // }
        }

        //Update the X position of this box on every update
        x = width - w - 3;
    }

    public void draw() {
        if (isVisible) { //only draw if visible
            pushStyle();

            stroke(OPENBCI_DARKBLUE);
            // fill(229); //bg
            fill(57, 128, 204); //bg
            rect(x, y, w, h);

            fill(57, 128, 204);
            // fill(177, 184, 193);
            noStroke();
            rect(x+w-(topNav.layoutButton.getWidth()-1), y, (topNav.layoutButton.getWidth()-1), 1);

            popStyle();

            layout_cp5.draw();
        }
    }

    public void isMouseHere() {
    }

    public void mousePressed() {
    }

    public void mouseReleased() {
        //only allow button interactivity if isVisible==true
        if (isVisible) {
            if ((mouseX < x || mouseX > x + w || mouseY < y || mouseY > y + h) && !topNav.layoutButton.isInside()) {
                toggleVisibility();
            }

        }
    }

    public void screenResized() {
        //update position of outer box and buttons
        //int oldX = x;
        x = width - w - 3;
        //int dx = oldX - x;
        layout_cp5.setGraphics(ourApplet, 0,0);

        for (int i = 0; i < layoutOptions.size(); i++) {
            int row = (i/4)%4;
            int column = i%4;
            layoutOptions.get(i).setPosition(x + (column+1)*margin + (b_w*column), y + (row+1)*margin + row*b_h);
        }
    }

    public void toggleVisibility() {
        isVisible = !isVisible;
        if (isVisible) {
            //the very convoluted way of locking all controllers of a single controlP5 instance...
            for (int i = 0; i < wm.widgets.size(); i++) {
                for (int j = 0; j < wm.widgets.get(i).cp5_widget.getAll().size(); j++) {
                    wm.widgets.get(i).cp5_widget.getController(wm.widgets.get(i).cp5_widget.getAll().get(j).getAddress()).lock();
                }
            }
        } else {
            //the very convoluted way of unlocking all controllers of a single controlP5 instance...
            for (int i = 0; i < wm.widgets.size(); i++) {
                for (int j = 0; j < wm.widgets.get(i).cp5_widget.getAll().size(); j++) {
                    wm.widgets.get(i).cp5_widget.getController(wm.widgets.get(i).cp5_widget.getAll().get(j).getAddress()).unlock();
                }
            }
        }
    }

    private void addLayoutOptionButtons() {
        final int numLayouts = 12;
        for (int i = 0; i < numLayouts; i++) {
            int row = (i/4)%4;
            int column = i%4;
            final int layoutNumber = i;
            Button tempLayoutButton = createButton(layout_cp5, "layoutButton"+i, "", x + (column+1)*margin + (b_w*column), y + (row+1)*margin + (row*b_h), b_w, b_h);
            PImage tempBackgroundImage = loadImage("layout_buttons/layout_"+(i+1)+".png");
            tempBackgroundImage.resize(b_w, b_h);
            tempLayoutButton.setImage(tempBackgroundImage);
            tempLayoutButton.setForceDrawBackground(true);
            tempLayoutButton.onRelease(new CallbackListener() {
                public void controlEvent(CallbackEvent theEvent) {
                    output("Layout [" + (layoutNumber) + "] selected.");
                    toggleVisibility(); //shut layoutSelector if something is selected
                    wm.setNewContainerLayout(layoutNumber); //have WidgetManager update Layout and active widgets
                    settings.currentLayout = layoutNumber; //copy this value to be used when saving Layout setting
                }
            });
            layoutOptions.add(tempLayoutButton);
        }
    }
}

class ConfigSelector {
    private int x, y, w, h, margin, b_w, b_h;
    private boolean clearAllSettingsPressed;
    public boolean isVisible;
    private ControlP5 settings_cp5;
    private Button expertMode;
    private Button saveSessionSettings;
    private Button loadSessionSettings;
    private Button defaultSessionSettings;
    private Button clearAllGUISettings;
    private Button clearAllSettingsNo;
    private Button clearAllSettingsYes;

    private int configHeight = 0;

    private int osPadding = 0;
    private int osPadding2 = 0;
    private int buttonSpacer = 0;

    ConfigSelector() {
        int _padding = (systemMode == SYSTEMMODE_POSTINIT) ? -3 : 3;
        w = 140;
        x = width - w - _padding;
        y = (navBarHeight * 2) - 3;
        margin = 6;
        b_w = w - margin*2;
        b_h = 22;
        h = margin*9 + b_h*8;
        //makes the setting text "are you sure" display correctly on linux
        osPadding = isLinux() ? -3 : -2;
        osPadding2 = isLinux() ? 5 : 0;

        //Instantiate local cp5 for this box
        settings_cp5 = new ControlP5(ourApplet);
        settings_cp5.setGraphics(ourApplet, 0,0);
        settings_cp5.setAutoDraw(false);

        isVisible = false;

        int buttonNumber = 0;
        createExpertModeButton("expertMode", "Turn Expert Mode On", x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h);
        buttonNumber++;
        createSaveSettingsButton("saveSessionSettings", "Save", x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h);
        buttonNumber++;
        createLoadSettingsButton("loadSessionSettings", "Load", x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h);
        buttonNumber++;
        createDefaultSettingsButton("defaultSessionSettings", "Default", x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h);
        buttonNumber++;
        createClearAllSettingsButton("clearAllGUISettings", "Clear All", x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h);
        buttonNumber += 2;
        createClearSettingsNoButton("clearAllSettingsNo", "No", x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h);
        buttonNumber++;
        createClearSettingsYesButton("clearAllSettingsYes", "Yes", x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h);
    }

    public void update() {
    }

    public void draw() {
        if (isVisible) { //only draw if visible
            pushStyle();

            stroke(OPENBCI_DARKBLUE);
            fill(57, 128, 204); //bg
            rect(x, y, w, h);

            boolean isSessionStarted = (systemMode == SYSTEMMODE_POSTINIT);
            saveSessionSettings.setVisible(isSessionStarted);
            loadSessionSettings.setVisible(isSessionStarted);
            defaultSessionSettings.setVisible(isSessionStarted);

            if (clearAllSettingsPressed) {
                textFont(p2, 16);
                fill(255);
                textAlign(CENTER);
                text("Are You Sure?", x + w/2, clearAllGUISettings.getPosition()[1] + b_h*2);
            }
            clearAllSettingsYes.setVisible(clearAllSettingsPressed);
            clearAllSettingsNo.setVisible(clearAllSettingsPressed);

            fill(57, 128, 204);
            noStroke();
            //This makes the dropdown box look like it's apart of the button by drawing over the part that overlaps
            rect(x+w-(topNav.settingsButton.getWidth()-1), y, (topNav.settingsButton.getWidth()-1), 1);

            popStyle();

            settings_cp5.draw();
        }
    }

    public void isMouseHere() {
    }

    public void mousePressed() {
    }

    public void mouseReleased() {
        //only allow button interactivity if isVisible==true
        if (isVisible) {
            if ((mouseX < x || mouseX > x + w || mouseY < y || mouseY > y + h) && !topNav.settingsButton.isInside()) {
                toggleVisibility();
                clearAllSettingsPressed = false;
            }
        }
    }

    public void screenResized() {
        settings_cp5.setGraphics(ourApplet, 0,0);
        updateConfigButtonPositions();
    }

    private void updateConfigButtonPositions() {
        //update position of outer box and buttons
        final boolean isSessionStarted = (systemMode == SYSTEMMODE_POSTINIT);
        int oldX = x;
        int multiplier = isSessionStarted ? 3 : 2;
        int _padding = isSessionStarted ? -3 : 3;
        x = width - 70*multiplier - _padding;
        int dx = oldX - x;

        h = !isSessionStarted ? margin*3 + b_h*2 : margin*6 + b_h*5;

        //Update the Y position for the clear settings buttons
        float clearSettingsButtonY = !isSessionStarted ? 
            expertMode.getPosition()[1] + margin + b_h : 
            defaultSessionSettings.getPosition()[1] + margin + b_h;
        clearAllGUISettings.setPosition(clearAllGUISettings.getPosition()[0], clearSettingsButtonY);
        clearAllSettingsNo.setPosition(clearAllSettingsNo.getPosition()[0], clearSettingsButtonY + margin*2 + b_h*2);
        clearAllSettingsYes.setPosition(clearAllSettingsYes.getPosition()[0], clearSettingsButtonY + margin*3 + b_h*3);
        
        //Update the X position for all buttons
        for (int j = 0; j < settings_cp5.getAll().size(); j++) {
            Button c = (Button) settings_cp5.getController(settings_cp5.getAll().get(j).getAddress());
            c.setPosition(c.getPosition()[0] - dx, c.getPosition()[1]);
        }

        //println("TopNav: ConfigSelector: Button Positions Updated");
    }

    public void toggleVisibility() {
        isVisible = !isVisible;
        if (systemMode >= SYSTEMMODE_POSTINIT) {
            if (isVisible) {
                //the very convoluted way of locking all controllers of a single controlP5 instance...
                for (int i = 0; i < wm.widgets.size(); i++) {
                    for (int j = 0; j < wm.widgets.get(i).cp5_widget.getAll().size(); j++) {
                        wm.widgets.get(i).cp5_widget.getController(wm.widgets.get(i).cp5_widget.getAll().get(j).getAddress()).lock();
                    }
                }
                clearAllSettingsPressed = false;
            } else {
                //the very convoluted way of unlocking all controllers of a single controlP5 instance...
                for (int i = 0; i < wm.widgets.size(); i++) {
                    for (int j = 0; j < wm.widgets.get(i).cp5_widget.getAll().size(); j++) {
                        wm.widgets.get(i).cp5_widget.getController(wm.widgets.get(i).cp5_widget.getAll().get(j).getAddress()).unlock();
                    }
                }
            }
        }

        //When closed by any means and confirmation buttons are open...
        //Hide confirmation buttons and shorten height of this box
        if (clearAllSettingsPressed && !isVisible) {
            //Shorten height of this box
            h -= margin*4 + b_h*3;
            clearAllSettingsPressed = false;
        }

        updateConfigButtonPositions();
    }

    private void createExpertModeButton(String name, String text, int _x, int _y, int _w, int _h) {
        expertMode = createButton(settings_cp5, name, text, _x, _y, _w, _h, p5, 12, BUTTON_NOOBGREEN, WHITE);
        expertMode.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                toggleVisibility();
                boolean isActive = !guiSettings.getExpertModeBoolean();
                toggleExpertModeFrontEnd(isActive);
                String outputMsg = isActive ?
                    "Expert Mode ON: All keyboard shortcuts and features are enabled!" : 
                    "Expert Mode OFF: Use spacebar to start/stop the data stream.";
                output(outputMsg);
                guiSettings.setExpertMode(isActive ? ExpertModeEnum.ON : ExpertModeEnum.OFF);
            }
        });
        expertMode.setDescription("Expert Mode enables advanced keyboard shortcuts and access to all GUI features.");
    }

    private void createSaveSettingsButton(String name, String text, int _x, int _y, int _w, int _h) {
        saveSessionSettings = createButton(settings_cp5, name, text, _x, _y, _w, _h);
        saveSessionSettings.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                toggleVisibility();
                settings.saveButtonPressed();
            }
        });
        saveSessionSettings.setDescription("Expert Mode enables advanced keyboard shortcuts and access to all GUI features.");
    }

    private void createLoadSettingsButton(String name, String text, int _x, int _y, int _w, int _h) {
        loadSessionSettings = createButton(settings_cp5, name, text, _x, _y, _w, _h);
        loadSessionSettings.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                toggleVisibility();
                settings.loadButtonPressed();
            }
        });
        loadSessionSettings.setDescription("Expert Mode enables advanced keyboard shortcuts and access to all GUI features.");
    }

    private void createDefaultSettingsButton(String name, String text, int _x, int _y, int _w, int _h) {
        defaultSessionSettings = createButton(settings_cp5, name, text, _x, _y, _w, _h);
        defaultSessionSettings.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                toggleVisibility();
                settings.defaultButtonPressed();
            }
        });
        defaultSessionSettings.setDescription("Expert Mode enables advanced keyboard shortcuts and access to all GUI features.");
    }

    private void createClearAllSettingsButton(String name, String text, int _x, int _y, int _w, int _h) {
        clearAllGUISettings = createButton(settings_cp5, name, text, _x, _y, _w, _h, p5, 12, BUTTON_CAUTIONRED, WHITE);
        clearAllGUISettings.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                //Leave box open if this button was pressed and toggle flag
                clearAllSettingsPressed = !clearAllSettingsPressed;
                //Expand or shorten height of this box
                final int delta_h = margin*4 + b_h*3;
                h += clearAllSettingsPressed ? delta_h : -delta_h;
            }
        });
        clearAllGUISettings.setDescription("This will clear all user settings and playback history. You will be asked to confirm.");
    }

    private void createClearSettingsNoButton(String name, String text, int _x, int _y, int _w, int _h) {
        clearAllSettingsNo = createButton(settings_cp5, name, text, _x, _y, _w, _h);
        clearAllSettingsNo.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                toggleVisibility();
                //Do nothing because the user clicked Are You Sure?->No
                clearAllSettingsPressed = false;
                //Shorten height of this box
                h -= margin*4 + b_h*3;
            }
        });
    }

    private void createClearSettingsYesButton(String name, String text, int _x, int _y, int _w, int _h) {
        clearAllSettingsYes = createButton(settings_cp5, name, text, _x, _y, _w, _h);
        clearAllSettingsYes.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                toggleVisibility();
                //Shorten height of this box
                h -= margin*4 + b_h*3;
                //User has selected Are You Sure?->Yes
                settings.clearAll();
                clearAllSettingsPressed = false;
                //Stop the system if the user clears all settings
                if (systemMode == SYSTEMMODE_POSTINIT) {
                    haltSystem();
                }
            }
        });
        clearAllSettingsYes.setDescription("Clicking 'Yes' will delete all user settings and stop the session if running.");
    }

    public void toggleExpertModeFrontEnd(boolean b) {
        if (b) {
            expertMode.getCaptionLabel().setText("Turn Expert Mode Off");
            expertMode.setColorBackground(BUTTON_EXPERTPURPLE);
        } else {
            expertMode.getCaptionLabel().setText("Turn Expert Mode On");
            expertMode.setColorBackground(BUTTON_NOOBGREEN);
        }
    } 
}

class TutorialSelector {

    private int x, y, w, h, margin, b_w, b_h;
    public boolean isVisible;
    private ControlP5 tutorial_cp5;
    private Button gettingStarted;
    private Button testingImpedance;
    private Button troubleshootingGuide;
    private Button customWidgets;
    private Button openbciForum;
    private Button ftdiBufferFix;
    private final int NUM_TUTORIAL_BUTTONS = 6;

    TutorialSelector() {
        w = 180;
        //account for consoleLog button, help button, and spacing
        x = width - 33 - w - 3*2;
        y = (navBarHeight) - 3;
        margin = 6;
        b_w = w - margin*2;
        b_h = 22;
        h = margin*(NUM_TUTORIAL_BUTTONS+1) + b_h*NUM_TUTORIAL_BUTTONS;

        //Instantiate local cp5 for this box
        tutorial_cp5 = new ControlP5(ourApplet);
        tutorial_cp5.setGraphics(ourApplet, 0,0);
        tutorial_cp5.setAutoDraw(false);

        isVisible = false;

        int buttonNumber = 0;
        createGettingStartedButton("gettingStarted", "Getting Started", x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h);
        buttonNumber++;
        createTestingImpedanceButton("testingImpedance", "Testing Impedance", x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h);
        buttonNumber++;
        createFtdiBufferFixButton("ftdiBufferFix", "Cyton Driver Fix", x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h);
        buttonNumber++;
        createTroubleshootingGuideButton("troubleshootingGuide", "Troubleshooting Guide", x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h);
        buttonNumber++;
        createCustomWidgetsButton("customWidgets", "Building Custom Widgets", x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h);
        buttonNumber++;
        createOpenbciForumButton("openbciForum", "OpenBCI Forum", x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h);
    }

    public void update() {
        if (isVisible) { //only update if visible
            // //close dropdown when mouse leaves
            // if ((mouseX < x || mouseX > x + w || mouseY < y || mouseY > y + h) && !topNav.tutorialsButton.isMouseHere()){
            //   toggleVisibility();
            // }
        }
    }

    public void draw() {
        if (isVisible) { //only draw if visible
            pushStyle();

            stroke(OPENBCI_DARKBLUE);
            // fill(229); //bg
            fill(OPENBCI_BLUE); //bg
            rect(x, y, w, h);


            // fill(177, 184, 193);
            noStroke();
            //Draw a tiny rectangle to make it look like the box and button are connected
            rect(x+w-(topNav.tutorialsButton.getWidth()-1), y, (topNav.tutorialsButton.getWidth()-1), 1);

            popStyle();

            tutorial_cp5.draw();
        }
    }

    public void isMouseHere() {
    }

    public void mousePressed() {
    }

    public void mouseReleased() {
        //only allow button interactivity if isVisible==true
        if (isVisible) {
            if ((mouseX < x || mouseX > x + w || mouseY < y || mouseY > y + h) && !topNav.tutorialsButton.isInside()) {
                toggleVisibility();
                //topNav.configButton.setIgnoreHover(false);
            }
        }
    }

    public void screenResized() {

        tutorial_cp5.setGraphics(ourApplet, 0,0);

        //update position of outer box and buttons. Y values do not change for this box.
        int oldX = x;
        x = width - 33 - w - 3*2;
        int dx = oldX - x;

        for (int j = 0; j < tutorial_cp5.getAll().size(); j++) {
            Button c = (Button) tutorial_cp5.getController(tutorial_cp5.getAll().get(j).getAddress());
            c.setPosition(c.getPosition()[0] - dx, c.getPosition()[1]);
        }
        
    }

    public void toggleVisibility() {
        isVisible = !isVisible;
        if (systemMode >= SYSTEMMODE_POSTINIT) {
            if (isVisible) {
                //the very convoluted way of locking all controllers of a single controlP5 instance...
                for (int i = 0; i < wm.widgets.size(); i++) {
                    for (int j = 0; j < wm.widgets.get(i).cp5_widget.getAll().size(); j++) {
                        wm.widgets.get(i).cp5_widget.getController(wm.widgets.get(i).cp5_widget.getAll().get(j).getAddress()).lock();
                    }
                }
            } else {
                //the very convoluted way of unlocking all controllers of a single controlP5 instance...
                for (int i = 0; i < wm.widgets.size(); i++) {
                    for (int j = 0; j < wm.widgets.get(i).cp5_widget.getAll().size(); j++) {
                        wm.widgets.get(i).cp5_widget.getController(wm.widgets.get(i).cp5_widget.getAll().get(j).getAddress()).unlock();
                    }
                }
            }
        }
    }

    private void createGettingStartedButton(String name, String text, int _x, int _y, int _w, int _h) {
        gettingStarted = createButton(tutorial_cp5, name, text, _x, _y, _w, _h);
        gettingStarted.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                openURLInBrowser("https://docs.openbci.com/GettingStarted/GettingStartedLanding/");
                toggleVisibility(); //shut layoutSelector if something is selected
            }
        });
        gettingStarted.setDescription("Need help getting started? Click here to view the official OpenBCI Getting Started guides.");
    }

    private void createTestingImpedanceButton(String name, String text, int _x, int _y, int _w, int _h) {
        testingImpedance = createButton(tutorial_cp5, name, text, _x, _y, _w, _h);
        testingImpedance.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                openURLInBrowser("https://docs.openbci.com/Software/OpenBCISoftware/GUIDocs/#impedance-testing");
                toggleVisibility(); //shut layoutSelector if something is selected
            }
        });
        testingImpedance.setDescription("Click here to learn more about testing the impedance on electrodes using the OpenBCI GUI. This process is different for Cyton and Ganglion. Checking impedance only works with passive electrodes.");
    }

    private void createTroubleshootingGuideButton(String name, String text, int _x, int _y, int _w, int _h) {
        troubleshootingGuide = createButton(tutorial_cp5, name, text, _x, _y, _w, _h);
        troubleshootingGuide.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                openURLInBrowser("https://docs.openbci.com/Troubleshooting/GUI_Troubleshooting/");
                toggleVisibility(); //shut layoutSelector if something is selected
            }
        });
        troubleshootingGuide.setDescription("Having trouble? Start here with some general troubleshooting tips found on the OpenBCI Docs.");
    }

    private void createCustomWidgetsButton(String name, String text, int _x, int _y, int _w, int _h) {
        customWidgets = createButton(tutorial_cp5, name, text, _x, _y, _w, _h);
        customWidgets.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                openURLInBrowser("https://docs.openbci.com/Software/OpenBCISoftware/GUIWidgets/#custom-widget");
                toggleVisibility(); //shut layoutSelector if something is selected
            }
        });
        customWidgets.setDescription("Click here to learn about creating your own custom OpenBCI widgets!");
    }

    private void createOpenbciForumButton(String name, String text, int _x, int _y, int _w, int _h) {
        openbciForum = createButton(tutorial_cp5, name, text, _x, _y, _w, _h);
        openbciForum.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                openURLInBrowser("https://openbci.com/forum/");
                toggleVisibility(); //shut layoutSelector if something is selected
            }
        });
        openbciForum.setDescription("Click here to visit the official OpenBCI Forum.");
    }

    private void createFtdiBufferFixButton(String name, String text, int _x, int _y, int _w, int _h) {
        openbciForum = createButton(tutorial_cp5, name, text, _x, _y, _w, _h);
        openbciForum.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                String ftdiDriverDocUrl;
                if (isMac()) {
                    ftdiDriverDocUrl = "https://docs.openbci.com/Troubleshooting/FTDI_Fix_Mac/";
                } else if (isLinux()){
                    ftdiDriverDocUrl = "https://docs.openbci.com/Troubleshooting/FTDI_Fix_Linux/";
                } else {
                    ftdiDriverDocUrl = "https://docs.openbci.com/Troubleshooting/FTDI_Fix_Windows/";
                }
                openURLInBrowser(ftdiDriverDocUrl);
                toggleVisibility(); //shut layoutSelector if something is selected
            }
        });
        openbciForum.setDescription("Click here to view information on how to lower the Cyton Dongle latency for your current operating system.");
    }
}

////////////////////////////////////////////////////
//
// W_Accelerometer is used to visualize accelerometer data
//
// Created: Joel Murphy
// Modified: Colin Fausnaught, September 2016
// Modified: Wangshu Sun, November 2016
// Modified: Richard Waltman, November 2018
//
//
////////////////////////////////////////////////////

class W_Accelerometer extends Widget {
    //To see all core variables/methods of the Widget class, refer to Widget.pde
    int graphStroke = color(210);
    int graphBG = color(245);
    int textColor = OPENBCI_DARKBLUE;
    int strokeColor = color(138, 146, 153);
    int eggshell = color(255, 253, 248);

    //Graphing variables
    int[] xLimOptions = {0, 1, 3, 5, 10, 20}; //number of seconds (x axis of graph)
    int[] yLimOptions = {0, 1, 2, 4};
    float accelXyzLimit = 4.0f; //hard limit on all accel values
    int accelHorizLimit = 20;
    float[] lastAccelVals;
    AccelerometerBar accelerometerBar;

    //Bottom xyz graph
    int accelGraphWidth;
    int accelGraphHeight;
    int accelGraphX;
    int accelGraphY;
    int accPadding = 30;

    //Circular 3d xyz graph
    float polarWindowX;
    float polarWindowY;
    int polarWindowWidth;
    int polarWindowHeight;
    float polarCorner;

    float yMaxMin;

    boolean accelInitHasOccured = false;
    private Button accelModeButton;

    private AccelerometerCapableBoard accelBoard;

    W_Accelerometer(PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)
        
        accelBoard = (AccelerometerCapableBoard)currentBoard;

        //Default dropdown settings
        settings.accVertScaleSave = 0;
        settings.accHorizScaleSave = 3;

        //Make dropdowns
        addDropdown("accelVertScale", "Vert Scale", Arrays.asList(settings.accVertScaleArray), settings.accVertScaleSave);
        addDropdown("accelDuration", "Window", Arrays.asList(settings.accHorizScaleArray), settings.accHorizScaleSave);

        setGraphDimensions();
        yMaxMin = adjustYMaxMinBasedOnSource();

        //XYZ buffer for bottom graph
        lastAccelVals = new float[NUM_ACCEL_DIMS];

        //create our channel bar and populate our accelerometerBar array!
        accelerometerBar = new AccelerometerBar(_parent, accelXyzLimit, accelGraphX, accelGraphY, accelGraphWidth, accelGraphHeight);
        accelerometerBar.adjustTimeAxis(xLimOptions[settings.accHorizScaleSave]);
        accelerometerBar.adjustVertScale(yLimOptions[settings.accVertScaleSave]);

        createAccelModeButton("accelModeButton", "Turn Accel. Off", (int)(x + 1), (int)(y0 + navHeight + 1), 120, navHeight - 3, p5, 12, colorNotPressed, OPENBCI_DARKBLUE);
    }

    public float adjustYMaxMinBasedOnSource() {
        float _yMaxMin;
        if (eegDataSource == DATASOURCE_CYTON) {
            _yMaxMin = 4.0f;
        }else if (eegDataSource == DATASOURCE_GANGLION || nchan == 4) {
            _yMaxMin = 2.0f;
            accelXyzLimit = 2.0f;
        }else{
            _yMaxMin = 4.0f;
        }
        return _yMaxMin;
    }

    public int nPointsBasedOnDataSource() {
        return accelHorizLimit * ((AccelerometerCapableBoard)currentBoard).getAccelSampleRate();
    }

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        if (accelBoard.isAccelerometerActive()) {
            //update the line graph and corresponding gplot points
            accelerometerBar.update();

            //update the current Accelerometer values
            lastAccelVals = accelerometerBar.getLastAccelVals();
        }
        
        //ignore top left button interaction when widgetSelector dropdown is active
        List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();
        cp5ElementsToCheck.add((controlP5.Controller)accelModeButton);
        lockElementsOnOverlapCheck(cp5ElementsToCheck);
        
        if(!accelBoard.canDeactivateAccelerometer() && !(currentBoard instanceof BoardCyton)) {
            accelModeButton.getCaptionLabel().setText("Accel. On");
            accelModeButton.setColorBackground(BUTTON_LOCKED_GREY);
            accelModeButton.setLock(true);
        }
    }

    public float getLastAccelVal(int val) {
        return lastAccelVals[val];
    }

    public void draw() {
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        pushStyle();

        fill(50);
        textFont(p4, 14);
        textAlign(CENTER,CENTER);
        text("z", polarWindowX, (polarWindowY-polarWindowHeight/2)-12);
        text("x", (polarWindowX+polarWindowWidth/2)+8, polarWindowY-5);
        text("y", (polarWindowX+polarCorner)+10, (polarWindowY-polarCorner)-10);

        fill(graphBG);  //pulse window background
        stroke(graphStroke);
        ellipse(polarWindowX,polarWindowY,polarWindowWidth,polarWindowHeight);

        stroke(180);
        line(polarWindowX-polarWindowWidth/2, polarWindowY, polarWindowX+polarWindowWidth/2, polarWindowY);
        line(polarWindowX, polarWindowY-polarWindowHeight/2, polarWindowX, polarWindowY+polarWindowHeight/2);
        line(polarWindowX-polarCorner, polarWindowY+polarCorner, polarWindowX+polarCorner, polarWindowY-polarCorner);
        
        if (accelBoard.isAccelerometerActive()) {
            drawAccValues();
            draw3DGraph();
        }

        popStyle();

        if (accelBoard.isAccelerometerActive()) {
            accelerometerBar.draw();
        }
    }

    public void setGraphDimensions() {
        accelGraphWidth = w - accPadding*2;
        accelGraphHeight = PApplet.parseInt((PApplet.parseFloat(h) - PApplet.parseFloat(accPadding*3))/2.0f);
        accelGraphX = x + accPadding/3;
        accelGraphY = y + h - accelGraphHeight - PApplet.parseInt(accPadding*2) + accPadding/6;

        polarWindowWidth = accelGraphHeight;
        polarWindowHeight = accelGraphHeight;
        polarWindowX = x + w - accPadding - polarWindowWidth/2;
        polarWindowY = y + accPadding + polarWindowHeight/2 - 10;
        polarCorner = (sqrt(2)*polarWindowWidth/2)/2;
    }

    public void screenResized() {
        int prevX = x;
        int prevY = y;
        int prevW = w;
        int prevH = h;
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)
        setGraphDimensions();
        //resize the accelerometer line graph
        accelerometerBar.screenResized(accelGraphX, accelGraphY, accelGraphWidth-accPadding*2, accelGraphHeight); //bar x, bar y, bar w, bar h
        //update the position of the accel mode button
        accelModeButton.setPosition((int)(x0 + 1), (int)(y0 + navHeight + 1));
    }
    
    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
    }

    public void mouseReleased() {
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
    }

    private void createAccelModeButton(String name, String text, int _x, int _y, int _w, int _h, PFont _font, int _fontSize, int _bg, int _textColor) {
        accelModeButton = createButton(cp5_widget, name, text, _x, _y, _w, _h, 0, _font, _fontSize, _bg, _textColor, BUTTON_HOVER, BUTTON_PRESSED, OBJECT_BORDER_GREY, 0);
        accelModeButton.setSwitch(true);
        accelModeButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (!accelBoard.isAccelerometerActive()) {
                    accelBoard.setAccelerometerActive(true);
                    output("Starting to read accelerometer");
                    accelModeButton.getCaptionLabel().setText("Turn Accel. Off");
                    if (currentBoard instanceof DigitalCapableBoard) {
                        w_digitalRead.toggleDigitalReadButton(false);
                    }
                    if (currentBoard instanceof AnalogCapableBoard) {
                        w_pulsesensor.toggleAnalogReadButton(false);
                        w_analogRead.toggleAnalogReadButton(false);
                    }
                    ///Hide button when set On for Cyton board only. This is a special case for Cyton board Aux mode behavior. See BoardCyton.pde for more info.
                    if ((currentBoard instanceof BoardCyton)) {
                        accelModeButton.setVisible(false);
                    }
                } else {
                    if (accelBoard.canDeactivateAccelerometer()) {
                        accelBoard.setAccelerometerActive(false);
                        accelModeButton.getCaptionLabel().setText("Turn Accel. On");
                    } else {
                        accelModeButton.setOn();
                    }
                }
            }
        });
        accelModeButton.setDescription("Click to activate/deactivate the accelerometer for capable boards.");
        if (accelBoard.canDeactivateAccelerometer() || (currentBoard instanceof BoardCyton)) {
            //Set button switch to On of it can be toggled
            accelModeButton.setOn();
            //Hide button when set On for Cyton board only. This is a special case for Cyton board Aux mode behavior. See BoardCyton.pde for more info.
            if ((currentBoard instanceof BoardCyton)) {
                accelModeButton.setVisible(false);
            }
        }
    }

    //Draw the current accelerometer values as text
    public void drawAccValues() {
        float displayX = (float)lastAccelVals[0];
        float displayY = (float)lastAccelVals[1];
        float displayZ = (float)lastAccelVals[2];
        textAlign(LEFT,CENTER);
        textFont(h1,20);
        fill(ACCEL_X_COLOR);
        text("X = " + nf(displayX, 1, 3) + " g", x+accPadding , y + (h/12)*1.5f - 5);
        fill(ACCEL_Y_COLOR);
        text("Y = " + nf(displayY, 1, 3) + " g", x+accPadding, y + (h/12)*3 - 5);
        fill(ACCEL_Z_COLOR);
        text("Z = " + nf(displayZ, 1, 3) + " g", x+accPadding, y + (h/12)*4.5f - 5);
    }

    //Draw the current accelerometer values as a 3D graph
    public void draw3DGraph() {
        float displayX = (float)lastAccelVals[0];
        float displayY = (float)lastAccelVals[1];
        float displayZ = (float)lastAccelVals[2];

        noFill();
        strokeWeight(3);
        stroke(ACCEL_X_COLOR);
        line(polarWindowX, polarWindowY, polarWindowX+map(displayX, -yMaxMin, yMaxMin, -polarWindowWidth/2, polarWindowWidth/2), polarWindowY);
        stroke(ACCEL_Y_COLOR);
        line(polarWindowX, polarWindowY, polarWindowX+map((sqrt(2)*displayY/2), -yMaxMin, yMaxMin, -polarWindowWidth/2, polarWindowWidth/2), polarWindowY+map((sqrt(2)*displayY/2), -yMaxMin, yMaxMin, polarWindowWidth/2, -polarWindowWidth/2));
        stroke(ACCEL_Z_COLOR);
        line(polarWindowX, polarWindowY, polarWindowX, polarWindowY+map(displayZ, -yMaxMin, yMaxMin, polarWindowWidth/2, -polarWindowWidth/2));
        strokeWeight(1);
    }

    //This public method allows Analog, Digital, and Pulse Widgets to turn off Accelerometer display
    //Happens only when buttons can be toggled
    public void accelBoardSetActive(boolean _value) {
        accelBoard.setAccelerometerActive(_value);
        String s = _value ? "Turn Accel. Off" : "Turn Accel. On";
        accelModeButton.getCaptionLabel().setText(s);
        if (_value) {
            accelModeButton.setOn();
        } else {
            accelModeButton.setOff();
        }
        //Hide button when set On for Cyton board only. This is a special case for Cyton board Aux mode behavior. See BoardCyton.pde for more info.
        if ((currentBoard instanceof BoardCyton)) {
            accelModeButton.setVisible(!_value);
        }
    }

};//end W_Accelerometer class

//These functions are activated when an item from the corresponding dropdown is selected
public void accelVertScale(int n) {
    settings.accVertScaleSave = n;
    w_accelerometer.accelerometerBar.adjustVertScale(w_accelerometer.yLimOptions[n]);
}

//triggered when there is an event in the Duration Dropdown
public void accelDuration(int n) {
    settings.accHorizScaleSave = n;

    //Sync the duration of Time Series, Accelerometer, and Analog Read(Cyton Only)
    if (n == 0) {
        w_accelerometer.accelerometerBar.adjustTimeAxis(w_timeSeries.getTSHorizScale().getValue());
    } else {
        //set accelerometer x axis to the duration selected from dropdown
        w_accelerometer.accelerometerBar.adjustTimeAxis(w_accelerometer.xLimOptions[n]);
    }
}

//========================================================================================================================
//                     Accelerometer Graph Class -- Implemented by Accelerometer Widget Class
//========================================================================================================================
class AccelerometerBar {
    //this class contains the plot for the 2d graph of accelerometer data
    int x, y, w, h;
    int accBarPadding = 30;
    int xOffset;

    GPlot plot; //the actual grafica-based GPlot that will be rendering the Time Series trace
    GPointsArray accelPointsX;
    GPointsArray accelPointsY;
    GPointsArray accelPointsZ;

    int nPoints;
    int numSeconds = 20; //default to 20 seconds
    float timeBetweenPoints;
    float[] accelTimeArray;
    int numSamplesToProcess;
    float minX, minY, minZ;
    float maxX, maxY, maxZ;
    float minVal;
    float maxVal;
    final float autoScaleSpacing = 0.1f;

    int channelColor; //color of plot trace

    boolean isAutoscale; //when isAutoscale equals true, the y-axis will automatically update to scale to the largest visible amplitude
    int lastProcessedDataPacketInd = 0;
    
    private AccelerometerCapableBoard accelBoard;

    AccelerometerBar(PApplet _parent, float accelXyzLimit, int _x, int _y, int _w, int _h) { //channel number, x/y location, height, width
        
        // This widget is only instantiated when the board is accel capable, so we don't need to check
        accelBoard = (AccelerometerCapableBoard)currentBoard;

        x = _x;
        y = _y;
        w = _w;
        h = _h;
        if (eegDataSource == DATASOURCE_CYTON) {
            xOffset = 22;
        } else {
            xOffset = 0;
        }

        plot = new GPlot(_parent);
        plot.setPos(x + 36 + 4 + xOffset, y); //match Accelerometer plot position with Time Series
        plot.setDim(w - 36 - 4 - xOffset, h);
        plot.setMar(0f, 0f, 0f, 0f);
        plot.setLineColor((int)channelColors[(NUM_ACCEL_DIMS)%8]);
        plot.setXLim(-numSeconds,0); //set the horizontal scale
        plot.setYLim(-accelXyzLimit, accelXyzLimit); //change this to adjust vertical scale
        //plot.setPointSize(2);
        plot.setPointColor(0);
        plot.getXAxis().setAxisLabelText("Time (s)");
        plot.getYAxis().setAxisLabelText("Acceleration (g)");
        plot.getYAxis().setNTicks(3);
        plot.setAllFontProperties("Arial", 0, 14);
        plot.getXAxis().getAxisLabel().setOffset(PApplet.parseFloat(accBarPadding));
        plot.getYAxis().getAxisLabel().setOffset(PApplet.parseFloat(accBarPadding));
        plot.getXAxis().setFontColor(OPENBCI_DARKBLUE);
        plot.getXAxis().setLineColor(OPENBCI_DARKBLUE);
        plot.getXAxis().getAxisLabel().setFontColor(OPENBCI_DARKBLUE);
        plot.getYAxis().setFontColor(OPENBCI_DARKBLUE);
        plot.getYAxis().setLineColor(OPENBCI_DARKBLUE);
        plot.getYAxis().getAxisLabel().setFontColor(OPENBCI_DARKBLUE);

        initArrays();

        //set the plot points for X, Y, and Z axes
        plot.addLayer("layer 1", accelPointsX);
        plot.getLayer("layer 1").setLineColor(ACCEL_X_COLOR);
        plot.addLayer("layer 2", accelPointsY);
        plot.getLayer("layer 2").setLineColor(ACCEL_Y_COLOR);
        plot.addLayer("layer 3", accelPointsZ);
        plot.getLayer("layer 3").setLineColor(ACCEL_Z_COLOR);
    }

    public void initArrays() {
        nPoints = nPointsBasedOnDataSource();
        timeBetweenPoints = (float)numSeconds / (float)nPoints;

        accelTimeArray = new float[nPoints];
        for (int i = 0; i < accelTimeArray.length; i++) {
            accelTimeArray[i] = -(float)numSeconds + (float)i * timeBetweenPoints;
        }

        float[] accelArrayX = new float[nPoints];
        float[] accelArrayY = new float[nPoints];
        float[] accelArrayZ = new float[nPoints];

        //make a GPoint array using float arrays x[] and y[] instead of plain index points
        accelPointsX = new GPointsArray(accelTimeArray, accelArrayX);
        accelPointsY = new GPointsArray(accelTimeArray, accelArrayY);
        accelPointsZ = new GPointsArray(accelTimeArray, accelArrayZ);
    }

    //Used to update the accelerometerBar class
    public void update() {
        updateGPlotPoints();

        if (isAutoscale) {
            autoScale();
        }
    }

    public void draw() {
        pushStyle();
        plot.beginDraw();
        plot.drawBox(); //we won't draw this eventually ...
        plot.drawGridLines(GPlot.BOTH);
        plot.drawLines(); //Draw a Line graph!
        //plot.drawPoints(); //Used to draw Points instead of Lines
        plot.drawYAxis();
        plot.drawXAxis();
        plot.endDraw();
        popStyle();
    }

    public int nPointsBasedOnDataSource() {
        return numSeconds * currentBoard.getSampleRate();
    }

    public void adjustTimeAxis(int _newTimeSize) {
        numSeconds = _newTimeSize;
        plot.setXLim(-_newTimeSize,0);

        initArrays();

        //Set the number of axis divisions...
        if (_newTimeSize > 1) {
            plot.getXAxis().setNTicks(_newTimeSize);
        }else{
            plot.getXAxis().setNTicks(10);
        }
    }

    //Used to update the Points within the graph
    public void updateGPlotPoints() {
        List<double[]> allData = accelBoard.getDataWithAccel(nPoints);
        int[] accelChannels = accelBoard.getAccelerometerChannels();

        for (int i=0; i < nPoints; i++) {
            accelPointsX.set(i, accelTimeArray[i], (float)allData.get(i)[accelChannels[0]], "");
            accelPointsY.set(i, accelTimeArray[i], (float)allData.get(i)[accelChannels[1]], "");
            accelPointsZ.set(i, accelTimeArray[i], (float)allData.get(i)[accelChannels[2]], "");
        }

        plot.setPoints(accelPointsX, "layer 1");
        plot.setPoints(accelPointsY, "layer 2");
        plot.setPoints(accelPointsZ, "layer 3");
    }

    public float[] getLastAccelVals() {
        float[] result = new float[NUM_ACCEL_DIMS];
        result[0] = accelPointsX.getY(nPoints-1);   
        result[1] = accelPointsY.getY(nPoints-1);   
        result[2] = accelPointsZ.getY(nPoints-1);   

        return result;
    }

    public void adjustVertScale(int _vertScaleValue) {
        if (_vertScaleValue == 0) {
            isAutoscale = true;
        } else {
            isAutoscale = false;
            plot.setYLim(-_vertScaleValue, _vertScaleValue);
        }
    }

    public void autoScale() {
        float[] minMaxVals = minMax(accelPointsX, accelPointsY, accelPointsZ);
        plot.setYLim(minMaxVals[0] - autoScaleSpacing, minMaxVals[1] + autoScaleSpacing);
    }

    public float[] minMax(GPointsArray arrX, GPointsArray arrY, GPointsArray arrZ) {
        float[] minMaxVals = {0.f, 0.f};
        for (int i = 0; i < arrX.getNPoints(); i++) { //go through the XYZ GPpointArrays for on-screen values
            float[] vals = {arrX.getY(i), arrY.getY(i), arrZ.getY(i)};
            minMaxVals[0] = min(minMaxVals[0], min(vals)); //make room to see
            minMaxVals[1] = max(minMaxVals[1], max(vals));
        }
        return minMaxVals;
    }

    public void screenResized(int _x, int _y, int _w, int _h) {
        x = _x;
        y = _y;
        w = _w+100;
        h = _h;
        //reposition & resize the plot
        plot.setPos(x + 36 + 4 + xOffset, y);
        plot.setDim(w - 36 - 4 - xOffset, h);

    }
}; //end of class

////////////////////////////////////////////////////
//
//  W_AnalogRead is used to visiualze analog voltage values
//
//  Created: AJ Keller
//
//
///////////////////////////////////////////////////,

class W_AnalogRead extends Widget {

    //to see all core variables/methods of the Widget class, refer to Widget.pde
    //put your custom variables here...

    private int numAnalogReadBars;
    float xF, yF, wF, hF;
    float arPadding;
    float ar_x, ar_y, ar_h, ar_w; // values for actual time series chart (rectangle encompassing all analogReadBars)
    float plotBottomWell;
    float playbackWidgetHeight;
    int analogReadBarHeight;

    AnalogReadBar[] analogReadBars;

    int[] xLimOptions = {0, 1, 3, 5, 10, 20}; // number of seconds (x axis of graph)
    int[] yLimOptions = {0, 50, 100, 200, 400, 1000, 10000}; // 0 = Autoscale ... everything else is uV

    private boolean allowSpillover = false;

    //Initial dropdown settings
    private int arInitialVertScaleIndex = 5;
    private int arInitialHorizScaleIndex = 0;

    private Button analogModeButton;

    private AnalogCapableBoard analogBoard;

    W_AnalogRead(PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        analogBoard = (AnalogCapableBoard)currentBoard;

        //Analog Read settings
        settings.arVertScaleSave = 5; //updates in VertScale_AR()
        settings.arHorizScaleSave = 0; //updates in Duration_AR()

        //This is the protocol for setting up dropdowns.
        //Note that these 3 dropdowns correspond to the 3 global functions below
        //You just need to make sure the "id" (the 1st String) has the same name as the corresponding function
        addDropdown("VertScale_AR", "Vert Scale", Arrays.asList(settings.arVertScaleArray), arInitialVertScaleIndex);
        addDropdown("Duration_AR", "Window", Arrays.asList(settings.arHorizScaleArray), arInitialHorizScaleIndex);
        // addDropdown("Spillover", "Spillover", Arrays.asList("False", "True"), 0);

        //set number of analog reads
        if (selectedProtocol == BoardProtocol.WIFI) {
            numAnalogReadBars = 2;
        } else {
            numAnalogReadBars = 3;
        }

        xF = PApplet.parseFloat(x); //float(int( ... is a shortcut for rounding the float down... so that it doesn't creep into the 1px margin
        yF = PApplet.parseFloat(y);
        wF = PApplet.parseFloat(w);
        hF = PApplet.parseFloat(h);

        plotBottomWell = 45.0f; //this appears to be an arbitrary vertical space adds GPlot leaves at bottom, I derived it through trial and error
        arPadding = 10.0f;
        ar_x = xF + arPadding;
        ar_y = yF + (arPadding);
        ar_w = wF - arPadding*2;
        ar_h = hF - playbackWidgetHeight - plotBottomWell - (arPadding*2);
        analogReadBarHeight = PApplet.parseInt(ar_h/numAnalogReadBars);

        analogReadBars = new AnalogReadBar[numAnalogReadBars];

        //create our channel bars and populate our analogReadBars array!
        for(int i = 0; i < numAnalogReadBars; i++) {
            int analogReadBarY = PApplet.parseInt(ar_y) + i*(analogReadBarHeight); //iterate through bar locations
            AnalogReadBar tempBar = new AnalogReadBar(_parent, i+5, PApplet.parseInt(ar_x), analogReadBarY, PApplet.parseInt(ar_w), analogReadBarHeight); //int _channelNumber, int _x, int _y, int _w, int _h
            analogReadBars[i] = tempBar;
            analogReadBars[i].adjustVertScale(yLimOptions[arInitialVertScaleIndex]);
            //sync horiz axis to Time Series by default
            analogReadBars[i].adjustTimeAxis(w_timeSeries.getTSHorizScale().getValue());
        }

        createAnalogModeButton("analogModeButton", "Turn Analog Read On", (int)(x0 + 1), (int)(y0 + navHeight + 1), 128, navHeight - 3, p5, 12, colorNotPressed, OPENBCI_DARKBLUE);
    }

    public int getNumAnalogReads() {
        return numAnalogReadBars;
    }

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        if (currentBoard instanceof DataSourcePlayback) {
            if (((DataSourcePlayback)currentBoard) instanceof AnalogCapableBoard
                && (!((AnalogCapableBoard)currentBoard).isAnalogActive())) {
                    return;
            }
        }

        //update channel bars ... this means feeding new EEG data into plots
        for(int i = 0; i < numAnalogReadBars; i++) {
            analogReadBars[i].update();
        }

        //ignore top left button interaction when widgetSelector dropdown is active
        List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();
        cp5ElementsToCheck.add((controlP5.Controller)analogModeButton);
        lockElementsOnOverlapCheck(cp5ElementsToCheck);

        if (!analogBoard.canDeactivateAnalog()) {
            analogModeButton.setLock(true);
            analogModeButton.getCaptionLabel().setText("Analog Read On");
            analogModeButton.setColorBackground(BUTTON_LOCKED_GREY);
        }
    }

    public void draw() {
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        if (analogBoard.isAnalogActive()) {
            for(int i = 0; i < numAnalogReadBars; i++) {
                analogReadBars[i].draw();
            }
        }
    }

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        xF = PApplet.parseFloat(x); //float(int( ... is a shortcut for rounding the float down... so that it doesn't creep into the 1px margin
        yF = PApplet.parseFloat(y);
        wF = PApplet.parseFloat(w);
        hF = PApplet.parseFloat(h);

        ar_x = xF + arPadding;
        ar_y = yF + (arPadding);
        ar_w = wF - arPadding*2;
        ar_h = hF - playbackWidgetHeight - plotBottomWell - (arPadding*2);
        analogReadBarHeight = PApplet.parseInt(ar_h/numAnalogReadBars);

        for(int i = 0; i < numAnalogReadBars; i++) {
            int analogReadBarY = PApplet.parseInt(ar_y) + i*(analogReadBarHeight); //iterate through bar locations
            analogReadBars[i].screenResized(PApplet.parseInt(ar_x), analogReadBarY, PApplet.parseInt(ar_w), analogReadBarHeight); //bar x, bar y, bar w, bar h
        }

        analogModeButton.setPosition((int)(x0 + 1), (int)(y0 + navHeight + 1));
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
    }

    public void mouseReleased() {
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
    }

    private void createAnalogModeButton(String name, String text, int _x, int _y, int _w, int _h, PFont _font, int _fontSize, int _bg, int _textColor) {
        analogModeButton = createButton(cp5_widget, name, text, _x, _y, _w, _h, 0, _font, _fontSize, _bg, _textColor, BUTTON_HOVER, BUTTON_PRESSED, OBJECT_BORDER_GREY, 0);
        analogModeButton.setSwitch(true);
        analogModeButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (!analogBoard.isAnalogActive()) {
                    analogBoard.setAnalogActive(true);  
                    analogModeButton.getCaptionLabel().setText("Turn Analog Read Off");	
                    if (selectedProtocol == BoardProtocol.WIFI) {
                        output("Starting to read analog inputs on pin marked A5 (D11) and A6 (D12)");
                    } else {
                        output("Starting to read analog inputs on pin marked A5 (D11), A6 (D12) and A7 (D13)");
                    }
                    w_pulsesensor.toggleAnalogReadButton(true);
                    w_accelerometer.accelBoardSetActive(false);
                    w_digitalRead.toggleDigitalReadButton(false);
                } else {
                    analogBoard.setAnalogActive(false);
                    analogModeButton.getCaptionLabel().setText("Turn Analog Read On");	
                    output("Starting to read accelerometer");
                    w_accelerometer.accelBoardSetActive(true);
                    w_digitalRead.toggleDigitalReadButton(false);
                    w_pulsesensor.toggleAnalogReadButton(false);
                }
            }
        });
        String _helpText = (selectedProtocol == BoardProtocol.WIFI) ? 
            "Click this button to activate/deactivate analog read on Cyton pins A5(D11) and A6(D12)." :
            "Click this button to activate/deactivate analog read on Cyton pins A5(D11), A6(D12) and A7(D13)."
            ;
        analogModeButton.setDescription(_helpText);
    }

    public void toggleAnalogReadButton(boolean _value) {
        String s = _value ? "Turn Analog Read Off" : "Turn Analog Read On";
        analogModeButton.getCaptionLabel().setText(s);
        if (_value) {
            analogModeButton.setOn();
        } else {
            analogModeButton.setOff();
        }
    }
};

//These functions need to be global! These functions are activated when an item from the corresponding dropdown is selected
public void VertScale_AR(int n) {
    settings.arVertScaleSave = n;
    for(int i = 0; i < w_analogRead.numAnalogReadBars; i++) {
            w_analogRead.analogReadBars[i].adjustVertScale(w_analogRead.yLimOptions[n]);
    }
}

//triggered when there is an event in the LogLin Dropdown
public void Duration_AR(int n) {
    // println("adjust duration to: " + w_analogRead.analogReadBars[i].adjustTimeAxis(n));
    //set analog read x axis to the duration selected from dropdown
    settings.arHorizScaleSave = n;

    //Sync the duration of Time Series, Accelerometer, and Analog Read(Cyton Only)
    for(int i = 0; i < w_analogRead.numAnalogReadBars; i++) {
        if (n == 0) {
            w_analogRead.analogReadBars[i].adjustTimeAxis(w_timeSeries.getTSHorizScale().getValue());
        } else {
            w_analogRead.analogReadBars[i].adjustTimeAxis(w_analogRead.xLimOptions[n]);
        }
    }
}

//========================================================================================================================
//                      Analog Voltage BAR CLASS -- Implemented by Analog Read Widget Class
//========================================================================================================================
//this class contains the plot and buttons for a single channel of the Time Series widget
//one of these will be created for each channel (4, 8, or 16)
class AnalogReadBar{

    private int analogInputPin;
    private int auxValuesPosition;
    private String analogInputString;
    private int x, y, w, h;

    private GPlot plot; //the actual grafica-based GPlot that will be rendering the Time Series trace
    private GPointsArray analogReadPoints;
    private int nPoints;
    private int numSeconds;
    private float timeBetweenPoints;

    private int channelColor; //color of plot trace

    private boolean isAutoscale; //when isAutoscale equals true, the y-axis of each channelBar will automatically update to scale to the largest visible amplitude
    private int autoScaleYLim = 0;
    
    private TextBox analogValue;
    private TextBox analogPin;
    private TextBox digitalPin;

    private boolean drawAnalogValue;
    private int lastProcessedDataPacketInd = 0;

    private AnalogCapableBoard analogBoard;

    AnalogReadBar(PApplet _parent, int _analogInputPin, int _x, int _y, int _w, int _h) { // channel number, x/y location, height, width

        analogInputPin = _analogInputPin;
        int digitalPinNum = 0;
        if (analogInputPin == 7) {
            auxValuesPosition = 2;
            digitalPinNum = 13;
        } else if (analogInputPin == 6) {
            auxValuesPosition = 1;
            digitalPinNum = 12;
        } else {
            analogInputPin = 5;
            auxValuesPosition = 0;
            digitalPinNum = 11;
        }

        analogInputString = str(analogInputPin);

        x = _x;
        y = _y;
        w = _w;
        h = _h;

        numSeconds = 20;
        plot = new GPlot(_parent);
        plot.setPos(x + 36 + 4, y);
        plot.setDim(w - 36 - 4, h);
        plot.setMar(0f, 0f, 0f, 0f);
        plot.setLineColor((int)channelColors[(auxValuesPosition)%8]);
        plot.setXLim(-3.2f,-2.9f);
        plot.setYLim(-200,200);
        plot.setPointSize(2);
        plot.setPointColor(0);
        plot.setAllFontProperties("Arial", 0, 14);
        plot.getXAxis().setFontColor(OPENBCI_DARKBLUE);
        plot.getXAxis().setLineColor(OPENBCI_DARKBLUE);
        plot.getXAxis().getAxisLabel().setFontColor(OPENBCI_DARKBLUE);
        if (selectedProtocol == BoardProtocol.WIFI) {
            if(auxValuesPosition == 1) {
                plot.getXAxis().setAxisLabelText("Time (s)");
            }
        } else {
            if(auxValuesPosition == 2) {
                plot.getXAxis().setAxisLabelText("Time (s)");
            }
        }

        initArrays();
        
        
        analogValue = new TextBox("t", x + 36 + 4 + (w - 36 - 4) - 2, y + h);
        analogValue.textColor = OPENBCI_DARKBLUE;
        analogValue.alignH = RIGHT;
        analogValue.alignV = BOTTOM;
        analogValue.drawBackground = true;
        analogValue.backgroundColor = color(255,255,255,125);

        analogPin = new TextBox("A" + analogInputString, x+3, y + h);
        analogPin.textColor = OPENBCI_DARKBLUE;
        analogPin.alignH = CENTER;
        digitalPin = new TextBox("(D" + digitalPinNum + ")", x+3, y + h + 12);
        digitalPin.textColor = OPENBCI_DARKBLUE;
        digitalPin.alignH = CENTER;

        drawAnalogValue = true;
        analogBoard = (AnalogCapableBoard) currentBoard;
    }

    public void initArrays() {
        nPoints = nPointsBasedOnDataSource();
        timeBetweenPoints = (float)numSeconds / (float)nPoints;
        analogReadPoints = new GPointsArray(nPoints);

        for (int i = 0; i < nPoints; i++) {
            float time = calcTimeAxis(i);
            float analog_value = 0.0f; //0.0 for all points to start
            analogReadPoints.set(i, time, analog_value, "");
        }

        plot.setPoints(analogReadPoints); //set the plot with 0.0 for all auxReadPoints to start
    }

    public void update() {

         // early out if unactive
        if (!analogBoard.isAnalogActive()) {
            return;
        }

        // update data in plot
        updatePlotPoints();
        if(isAutoscale) {
            autoScale();
        }

        //Fetch the last value in the buffer to display on screen
        float val = analogReadPoints.getLastPoint().getY();
        analogValue.string = String.format(getFmt(val),val);
    }

    private String getFmt(float val) {
        String fmt;
        if (val > 100.0f) {
            fmt = "%.0f";
        } else if (val > 10.0f) {
            fmt = "%.1f";
        } else {
            fmt = "%.2f";
        }
        return fmt;
    }

    public float calcTimeAxis(int sampleIndex) {
        return -(float)numSeconds + (float)sampleIndex * timeBetweenPoints;
    }

    public void updatePlotPoints() {
        List<double[]> allData = analogBoard.getDataWithAnalog(nPoints);
        int[] channels = analogBoard.getAnalogChannels();

        if (channels.length == 0) {
            return;
        }
        
        for (int i=0; i < nPoints; i++) {
            float timey = calcTimeAxis(i);
            float value = (float)allData.get(i)[channels[auxValuesPosition]];
            analogReadPoints.set(i, timey, value, "");
        }

        plot.setPoints(analogReadPoints);
    }

    public void draw() {
        pushStyle();

        //draw plot
        stroke(OPENBCI_BLUE_ALPHA50);
        fill(color(125,30,12,30));

        rect(x + 36 + 4, y, w - 36 - 4, h);

        plot.beginDraw();
        plot.drawBox(); // we won't draw this eventually ...
        plot.drawGridLines(GPlot.VERTICAL);
        plot.drawLines();
        if (selectedProtocol == BoardProtocol.WIFI) {
            if(auxValuesPosition == 1) { //only draw the x axis label on the bottom channel bar
                plot.drawXAxis();
                plot.getXAxis().draw();
            }
        }
        else {
            if(auxValuesPosition == 2) { //only draw the x axis label on the bottom channel bar
                plot.drawXAxis();
                plot.getXAxis().draw();
            }
        }

        plot.endDraw();

        if(drawAnalogValue) {
            analogValue.draw();
            analogPin.draw();
            digitalPin.draw();
        }

        popStyle();
    }

    public int nPointsBasedOnDataSource() {
        return numSeconds * ((AnalogCapableBoard)currentBoard).getAnalogSampleRate();
    }

    public void adjustTimeAxis(int _newTimeSize) {
        numSeconds = _newTimeSize;
        plot.setXLim(-_newTimeSize,0);

        nPoints = nPointsBasedOnDataSource();

        analogReadPoints = new GPointsArray(nPoints);
        if (_newTimeSize > 1) {
            plot.getXAxis().setNTicks(_newTimeSize);  //sets the number of axis divisions...
        }
        else {
            plot.getXAxis().setNTicks(10);
        }
        
        updatePlotPoints();
    }

    public void adjustVertScale(int _vertScaleValue) {
        if(_vertScaleValue == 0) {
            isAutoscale = true;
        } else {
            isAutoscale = false;
            plot.setYLim(-_vertScaleValue, _vertScaleValue);
        }
    }

    public void autoScale() {
        autoScaleYLim = 0;
        for(int i = 0; i < nPoints; i++) {
            if(PApplet.parseInt(abs(analogReadPoints.getY(i))) > autoScaleYLim) {
                autoScaleYLim = PApplet.parseInt(abs(analogReadPoints.getY(i)));
            }
        }
        plot.setYLim(-autoScaleYLim, autoScaleYLim);
    }

    public void screenResized(int _x, int _y, int _w, int _h) {
        x = _x;
        y = _y;
        w = _w;
        h = _h;

        plot.setPos(x + 36 + 4, y);
        plot.setDim(w - 36 - 4, h);

        analogValue.x = x + 36 + 4 + (w - 36 - 4) - 2;
        analogValue.y = y + h;

        analogPin.x = x + 14;
        analogPin.y = y + PApplet.parseInt(h/2.0f);
        digitalPin.x = analogPin.x;
        digitalPin.y = analogPin.y + 12;
    }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    W_BandPowers.pde
//
//    This is a band power visualization widget!
//    (Couldn't think up more)
//    This is for visualizing the power of each brainwave band: delta, theta, alpha, beta, gamma
//    Averaged over all channels
//
//    Created by: Wangshu Sun, May 2017
//    Modified by: Richard Waltman, March 2022
//
////////////////////////////////////////////////////////////////////////////////////////////////////////



class W_BandPower extends Widget {

    // indexes
    final int DELTA = 0; // 1-4 Hz
    final int THETA = 1; // 4-8 Hz
    final int ALPHA = 2; // 8-13 Hz
    final int BETA = 3; // 13-30 Hz
    final int GAMMA = 4; // 30-55 Hz
    
    private final int NUM_BANDS = 5;
    private float[] activePower = new float[NUM_BANDS];
    private float[] normalizedBandPowers = new float[NUM_BANDS];

    GPlot bp_plot;
    public ChannelSelect bpChanSelect;
    boolean prevChanSelectIsVisible = false;

    List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();

    W_BandPower(PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        //Add channel select dropdown to this widget
        bpChanSelect = new ChannelSelect(pApplet, this, x, y, w, navH, "BP_Channels");
        bpChanSelect.activateAllButtons();
        cp5ElementsToCheck.addAll(bpChanSelect.getCp5ElementsForOverlapCheck());
        
        //Add settings dropdowns
        addDropdown("Smoothing", "Smooth", Arrays.asList(settings.fftSmoothingArray), smoothFac_ind); //smoothFac_ind is a global variable at the top of W_HeadPlot.pde
        addDropdown("UnfiltFilt", "Filters?", Arrays.asList(settings.fftFilterArray), settings.fftFilterSave);

        // Setup for the BandPower plot
        bp_plot = new GPlot(_parent, x, y-navHeight, w, h+navHeight);
        // bp_plot.setPos(x, y+navHeight);
        bp_plot.setDim(w, h);
        bp_plot.setLogScale("y");
        bp_plot.setYLim(0.1f, 100);
        bp_plot.setXLim(0, 5);
        bp_plot.getYAxis().setNTicks(9);
        bp_plot.getXAxis().setNTicks(0);
        bp_plot.getTitle().setTextAlignment(LEFT);
        bp_plot.getTitle().setRelativePos(0);
        bp_plot.setAllFontProperties("Arial", 0, 14);
        bp_plot.getYAxis().getAxisLabel().setText("Power — (uV)^2 / Hz");
        bp_plot.getXAxis().setAxisLabelText("EEG Power Bands");
        bp_plot.getXAxis().getAxisLabel().setOffset(42f);
        bp_plot.startHistograms(GPlot.VERTICAL);
        bp_plot.getHistogram().setDrawLabels(true);
        bp_plot.getXAxis().setFontColor(OPENBCI_DARKBLUE);
        bp_plot.getXAxis().setLineColor(OPENBCI_DARKBLUE);
        bp_plot.getXAxis().getAxisLabel().setFontColor(OPENBCI_DARKBLUE);
        bp_plot.getYAxis().setFontColor(OPENBCI_DARKBLUE);
        bp_plot.getYAxis().setLineColor(OPENBCI_DARKBLUE);
        bp_plot.getYAxis().getAxisLabel().setFontColor(OPENBCI_DARKBLUE);

        //setting border of histograms to match BG
        bp_plot.getHistogram().setLineColors(new int[]{
            color(245), color(245), color(245), color(245), color(245)
          }
        );
        //setting bg colors of histogram bars to match the color scheme of the channel colors w/ an opacity of 150/255
        bp_plot.getHistogram().setBgColors(new int[] {
                color((int)channelColors[6], 200),
                color((int)channelColors[4], 200),
                color((int)channelColors[3], 200),
                color((int)channelColors[2], 200), 
                color((int)channelColors[1], 200),
            }
        );
        //setting color of text label for each histogram bar on the x axis
        bp_plot.getHistogram().setFontColor(OPENBCI_DARKBLUE);
    } //end of constructor

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
        
        float normalizingSum = 0;

        for (int i = 0; i < NUM_BANDS; i++) {
            float sum = 0;

            for (int j = 0; j < bpChanSelect.activeChan.size(); j++) {
                int chan = bpChanSelect.activeChan.get(j);
                sum += dataProcessing.avgPowerInBins[chan][i];
            }

            activePower[i] = sum / bpChanSelect.activeChan.size();

            normalizingSum += activePower[i];
        }

        for (int i = 0; i < NUM_BANDS; i++) {
            normalizedBandPowers[i] = activePower[i] / normalizingSum;
        }
        
        //Update channel checkboxes and active channels
        bpChanSelect.update(x, y, w);
        
        //Flex the Gplot graph when channel select dropdown is open/closed
        if (bpChanSelect.isVisible() != prevChanSelectIsVisible) {
            flexGPlotSizeAndPosition();
            prevChanSelectIsVisible = bpChanSelect.isVisible();
        }

        GPointsArray bp_points = new GPointsArray(dataProcessing.headWidePower.length);
        bp_points.add(DELTA + 0.5f, activePower[DELTA], "DELTA\n0.5-4Hz");
        bp_points.add(THETA + 0.5f, activePower[THETA], "THETA\n4-8Hz");
        bp_points.add(ALPHA + 0.5f, activePower[ALPHA], "ALPHA\n8-13Hz");
        bp_points.add(BETA + 0.5f, activePower[BETA], "BETA\n13-32Hz");
        bp_points.add(GAMMA + 0.5f, activePower[GAMMA], "GAMMA\n32-100Hz");
        bp_plot.setPoints(bp_points);

        if (bpChanSelect.isVisible()) {
            lockElementsOnOverlapCheck(cp5ElementsToCheck);
        }
    } //end of update

    public void draw() {
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)
        pushStyle();

        //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        // Draw the third plot
        bp_plot.beginDraw();
        bp_plot.drawBackground();
        bp_plot.drawBox();
        bp_plot.drawXAxis();
        bp_plot.drawYAxis();
        bp_plot.drawGridLines(GPlot.HORIZONTAL);
        bp_plot.drawHistograms();
        bp_plot.endDraw();

        //for this widget need to redraw the grey bar, bc the FFT plot covers it up...
        fill(200, 200, 200);
        rect(x, y - navHeight, w, navHeight); //button bar

        popStyle();
        bpChanSelect.draw();
    }

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        flexGPlotSizeAndPosition();

        bpChanSelect.screenResized(pApplet);
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
        bpChanSelect.mousePressed(this.dropdownIsActive); //Calls channel select mousePressed and checks if clicked
    }

    public void mouseReleased() {
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
    }

    public void flexGPlotSizeAndPosition() {
        if (bpChanSelect.isVisible()) {
            bp_plot.setPos(x, y + bpChanSelect.getHeight() - navH);
            bp_plot.setOuterDim(w, h - bpChanSelect.getHeight() + navH);
        } else {
            bp_plot.setPos(x, y - navH);
            bp_plot.setOuterDim(w, h + navH);
        }
    }

    public float[] getNormalizedBPSelectedChannels() {
        return normalizedBandPowers;
    }
};
//Cyton Signal Check Widget aka Cyton Impedance
//Uses classes found in CytonImpedanceEnums.pde and CytonElectrodeStatus.pde



class W_CytonImpedance extends Widget {

    private BoardCyton cytonBoard;

    //Used to synchronize impedance command threads
    private final Object THREAD_LOCK = new Object();
    ExecutorService es = Executors.newCachedThreadPool();

    private Grid dataGrid;

    private ControlP5 imp_buttons_cp5;
    private ControlP5 threshold_ui_cp5;

    private CytonSignalCheckMode signalCheckMode = CytonSignalCheckMode.IMPEDANCE;
    private CytonImpedanceLabels labelMode = CytonImpedanceLabels.ADS_CHANNEL;
    private CytonImpedanceInterval masterCheckInterval = CytonImpedanceInterval.FIVE;
    
    private final int padding = 5;
    private final int padding_3 = 3;
    private int numTableRows = 9;
    private final int numTableColumns = 3;
    private final int tableWidth = 190;
    private int tableHeight = 0;
    private int cellHeight = 10;
    
    private final float mapInitialW = 488f;
    private final float mapInitialH = 488f;
    private int imageContainerW, imageContainerH;
    private PImage cytonHeadplotStatic;
    private CytonElectrodeStatus[] cytonElectrodeStatus;
    private int facepad_x, facepad_y, facepad_w;
    private float facepad_h;
    private int translate_facepadX, translate_facepadY;
    private int imageFooterX, imageFooterY; //same width as imageContainerW
    private int footerHeight;

    private Gif checkingImpedanceOnElectrodeGif;

    private int signalQualityStatusTimer;
    private String signalQualityStatusDescription;

    private Button cytonImpedanceMasterCheck;
    private Button cytonResetAllChannels;
    private int masterCheckCounter = 0; //Used to iterate through electrodes
    private int prevMasterCheckCounter = -1;
    private int numElectrodesToMasterCheck = 0;
    private int prevMasterCheckMillis = 0; //Used for simple timer
    public boolean isCheckingImpedanceOnAnything = false; //This is more reliable than waiting to see if the Board is checking impedance

    private SignalCheckThresholdUI errorThreshold;
    private SignalCheckThresholdUI warningThreshold;
    private int thresholdTFHeight = 14;
    private int thresholdTFWidth = 60; //Hard-code this value since there are deep errors with controlp5.textfield.setSize() and creating new graphics in this class - RW 12/13/2021
    

    W_CytonImpedance(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        cytonBoard = (BoardCyton) currentBoard;

        imp_buttons_cp5 = new ControlP5(ourApplet);
        imp_buttons_cp5.setGraphics(ourApplet, 0,0);
        imp_buttons_cp5.setAutoDraw(false);
        imp_buttons_cp5.setVisible(signalCheckMode == CytonSignalCheckMode.IMPEDANCE);
        threshold_ui_cp5 = new ControlP5(ourApplet);
        threshold_ui_cp5.setGraphics(ourApplet, 0,0);
        threshold_ui_cp5.setAutoDraw(false);

        checkingImpedanceOnElectrodeGif = new Gif(ourApplet, "Rolling-1s-200px.gif");
        checkingImpedanceOnElectrodeGif.loop();

        addDropdown("CytonImpedance_MasterCheckInterval", "Interval", masterCheckInterval.getEnumStringsAsList(), masterCheckInterval.getIndex());
        dropdownWidth = 85; //Override the widget header dropdown width to fit "impedance" mode
        addDropdown("CytonImpedance_LabelMode", "Labels", labelMode.getEnumStringsAsList(), labelMode.getIndex());
        addDropdown("CytonImpedance_Mode", "Mode", signalCheckMode.getEnumStringsAsList(), signalCheckMode.getIndex());

        footerHeight = navH/2;
        
        if (currentBoard.getNumEXGChannels() > 8) {
            numTableRows += 8;
        }

        //Create Table first!
        dataGrid = new Grid(numTableRows, numTableColumns, cellHeight);
        dataGrid.setTableFontAndSize(p6, 10);
        dataGrid.setDrawTableBorder(true);

        //Set Column Labels
        dataGrid.setString("N Status", 0, 1);
        dataGrid.setString("P Status", 0, 2);

        setTableElectrodeNames();

        //Init the electrode map and fill and create signal check buttons
        initCytonImpedanceMap();

        cytonResetAllChannels = createCytonResetChannelsButton("cytonResetAllChannels", "Reset Channels", (int)(x0 + 1), (int)(y0 + navHeight + 1), 90, navHeight - 3, p5, 12, colorNotPressed, OPENBCI_DARKBLUE);
        cytonImpedanceMasterCheck = createCytonImpMasterCheckButton("cytonImpedanceMasterCheck", "Check All Channels", (int)(x0 + 1 + padding_3 + 90), (int)(y0 + navHeight + 1), 120, navHeight - 3, p5, 12, colorNotPressed, OPENBCI_DARKBLUE);
        errorThreshold = new SignalCheckThresholdUI(threshold_ui_cp5, "errorThreshold", x + tableWidth + padding, y + h - navH, thresholdTFWidth, thresholdTFHeight, SIGNAL_CHECK_RED, signalCheckMode);
        warningThreshold = new SignalCheckThresholdUI(threshold_ui_cp5, "warningThreshold", x + tableWidth + padding, y + h - navH/2, thresholdTFWidth, thresholdTFHeight, SIGNAL_CHECK_YELLOW, signalCheckMode);
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        if (is_railed == null) {
            return;
        }

        List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();
        for (int i = 0; i < cytonElectrodeStatus.length; i++) {
            cytonElectrodeStatus[i].update(dataGrid, signalCheckMode.getIsImpedanceMode());
            cp5ElementsToCheck.add((controlP5.Controller)cytonElectrodeStatus[i].getTestingButton());
        }
        cp5ElementsToCheck.add((controlP5.Controller)cytonImpedanceMasterCheck);
        cp5ElementsToCheck.add((controlP5.Controller)cytonResetAllChannels);
        //Ignore button interaction when widgetSelector dropdown is active
        lockElementsOnOverlapCheck(cp5ElementsToCheck);

        errorThreshold.update();
        warningThreshold.update();

        //Use state change logic so we can run this test in the main thread using simple timer
        if (cytonMasterImpedanceCheckIsActive()) {
            doMasterImpedanceCheck();
        } else {
            if (!dropdownIsActive) {
                //setLockAllImpedanceTestingButtons(false);
            }
        }  
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        dataGrid.draw();

        /*
        pushStyle();
        stroke(0,0,0,255);
        fill(0,255,0,50);
        strokeWeight(3);
        rect(facepad_x, facepad_y, facepad_w, (int)facepad_h);
        popStyle();
        */
        //Scale the dataImage to fit in inside the widget
        float s = facepad_w / mapInitialW;
        /*
        pushStyle();
        stroke(0,0,0,255);
        fill(0,100,142,100);
        strokeWeight(3);
        rect(t_facepadX, t_facepadY, facepad_w, (int)facepad_h);
        popStyle();
        */
        pushMatrix(); // save the transformation matrix
        translate(translate_facepadX, translate_facepadY);
        scale(s); // scale the transformation matrix
        /*
        pushStyle();
        stroke(0,0,0,255);
        fill(0,255,0,100);
        strokeWeight(3);
        rect(0, 0, mapInitialW, mapInitialH);
        popStyle();
        */
        image(cytonHeadplotStatic, 0, 0);
        popMatrix(); // restore the transformation matrix

        drawUserLeftRightLabels();

        imp_buttons_cp5.draw();
        threshold_ui_cp5.draw();

        drawImageFooterInfo();
    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        int overrideDropdownWidth = 64;
        cp5_widget.get(ScrollableList.class, "CytonImpedance_MasterCheckInterval").setWidth(overrideDropdownWidth);
        cp5_widget.get(ScrollableList.class, "CytonImpedance_MasterCheckInterval").setPosition(x0+w0-dropdownWidth*2-overrideDropdownWidth-6, navH+y0+2);

        //**IMPORTANT FOR CP5**//
        //This makes the cp5 objects within the widget scale properly
        imp_buttons_cp5.setGraphics(pApplet, 0, 0);
        threshold_ui_cp5.setGraphics(pApplet, 0, 0);

        cytonResetAllChannels.setPosition((int)(x0 + 1), (int)(y0 + navHeight + 1));
        cytonImpedanceMasterCheck.setPosition((int)(x0 + 1 + padding_3 + 90), (int)(y0 + navHeight + 1));

        resizeTable();

        imageContainerW = w - padding*3 - tableWidth;
        imageContainerH = h - padding*2 - navH;

        facepad_x = x + padding*2 + tableWidth;
        facepad_y = y + padding;
        facepad_w = w - padding*3 - tableWidth;
        //println("BEFORE="+facepad_w);
        //Get scale using container width for facepad divided by original width of image
        float _scale = facepad_w / mapInitialW;
        facepad_h = _scale * mapInitialH;
        if (facepad_h > imageContainerH) {
            //println("OOPS... FACEPAD WOULD BE TOO BIG, RESIZING TO FIT WIDGET AND KEEP ASPECT RATIO", facepad_h, imageContainerH);
            facepad_w = Math.round(facepad_w * (imageContainerH / facepad_h));
            _scale = facepad_w / mapInitialW;
            facepad_h = _scale * mapInitialH;
            //println("AFTER=="+facepad_w);
        }

        //Center the image horizontally and vertically
        translate_facepadX = (facepad_w < imageContainerW) ? facepad_x + PApplet.parseInt((imageContainerW - facepad_w) / 2) : facepad_x;
        translate_facepadY = (facepad_h < imageContainerH) ? facepad_y + (PApplet.parseInt(imageContainerH/2) - PApplet.parseInt(facepad_h/2)) : facepad_y;

        for (int i = 0; i < cytonElectrodeStatus.length; i++) {
            cytonElectrodeStatus[i].resizeButton(dataGrid);
        }

        //Calculate these values last
        imageFooterX = translate_facepadX + facepad_w / 2; //centered under the visual map container
        imageFooterY = y + h - footerHeight;
        
        //final int thresholdTF_y = y + tableHeight + padding*2;
        RectDimensions dim = dataGrid.getCellDims(numTableRows - 1, 1);
        warningThreshold.setPosition(dim.x, dim.y + dim.h + padding);
        dim = dataGrid.getCellDims(numTableRows - 1, 2);
        errorThreshold.setPosition(dim.x + 1, dim.y + dim.h + padding);
    }

    private void resizeTable() {
        tableHeight = getTableContainerHeight();
        dataGrid.setDim(x + padding, y + padding, tableWidth);
        dataGrid.setTableHeight(tableHeight);
        dataGrid.dynamicallySetTextVerticalPadding(0, 1);
        dataGrid.setHorizontalCenterTextInCells(true);
    }

    private int getTableContainerHeight() {
        return h - (padding * 3) - footerHeight;
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
    }

    private void initCytonImpedanceMap() {
        if (nchan == 8) {
            cytonHeadplotStatic = loadImage("Cyton_8Ch_Static_Headplot_Image.png");
        } else {
            cytonHeadplotStatic = loadImage("Cyton_16Ch_Static_Headplot_Image.png");
        }
        
        //Instantiate electrodeStatus for all electrodes!
        cytonElectrodeStatus = new CytonElectrodeStatus[nchan];
        for (int i = 0; i < cytonElectrodeStatus.length; i++) {
            cytonElectrodeStatus[i] = new CytonElectrodeStatus(imp_buttons_cp5, CytonElectrodeLocations.getByIndex(i), cytonBoard, checkingImpedanceOnElectrodeGif);
            //println("CYTON ELECTRODE STATUS making electrode #", i);
        }
    }

    public void setTableElectrodeNames() {
        if (labelMode.getIsAnatomicalName()) {
            //If true, set anatomical names as text in the table.
            dataGrid.setString("Position", 0, 0);
            for (int i = 1; i < numTableRows; i++) {
                dataGrid.setString(cytonElectrodeStatus[i - 1].getThisElectrodeLabel(), i, 0);
            }
        } else {
            //Else, set ADS Channel names
            dataGrid.setString("Channel", 0, 0);
            for (int i = 1; i < numTableRows; i++) {
                dataGrid.setString(Integer.toString(i), i, 0);
            }
        }
    }


    //This is a very important method that helps this widget change signal check mode. Called when user selects option from Mode dropdown.
    public void setSignalCheckMode(int n) {
        signalCheckMode = signalCheckMode.values()[n];
        if (signalCheckMode == CytonSignalCheckMode.LIVE) {
            ////Toggle showing impedance test buttons
            imp_buttons_cp5.setVisible(false);
            //Green out all electrode positions initially when switching to railed/live mode
            for (int i = 0; i < cytonElectrodeStatus.length; i++) {
                cytonElectrodeStatus[i].setElectrodeGreenStatus();
            }
            turnOffImpedanceCheckPreviousElectrode();
            //Hide and disable master impedance check
            cytonImpedanceMasterCheck.setVisible(false);
            cytonImpedanceMasterCheck.setOff();
        } else if (signalCheckMode == CytonSignalCheckMode.IMPEDANCE) {
            //Attempt to close Hardware Settings view. Also, throws a popup if there are unsent changes.
            if (w_timeSeries.getAdsSettingsVisible()) {
                w_timeSeries.closeADSSettings();
            }
            //Clear the cells and show buttons instead
            for (int i = 1; i < numTableRows; i++) {
                dataGrid.setString(null, i, 1);
                dataGrid.setString(null, i, 2);
            }
            //Toggle showing impedance test buttons
            imp_buttons_cp5.setVisible(true);

            cytonImpedanceMasterCheck.setVisible(true);
        }
        errorThreshold.updateTextfieldModeChanged(signalCheckMode);
        warningThreshold.updateTextfieldModeChanged(signalCheckMode);
    }

    public void setShowAnatomicalName(int n) {
        labelMode = labelMode.values()[n];
        setTableElectrodeNames();
    }

    public void setMasterCheckInterval(int n) {
        masterCheckInterval = masterCheckInterval.values()[n];
        println("MASTERCHECKINTERVAL_CHANGE", masterCheckInterval);
    }
    
    public void drawUserLeftRightLabels() {
        pushStyle();
        fill(OPENBCI_DARKBLUE);
        textAlign(CENTER);
        textFont(h4, 14);
        String s = "User Left";
        float _x = translate_facepadX + facepad_w * .2f;
        float _y = y + 20;
        text(s, _x , _y);
        s = "User Right";
        _x = translate_facepadX + facepad_w * .8f;
        text(s, _x , _y);
        popStyle();
    }

    private void drawImageFooterInfo() {
        //Draw "thresholds" text label below the table under the first column
        RectDimensions dim = dataGrid.getCellDims(numTableRows - 1, 0);
        int thresholdTextX = dim.x + dim.w / 2;
        pushStyle();
        textFont(p6, 10);
        textAlign(CENTER, TOP);
        fill(ElectrodeState.GREYED_OUT.getColor());
        text("Thresholds", thresholdTextX, dim.y + dim.h + padding);
        popStyle();
        
        pushStyle();
        textFont(p5, 12);
        textAlign(CENTER);
        String s;
        int c = ElectrodeState.GREYED_OUT.getColor();
        if (signalCheckMode == CytonSignalCheckMode.IMPEDANCE) {
            Pair<String, ElectrodeState> pair = getImpedanceStringAndState();
            s = pair.getLeft();
            c = pair.getRight().getColor();
            //Skip over facepad electrodes that do not correspond to a channel number (PPG, EDA, BIAS, and SRB2)
            if (s == null) {
                if (cytonImpedanceMasterCheck.getBooleanValue()) {
                    popStyle();
                    return;
                } else {
                    //If not checking impedance on all channels, display this text in the footer
                    s = "Click a \"Test\" button in the table to start.";
                }
            }
        } else {
            s = numberOfRailedChanDescription();
        }
        fill(c);
        text(s, imageFooterX, imageFooterY);
        popStyle();
    }

    private String numberOfRailedChanDescription() {
        //Update roughly once a second, to keep text from jittering between options
        boolean timeToUpdate = millis() > signalQualityStatusTimer + 1000;
        if (timeToUpdate) {
            int counter = 0;
            for (int i = 0; i < is_railed.length; i++) {
                if (is_railed[i].is_railed) {
                    counter++;
                }
            }
            String s;
            if (counter == 0) {
                s = "Looks great! No railed channels.";
            } else if (counter > 0 && counter <= 5) {
                s = "A few channels are railed.";
            } else {
                s = "Many channels are railed right now."; 
            }
            signalQualityStatusTimer = millis();
            signalQualityStatusDescription = s;
        }     
        return signalQualityStatusDescription;
    }

    private Pair<String, ElectrodeState> getImpedanceStringAndState() {
        final Integer CHAN_X = cytonBoard.isCheckingImpedanceOnAnyChannelsNorP().getValue();
        final Boolean CHAN_X_ISNPIN = cytonBoard.isCheckingImpedanceOnAnyChannelsNorP().getKey();
        final int NUM_FRONT_CHAN = 8;
        if (CHAN_X == null && CHAN_X_ISNPIN == null) {
            return new ImmutablePair<String, ElectrodeState>(null, ElectrodeState.GREYED_OUT);
        }

        final Integer _CHAN = CHAN_X + 1;
        for (CytonElectrodeStatus e : cytonElectrodeStatus) {
            //println(_chan, e.getGUIChannelNumber(), " -- ", chanX_isNpin, e.getIsNPin());
            if (_CHAN.equals(e.getGUIChannelNumber())
                && CHAN_X_ISNPIN.equals(e.getIsNPin())) {
                    return new ImmutablePair<String, ElectrodeState>(
                        e.getImpedanceValueAsString(labelMode.getIsAnatomicalName()), 
                        e.getElectrodeState()
                    );
            }
        }
        return new ImmutablePair<String, ElectrodeState>("Oops?", ElectrodeState.GREYED_OUT);
    }

    private Button createCytonImpMasterCheckButton(String name, String text, int _x, int _y, int _w, int _h, PFont _font, int _fontSize, int _bg, int _textColor) {
        final Button myButton = createButton(cp5_widget, name, text, _x, _y, _w, _h, _font, _fontSize, _bg, _textColor);
        myButton.setSwitch(true);
        myButton.setBorderColor(OBJECT_BORDER_GREY);
        myButton.setVisible(signalCheckMode == CytonSignalCheckMode.IMPEDANCE);
        myButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                boolean isActive = myButton.getBooleanValue();
                StringBuilder sb = new StringBuilder("Signal Quality Test: User toggled checking impedance on all channels to ");
                sb.append(isActive);
                println(sb.toString());
                if (!isActive) {
                    Executors.newSingleThreadExecutor().execute(new Runnable() {
                        @Override
                        public void run() {
                            hardResetAllChannels();
                        }
                    });
                } else {
                    setLockAllImpedanceTestingButtons(isActive);
                }
            }
        });
        myButton.setDescription("Click to check impedance on all electrodes. Please allow time for commands to be sent to the board.");
        return myButton;
    }

    public boolean cytonMasterImpedanceCheckIsActive() {
        return cytonImpedanceMasterCheck.getBooleanValue();
    }

    private Button createCytonResetChannelsButton(String name, String text, int _x, int _y, int _w, int _h, PFont _font, int _fontSize, int _bg, int _textColor) {
        final Button myButton = createButton(cp5_widget, name, text, _x, _y, _w, _h, _font, _fontSize, _bg, _textColor);
        //myButton.setSwitch(true);
        myButton.setVisible(signalCheckMode == CytonSignalCheckMode.IMPEDANCE);
        myButton.setBorderColor(OBJECT_BORDER_GREY);
        myButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                println("Cyton Impedance Check: User clicked reset all channel settings.");
                Executors.newSingleThreadExecutor().execute(new Runnable() {
                    @Override
                    public void run() {
                        hardResetAllChannels();
                    }
                });
            }
        });
        myButton.setDescription("Click to reset all channel settings to default.");
        return myButton;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Toggle impedance on an electrode using commands sent to board and override the testing button.              //
    //  Do this asynchonously in a separate thread for the first time in the history of the GUI!!!                  //
    //  This is the most important method in this class.                                                            //
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public void toggleImpedanceOnElectrode(final boolean toggle, final Integer checkingChanX, final Boolean checkingChanX_isNpin, final int curMillis) {
        isCheckingImpedanceOnAnything = toggle;
        try {
            es.submit(new Runnable() {
                @Override
                public void run() {
                    synchronized (THREAD_LOCK) {
                        setLockAllImpedanceTestingButtons(true);
                        //println("^^^^^^^^^^^NEW THREAD!!!");

                        if (topNav.dataStreamingButtonIsActive()) {
                            stopRunning();
                            topNav.resetStartStopButton();
                        } else {
                            cytonBoard.stopStreaming();
                        }

                        delay(100);

                        //Turn off impedance check on another electrode if checking there
                        Integer checkingOtherChan = cytonBoard.isCheckingImpedanceOnAnyChannelsNorP().getValue();
                        Boolean checkingOtherChan_isNpin = cytonBoard.isCheckingImpedanceOnAnyChannelsNorP().getKey();
                        if (checkingOtherChan != null) {
                            if (checkingChanX != checkingOtherChan || (checkingChanX == checkingOtherChan && checkingChanX_isNpin != checkingOtherChan_isNpin)) {
                                //println("-----SEND COMMAND TO TOGGLE OFF PREVIOUS ELECTRODE");
                                cytonBoard.setCheckingImpedanceCyton(checkingOtherChan, false, checkingOtherChan_isNpin);
                                
                                checkingOtherChan = checkingOtherChan + 1;
                                for (CytonElectrodeStatus e : cytonElectrodeStatus) {
                                    //println(_chan, e.getGUIChannelNumber(), " -- ", checkingChanX_isNpin, e.getIsNPin());
                                    if (checkingOtherChan.equals(e.getGUIChannelNumber())
                                        && checkingOtherChan_isNpin.equals(e.getIsNPin())) {
                                            //println("TOGGLE OFF", e.getGUIChannelNumber(), e.getIsNPin(), "TOGGLE TO ==", false);
                                            e.overrideTestingButtonSwitch(false);
                                            w_timeSeries.adsSettingsController.updateChanSettingsDropdowns(checkingOtherChan-1, cytonBoard.isEXGChannelActive(checkingOtherChan-1));
                                            w_timeSeries.adsSettingsController.setHasUnappliedSettings(checkingOtherChan-1, false);
                                    }
                                }

                                //Add a small delay between turning off previous channel check and checking impedance on new channel
                                //println("~*~*~* 150ms Delay");
                                delay(150);
                            }
                        }

                        //println("+++++TOGGLING IMPEDANCE");
                        final Pair<Boolean, String> fullResponse = cytonBoard.setCheckingImpedanceCyton(checkingChanX, toggle, checkingChanX_isNpin);
                        boolean response = fullResponse.getKey().booleanValue();
                        if (!response) {
                            println("Board Communication Error: Error sending impedance test commands. See additional info in Console Log. You may need to reset the hardware.");
                            PopupMessage msg = new PopupMessage("Board Communication Error", "Error sending impedance test commands during Check All Channels. See additional info in Console Log. You may need to reset the hardware.");
                            cytonImpedanceMasterCheck.setOff();
                        } else {
                            //If successful, update the front end components to reflect the new state
                            w_timeSeries.adsSettingsController.updateChanSettingsDropdowns(checkingChanX, cytonBoard.isEXGChannelActive(checkingChanX));
                            w_timeSeries.adsSettingsController.setHasUnappliedSettings(checkingChanX, false);
                        }

                        boolean shouldBeOn = toggle && response;
                        final Integer _chan = checkingChanX + 1;
                        for (CytonElectrodeStatus e : cytonElectrodeStatus) {
                            //println(_chan, e.getGUIChannelNumber(), " -- ", checkingChanX_isNpin, e.getIsNPin());
                            if (_chan.equals(e.getGUIChannelNumber())
                                && checkingChanX_isNpin.equals(e.getIsNPin())) {
                                    //println("TOGGLE ", e.getGUIChannelNumber(), e.getIsNPin(), "TOGGLE TO ==", shouldBeOn);
                                    e.overrideTestingButtonSwitch(shouldBeOn);
                                }
                        }

                        Boolean isCheckingImpedance = cytonBoard.isCheckingImpedanceOnAnyChannelsNorP().getLeft();
                        if (isCheckingImpedance != null) {
                            if (!currentBoard.isStreaming()) {
                                cytonBoard.startStreaming();
                            }
                        } else {
                            cytonBoard.stopStreaming();
                        }
                        
                        if (!cytonMasterImpedanceCheckIsActive()) {
                            setLockAllImpedanceTestingButtons(false);
                        } else {
                            prevMasterCheckMillis = curMillis;
                            masterCheckCounter++;

                            if (masterCheckCounter == numElectrodesToMasterCheck) {
                                masterCheckCounter = 0;
                            }
                        }
                    }
                }
            });
        } catch (RejectedExecutionException e) {
            println("CytonImpedanceError::"+e.getMessage());
            outputError("Cyton Signal Check Error: Please be patient when pressing \'Check All Channels\' button!");
            PopupMessage msg = new PopupMessage("Cyton Signal Check Error", "Please be patient when pressing \'Check All Channels\' button! You will likely need to restart a GUI session and turn the Cyton off and on.");
        }
    }

    ////////////////////////////////////////////////////////////////
    //  Master Impedance Check has been toggled on. Do the work!  //
    ////////////////////////////////////////////////////////////////
    private void doMasterImpedanceCheck() {
        setLockAllImpedanceTestingButtons(true);
        final int curMillis = millis();
        final boolean iterateNow = prevMasterCheckCounter != masterCheckCounter && curMillis - prevMasterCheckMillis > masterCheckInterval.getValue();
        //println("MASTER_CHECK_TIMER==",curMillis - prevMasterCheckMillis);
        
        if (iterateNow) {
            
            prevMasterCheckCounter = masterCheckCounter;

            numElectrodesToMasterCheck = currentBoard.getNumEXGChannels();

            /*
            if (guiSettings.getExpertModeBoolean()) {
                numElectrodesToMasterCheck += nchan; //CHECK N AND P IF EXPERT MODE
            }
            */
            
            /*
            if (masterCheckCounter == numElectrodesToMasterCheck) {
                masterCheckCounter = 0;
                prevMasterCheckCounter = 0;
            }
            */

            boolean isNPin = true;
            Integer guiChanNum = null;
            isNPin = cytonElectrodeStatus[masterCheckCounter].getIsNPin();
            guiChanNum = cytonElectrodeStatus[masterCheckCounter].getGUIChannelNumber();
            //println("MASTER_CHECK_TIMER_CHECKING==", guiChanNum, isNPin);

            /*
            if (guiChanNum == null) {
                prevMasterCheckMillis = curMillis - masterCheckInterval.getValue();
                //println("SKIP!!!!!!");
                return;
            }
            */

            guiChanNum -= 1; //Subtract 1 here since the following methods count starting from 0

            // Toggle impedance on for the next electrode
            toggleImpedanceOnElectrode(true, guiChanNum, isNPin, curMillis);
            
        }
    }

    private void hardResetAllChannels() {

        if (cytonMasterImpedanceCheckIsActive()) {
            cytonImpedanceMasterCheck.setOff();
            cytonBoard.stopStreaming();
        }

        if (topNav.dataStreamingButtonIsActive()) {
            stopRunning();
            topNav.resetStartStopButton();
        }

        //es.shutdown();
        int timeElapsed = millis();
        //println("______________________________AWAITING TERMINATION OF EXECUTOR SERVICE___");
        es.shutdown();
        try {
            if (!es.awaitTermination(10, TimeUnit.SECONDS)) {
                es.shutdownNow();
                println("ERROR: HAD TO FORCE EXECUTOR SERVICE SHUTDOWN");
            }
        } catch (InterruptedException ex) {
            ex.printStackTrace();
            es.shutdownNow();
            Thread.currentThread().interrupt();
        }
        es = Executors.newCachedThreadPool();
        
        /*
        final Integer checkingChanX = cytonBoard.isCheckingImpedanceOnAnyChannelsNorP().getValue();
        final Boolean checkingChanX_isNpin = cytonBoard.isCheckingImpedanceOnAnyChannelsNorP().getKey();
        if (checkingChanX != null) {
            println("&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&HAVING TO FORCE TURN OFF AN ELECTRODE THAT WAS LEFT ON");
        }
        */

        turnOffImpedanceCheckPreviousElectrode();
        setLockAllImpedanceTestingButtons(true);

        es.shutdown();
        try {
            if (!es.awaitTermination(10, TimeUnit.SECONDS)) {
                es.shutdownNow();
                println("ERROR: HAD TO FORCE EXECUTOR SERVICE SHUTDOWN");
            }
        } catch (InterruptedException ex) {
            ex.printStackTrace();
            es.shutdownNow();
            Thread.currentThread().interrupt();
        }
        es = Executors.newCachedThreadPool();
        
        // Send board reset twice to increase success rate
        cytonBoard.sendCommand("d");
        delay(100);
        cytonBoard.sendCommand("d");

        // Update ADS1299 settings to default but don't commit. Instead, sent "d" command twice.
        cytonBoard.getADS1299Settings().revertAllChannelsToDefaultValues();
        w_timeSeries.adsSettingsController.updateAllChanSettingsDropdowns();

        timeElapsed = millis() - timeElapsed;
        StringBuilder sb = new StringBuilder("Cyton Impedance Check: Hard reset to default board mode took -- ");
        sb.append(timeElapsed);
        sb.append(" ms");
        println(sb.toString());

        prevMasterCheckCounter--;
        setLockAllImpedanceTestingButtons(false);
        outputSuccess("Cyton: All channels have been reset and board is in default mode!\n");
    }

    private void turnOffImpedanceCheckPreviousElectrode() {
        //Turn off impedance check on another electrode if checking there
        final Integer checkingChanX = cytonBoard.isCheckingImpedanceOnAnyChannelsNorP().getValue();
        final Boolean checkingChanX_isNpin = cytonBoard.isCheckingImpedanceOnAnyChannelsNorP().getKey();
        if (checkingChanX != null) {
            //println("---------------------------TURN OFF IMPEDANCE CHECK ON ELECTRODE="+checkingChanX+" | IS_N_PIN="+checkingChanX_isNpin);
            toggleImpedanceOnElectrode(false, checkingChanX, checkingChanX_isNpin, millis());
        }
    }

    private void setLockAllImpedanceTestingButtons(boolean _b) {
        //println("*************************************************************LOCKING ALL TEST BUTTONS==",_b);
        for (int i = 0; i < cytonElectrodeStatus.length; i++) {
            cytonElectrodeStatus[i].setLockTestingButton(_b);
        }
    }

    public boolean signalCheckIsRailedMode() {
        return signalCheckMode == CytonSignalCheckMode.LIVE;
    }

    public void updateElectrodeStatusGreenThreshold(double _d) {
        for (int i = 0; i < cytonElectrodeStatus.length; i++) {
            cytonElectrodeStatus[i].updateGreenThreshold(_d);
        }
    }

    public void updateElectrodeStatusYellowThreshold(double _d) {
        for (int i = 0; i < cytonElectrodeStatus.length; i++) {
            cytonElectrodeStatus[i].updateYellowThreshold(_d);
        }
    }
};

//These functions need to be global! These functions are activated when an item from the corresponding dropdown is selected
//Update: It's not worth the trouble to implement a callback listener in the widget for this specifc kind of dropdown. Keep using this pattern for widget Nav dropdowns. - February 2021 RW
public void CytonImpedance_Mode(int n) {
    w_cytonImpedance.setSignalCheckMode(n);
}

public void CytonImpedance_LabelMode(int n) {
    w_cytonImpedance.setShowAnatomicalName(n);
}

public void CytonImpedance_MasterCheckInterval(int n) {
    w_cytonImpedance.setMasterCheckInterval(n);
}

////////////////////////////////////////////////////
//
//  W_DigitalRead is used to visiualze digital input values
//
//  Created: AJ Keller
//
//
///////////////////////////////////////////////////,

class W_DigitalRead extends Widget {
    private int numDigitalReadDots;
    float xF, yF, wF, hF;
    int dot_padding;
    //values for actual time series chart (rectangle encompassing all digitalReadDots)
    float dot_x, dot_y, dot_h, dot_w;
    float plotBottomWell;
    float playbackWidgetHeight;
    int digitalReaddotHeight;

    DigitalReadDot[] digitalReadDots;

    private Button digitalModeButton;

    private DigitalCapableBoard digitalBoard;

    W_DigitalRead(PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        digitalBoard = (DigitalCapableBoard)currentBoard;

        //set number of digital reads
        if (selectedProtocol == BoardProtocol.WIFI) {
            numDigitalReadDots = 3;
        } else {
            numDigitalReadDots = 5;
        }

        xF = PApplet.parseFloat(x); //float(int( ... is a shortcut for rounding the float down... so that it doesn't creep into the 1px margin
        yF = PApplet.parseFloat(y);
        wF = PApplet.parseFloat(w);
        hF = PApplet.parseFloat(h);

        dot_padding = 10;
        dot_x = xF + dot_padding;
        dot_y = yF + (dot_padding);
        dot_w = wF - dot_padding*2;
        dot_h = hF - playbackWidgetHeight - plotBottomWell - (dot_padding*2);
        digitalReaddotHeight = PApplet.parseInt(dot_h/numDigitalReadDots);

        digitalReadDots = new DigitalReadDot[numDigitalReadDots];

        //create our channel bars and populate our digitalReadDots array!
        for (int i = 0; i < numDigitalReadDots; i++) {
            int digitalReaddotY = PApplet.parseInt(dot_y) + i*(digitalReaddotHeight); //iterate through bar locations
            int digitalReaddotX = PApplet.parseInt(dot_x) + i*(digitalReaddotHeight); //iterate through bar locations
            int digitalPin = 0;
            if (i == 0) {
                digitalPin = 11;
            } else if (i == 1) {
                digitalPin = 12;
            } else if (i == 2) {
                if (selectedProtocol == BoardProtocol.WIFI) {
                    digitalPin = 17;
                } else {
                    digitalPin = 13;
                }
            } else if (i == 3) {
                digitalPin = 17;
            } else {
                digitalPin = 18;
            }
            DigitalReadDot tempDot = new DigitalReadDot(_parent, digitalPin, digitalReaddotX, digitalReaddotY, PApplet.parseInt(dot_w), digitalReaddotHeight, dot_padding);
            digitalReadDots[i] = tempDot;
        }

        createDigitalModeButton("digitalModeButton", "Turn Digital Read On", (int)(x0 + 1), (int)(y0 + navHeight + 1), 128, navHeight - 3, p5, 12, buttonsLightBlue, WHITE);
    }

    public int getNumDigitalReads() {
        return numDigitalReadDots;
    }

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        if (currentBoard instanceof DataSourcePlayback) {
            if (((DataSourcePlayback)currentBoard) instanceof DigitalCapableBoard
                && (!((DigitalCapableBoard)currentBoard).isDigitalActive())) {
                    return;
            }
        }

        //update channel bars ... this means feeding new EEG data into plots
        for (int i = 0; i < numDigitalReadDots; i++) {
            digitalReadDots[i].update();
        }

        //ignore top left button interaction when widgetSelector dropdown is active
        List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();
        cp5ElementsToCheck.add((controlP5.Controller)digitalModeButton);
        lockElementsOnOverlapCheck(cp5ElementsToCheck);

        if (!digitalBoard.canDeactivateDigital()) {
            digitalModeButton.setLock(true);
            digitalModeButton.getCaptionLabel().setText("Digital Read On");
            digitalModeButton.setColorBackground(BUTTON_LOCKED_GREY);
        }
    }

    public void draw() {
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        //draw channel bars
        if (digitalBoard.isDigitalActive()) {
            for (int i = 0; i < numDigitalReadDots; i++) {
                digitalReadDots[i].draw();
            }
        }
    }

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        xF = PApplet.parseFloat(x); //float(int( ... is a shortcut for rounding the float down... so that it doesn't creep into the 1px margin
        yF = PApplet.parseFloat(y);
        wF = PApplet.parseFloat(w);
        hF = PApplet.parseFloat(h);

        if (wF > hF) {
            digitalReaddotHeight = PApplet.parseInt(hF/(numDigitalReadDots+1));
        } else {
            digitalReaddotHeight = PApplet.parseInt(wF/(numDigitalReadDots+1));
        }

        if (numDigitalReadDots == 3) {
            digitalReadDots[0].screenResized(x+PApplet.parseInt(wF*(1.0f/3.0f)), y+PApplet.parseInt(hF*(1.0f/3.0f)), digitalReaddotHeight, digitalReaddotHeight); //bar x, bar y, bar w, bar h
            digitalReadDots[1].screenResized(x+PApplet.parseInt(wF/2), y+PApplet.parseInt(hF/2), digitalReaddotHeight, digitalReaddotHeight); //bar x, bar y, bar w, bar h
            digitalReadDots[2].screenResized(x+PApplet.parseInt(wF*(2.0f/3.0f)), y+PApplet.parseInt(hF*(2.0f/3.0f)), digitalReaddotHeight, digitalReaddotHeight); //bar x, bar y, bar w, bar h
        } else {
            int y_pad = y + dot_padding;
            digitalReadDots[0].screenResized(x+PApplet.parseInt(wF*(1.0f/8.0f)), y_pad+PApplet.parseInt(hF*(1.0f/8.0f)), digitalReaddotHeight, digitalReaddotHeight);
            digitalReadDots[2].screenResized(x+PApplet.parseInt(wF/2), y_pad+PApplet.parseInt(hF/2), digitalReaddotHeight, digitalReaddotHeight);
            digitalReadDots[4].screenResized(x+PApplet.parseInt(wF*(7.0f/8.0f)), y_pad+PApplet.parseInt(hF*(7.0f/8.0f)), digitalReaddotHeight, digitalReaddotHeight);
            digitalReadDots[1].screenResized(digitalReadDots[0].dotX+PApplet.parseInt(wF*(3.0f/16.0f)), digitalReadDots[0].dotY+PApplet.parseInt(hF*(3.0f/16.0f)), digitalReaddotHeight, digitalReaddotHeight);
            digitalReadDots[3].screenResized(digitalReadDots[2].dotX+PApplet.parseInt(wF*(3.0f/16.0f)), digitalReadDots[2].dotY+PApplet.parseInt(hF*(3.0f/16.0f)), digitalReaddotHeight, digitalReaddotHeight);

        }

        digitalModeButton.setPosition((int)(x0 + 1), (int)(y0 + navHeight + 1));
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
    }

    public void mouseReleased() {
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
    }

    private void createDigitalModeButton(String name, String text, int _x, int _y, int _w, int _h, PFont _font, int _fontSize, int _bg, int _textColor) {
        digitalModeButton = createButton(cp5_widget, name, text, _x, _y, _w, _h, 0, _font, _fontSize, _bg, _textColor, BUTTON_HOVER, BUTTON_PRESSED, OBJECT_BORDER_GREY, 0);
        digitalModeButton.setSwitch(true);
        digitalModeButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (!digitalBoard.isDigitalActive()) {
                    digitalBoard.setDigitalActive(true);
                    digitalModeButton.getCaptionLabel().setText("Turn Digital Read Off");	
                    if (selectedProtocol == BoardProtocol.WIFI) {
                        output("Starting to read digital inputs on pin marked D11, D12 and D17");
                    } else {
                        output("Starting to read digital inputs on pin marked D11, D12, D13, D17 and D18");
                    }
                    w_accelerometer.accelBoardSetActive(false);
                    w_analogRead.toggleAnalogReadButton(false);
                    w_pulsesensor.toggleAnalogReadButton(false);
                } else {
                    digitalBoard.setDigitalActive(false);
                    digitalModeButton.getCaptionLabel().setText("Turn Digital Read On");
                    output("Starting to read accelerometer");
                    w_accelerometer.accelBoardSetActive(true);
                    w_analogRead.toggleAnalogReadButton(false);
                    w_pulsesensor.toggleAnalogReadButton(false);
                }
            }
        });
        String _helpText = (selectedProtocol == BoardProtocol.WIFI) ? 
            "Click this button to activate/deactivate digital read on Cyton pins D11, D12, and D17." :
            "Click this button to activate/deactivate digital read on Cyton pins D11, D12, D13, D17 and D18."
            ;
        digitalModeButton.setDescription(_helpText);
    }

    public void toggleDigitalReadButton(boolean _value) {
        String s = _value ? "Turn Digital Read Off" : "Turn Digital Read On";
        digitalModeButton.getCaptionLabel().setText(s);
        if (_value) {
            digitalModeButton.setOn();
        } else {
            digitalModeButton.setOff();
        }
    }
};

//========================================================================================================================
//                      Analog Voltage BAR CLASS -- Implemented by Analog Read Widget Class
//========================================================================================================================
//this class contains the plot and buttons for a single channel of the Time Series widget
//one of these will be created for each channel (4, 8, or 16)
class DigitalReadDot{

    private int digitalInputPin;
    private int digitalInputVal;
    String digitalInputString;
    int padding;

    TextBox digitalValue;
    TextBox digitalPin;

    boolean drawDigitalValue;

    int dotStroke = 0xFFD2D2D2;
    int dot0Fill = 0xFFF5F5F5;
    int dot1Fill = 0xFFF5F5F5;
    int val0Fill = OPENBCI_DARKBLUE;
    int val1Fill = WHITE;

    int dotX;
    int dotY;
    int dotWidth;
    int dotHeight;
    float dotCorner;

    DigitalCapableBoard digitalBoard;

    DigitalReadDot(PApplet _parent, int _digitalInputPin, int _x, int _y, int _w, int _h, int _padding) { // channel number, x/y location, height, width

        digitalBoard = (DigitalCapableBoard)currentBoard;

        digitalInputPin = _digitalInputPin;
        digitalInputString = str(digitalInputPin);
        digitalInputVal = 0;

        if (digitalInputPin == 11) {
            dot1Fill = channelColors[0];
        } else if (digitalInputPin == 12) {
            dot1Fill = channelColors[1];
        } else if (digitalInputPin == 13) {
            dot1Fill = channelColors[2];
        } else if (digitalInputPin == 17) {
            dot1Fill = channelColors[3];
        } else { // 18
            dot1Fill = channelColors[4];
        }

        dotX = _x;
        dotY = _y;
        dotWidth = _w;
        dotHeight = _h;
        padding = _padding;

        digitalValue = new TextBox("", dotX, dotY);
        digitalValue.textColor = val0Fill;
        digitalValue.alignH = CENTER;
        digitalValue.alignV = CENTER;
        drawDigitalValue = true;

        digitalPin = new TextBox("D" + digitalInputString, dotX, dotY - dotWidth);
        digitalPin.textColor = OPENBCI_DARKBLUE;
        digitalPin.alignH = CENTER;
    }

    public void update() {
        List<double[]> lastData = digitalBoard.getDataWithDigital(1);
        double[] lastSample = lastData.get(0);
        int[] digitalChannels = digitalBoard.getDigitalChannels();

        //update the voltage values
        if (digitalInputPin == 11) {
            digitalInputVal = (int)lastSample[digitalChannels[0]];
        } else if (digitalInputPin == 12) {
            digitalInputVal = (int)lastSample[digitalChannels[1]];
        } else if (digitalInputPin == 13) {
            digitalInputVal = (int)lastSample[digitalChannels[2]];
        } else if (digitalInputPin == 17) {
            digitalInputVal = (int)lastSample[digitalChannels[3]];
        } else {
            // 18
            digitalInputVal = (int)lastSample[digitalChannels[4]];
        }

        digitalValue.string = String.format("%d", digitalInputVal);
    }

    public void draw() {
        pushStyle();

        if (digitalInputVal == 1) {
            fill(dot1Fill);
            digitalValue.textColor = val1Fill;
        } else {
            fill(dot0Fill);
            digitalValue.textColor = val0Fill;
        }
        stroke(dotStroke);
        ellipse(dotX, dotY, dotWidth, dotHeight);

        if (drawDigitalValue) {
            digitalValue.draw();
            digitalPin.draw();
        }

        popStyle();
    }

    public int getDigitalReadVal() {
        return digitalInputVal;
    }

    public void screenResized(int _x, int _y, int _w, int _h) {
        dotX = _x;
        dotY = _y;
        dotWidth = _w;
        dotHeight = _h;
        dotCorner = (sqrt(2)*dotWidth/2)/2;

        digitalPin.x = dotX;
        digitalPin.y = dotY - PApplet.parseInt(dotWidth/2.0f);

        digitalValue.x = dotX;
        digitalValue.y = dotY;
    }
};
////////////////////////////////////////////////////
//                                                //
//    W_focus.pde (ie "Focus Widget")             //
//    Enums can be found in FocusEnums.pde        //
//                                                //
//                                                //
//    Created by: Richard Waltman, March 2021     //
//                                                //
////////////////////////////////////////////////////














class W_EEGMapping extends Widget {

    //to see all core variables/methods of the Widget class, refer to Widget.pde
    //put your custom variables here...
    //private ControlP5 focus_cp5;
    //private Button widgetTemplateButton;
    private ChannelSelect focusChanSelect;
    private boolean prevChanSelectIsVisible = false;
    private AuditoryNeurofeedback auditoryNeurofeedback;


    private Grid dataGrid;
    private final int NUM_TABLE_ROWS = 6;
    private final int NUM_TABLE_COLUMNS = 2;
    //private final int TABLE_WIDTH = 142;
    private int tableHeight = 0;
    private int cellHeight = 10;
    private DecimalFormat df = new DecimalFormat("#.0000");

    private final int PAD_FIVE = 5;
    private final int PAD_TWO = 2;
    private final int METRIC_DROPDOWN_W = 100;
    private final int CLASSIFIER_DROPDOWN_W = 80;

    private EEGMappingBar focusBar;
    private float focusBarHardYAxisLimit = 1.05f; //Provide slight "breathing room" to avoid GPlot error when metric value == 1.0
    FocusXLim xLimit = FocusXLim.TEN;
    FocusMetric focusMetric = FocusMetric.RELAXATION;
    FocusClassifier focusClassifier = FocusClassifier.REGRESSION;
    FocusThreshold focusThreshold = FocusThreshold.EIGHT_TENTHS;
    private FocusColors focusColors = FocusColors.GREEN;

    int[] exgChannels;
    int channelCount;
    double[][] dataArray;

    MLModel mlModel;
    private double metricPrediction = 0d;
    private boolean predictionExceedsThreshold = false;

    private float xc, yc, wc, hc; // status circle center xy, width and height
    private int graphX, graphY, graphW, graphH;
    private int graphPadding = 30;
    private int cBack, cDark, cMark, cFocus, cWave, cPanel;

    List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();

    W_EEGMapping(PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

         //Add channel select dropdown to this widget
        focusChanSelect = new ChannelSelect(pApplet, this, x, y, w, navH, "FocusChannelSelect");
        focusChanSelect.activateAllButtons();
        cp5ElementsToCheck.addAll(focusChanSelect.getCp5ElementsForOverlapCheck());

        auditoryNeurofeedback = new AuditoryNeurofeedback(x + PAD_FIVE, y + PAD_FIVE, w/2 - PAD_FIVE*2, navBarHeight/2);
        cp5ElementsToCheck.add((controlP5.Controller)auditoryNeurofeedback.startStopButton);
        cp5ElementsToCheck.add((controlP5.Controller)auditoryNeurofeedback.modeButton);

        exgChannels = currentBoard.getEXGChannels();
        channelCount = currentBoard.getNumEXGChannels();
        dataArray = new double[channelCount][];

        // initialize graphics parameters
        onColorChange();
        
        //This is the protocol for setting up dropdowns.
        dropdownWidth = 60; //Override the default dropdown width for this widget
        addDropdown("focusMetricDropdown", "Metric", focusMetric.getEnumStringsAsList(), focusMetric.getIndex());
        addDropdown("focusClassifierDropdown", "Classifier", focusClassifier.getEnumStringsAsList(), focusClassifier.getIndex());
        addDropdown("focusThresholdDropdown", "Threshold", focusThreshold.getEnumStringsAsList(), focusThreshold.getIndex());
        addDropdown("focusWindowDropdown", "Window", xLimit.getEnumStringsAsList(), xLimit.getIndex());
        

        //Create data table
        dataGrid = new Grid(NUM_TABLE_ROWS, NUM_TABLE_COLUMNS, cellHeight);
        dataGrid.setTableFontAndSize(p6, 10);
        dataGrid.setDrawTableBorder(true);
        dataGrid.setString("Metric Value", 0, 0);
        dataGrid.setString("Delta (1.5-4Hz)", 1, 0);
        dataGrid.setString("Theta (4-8Hz)", 2, 0);
        dataGrid.setString("Alpha (7.5-13Hz)", 3, 0);
        dataGrid.setString("Beta (13-30Hz)", 4, 0);
        dataGrid.setString("Gamma (30-45Hz)", 5, 0);

        //Instantiate local cp5 for this box. This allows extra control of drawing cp5 elements specifically inside this class.
        //focus_cp5 = new ControlP5(ourApplet);
        //focus_cp5.setGraphics(ourApplet, 0,0);
        //focus_cp5.setAutoDraw(false);

        //create our focus graph
        updateGraphDims();
        focusBar = new EEGMappingBar(_parent, xLimit.getValue(), focusBarHardYAxisLimit, graphX, graphY, graphW, graphH);

        initBrainFlowMetric();
    }

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        //Update channel checkboxes and active channels
        focusChanSelect.update(x, y, w);

        //Flex the Gplot graph when channel select dropdown is open/closed
        if (focusChanSelect.isVisible() != prevChanSelectIsVisible) {
            channelSelectFlexWidgetUI();
            prevChanSelectIsVisible = focusChanSelect.isVisible();
        }

        if (currentBoard.isStreaming()) {
            metricPrediction = updateFocusState();
            dataGrid.setString(df.format(metricPrediction), 0, 1);
            focusBar.update(metricPrediction);
            predictionExceedsThreshold = metricPrediction > focusThreshold.getValue();
        }

        lockElementsOnOverlapCheck(cp5ElementsToCheck);
    }

    public void draw() {
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)
        //remember to refer to x,y,w,h which are the positioning variables of the Widget class

        //Draw data table
        dataGrid.draw();

        drawStatusCircle();

        if (false) {
            //Draw some guides to help develop this widget faster
            pushStyle();
            stroke(OPENBCI_DARKBLUE);
            //Main guides
            line(x, y+(h/2), x+w, y+(h/2));
            line(x+(w/2), y, x+(w/2), y+(h/2));
            //Top left container center
            line(x+(w/4), y, x+(w/4), y+(h/2));
            line(x, y+(h/4), x+(w/2), y+(h/4));
            popStyle();
        }

        //This draws all cp5 objects in the local instance
        //focus_cp5.draw();
        auditoryNeurofeedback.draw();
        
        //Draw the graph
        focusBar.draw();

        focusChanSelect.draw();
    }

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        //Very important to allow users to interact with objects after app resize        
        //focus_cp5.setGraphics(ourApplet, 0, 0);

        resizeTable();

        //We need to set the position of our Cp5 object after the screen is resized
        //widgetTemplateButton.setPosition(x + w/2 - widgetTemplateButton.getWidth()/2, y + h/2 - widgetTemplateButton.getHeight()/2);

        updateStatusCircle();
        updateAuditoryNeurofeedbackPosition();

        updateGraphDims();
        focusBar.screenResized(graphX, graphY, graphW, graphH);
        focusChanSelect.screenResized(pApplet);

        //Custom resize these dropdowns due to longer text strings as options
        cp5_widget.get(ScrollableList.class, "focusMetricDropdown").setWidth(METRIC_DROPDOWN_W);
        cp5_widget.get(ScrollableList.class, "focusMetricDropdown").setPosition(
            x0 + w0 - (dropdownWidth*2) - METRIC_DROPDOWN_W - CLASSIFIER_DROPDOWN_W - (PAD_TWO*4), 
            navH + y0 + PAD_TWO
            );
        cp5_widget.get(ScrollableList.class, "focusClassifierDropdown").setWidth(CLASSIFIER_DROPDOWN_W);
        cp5_widget.get(ScrollableList.class, "focusClassifierDropdown").setPosition(
            x0 + w0 - (dropdownWidth*2) - CLASSIFIER_DROPDOWN_W - (PAD_TWO*3), 
            navH + y0 + PAD_TWO
            );
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
        focusChanSelect.mousePressed(this.dropdownIsActive); //Calls channel select mousePressed and checks if clicked
    }

    private void resizeTable() {
        int extraPadding = focusChanSelect.isVisible() ? navHeight : 0;
        float upperLeftContainerW = w/2;
        float upperLeftContainerH = h/2;
        //float min = min(upperLeftContainerW, upperLeftContainerH);
        int tx = x + PApplet.parseInt(upperLeftContainerW);
        int ty = y + PAD_FIVE + extraPadding;
        int tw = PApplet.parseInt(upperLeftContainerW) - PAD_FIVE*2;
        //tableHeight = tw;
        dataGrid.setDim(tx, ty, tw);
        dataGrid.setTableHeight(PApplet.parseInt(upperLeftContainerH - PAD_FIVE*2));
        dataGrid.dynamicallySetTextVerticalPadding(0, 0);
        dataGrid.setHorizontalCenterTextInCells(true);
    }

    private void updateAuditoryNeurofeedbackPosition() {
        int extraPadding = focusChanSelect.isVisible() ? navHeight : 0;
        int subContainerMiddleX = x + w/4;
        auditoryNeurofeedback.screenResized(subContainerMiddleX, (int)(y + h/2 - navHeight + extraPadding), w/2 - PAD_FIVE*2, navBarHeight/2);
    }

    private void updateStatusCircle() {
        float upperLeftContainerW = w/2;
        float upperLeftContainerH = h/2;
        float min = min(upperLeftContainerW, upperLeftContainerH);
        xc = x + w/4;
        yc = y + h/4 - navHeight;
        wc = min * (3f/5);
        hc = wc;
    }

    private void updateGraphDims() {
        graphW = PApplet.parseInt(w - PAD_FIVE*4);
        graphH = PApplet.parseInt(h/2 - graphPadding - PAD_FIVE*2);
        graphX = x + PAD_FIVE*2;
        graphY = PApplet.parseInt(y + h/2);
    }

    //Core method to fetch and process data
    //Returns a metric value from 0. to 1. When there is an error, returns -1.
    private double updateFocusState() {
        try {
            int windowSize = currentBoard.getSampleRate() * xLimit.getValue();
            // getData in GUI returns data in shape ndatapoints x nchannels, in BrainFlow its transposed
            List<double[]> currentData = currentBoard.getData(windowSize);

            if (currentData.size() != windowSize || focusChanSelect.activeChan.size() <= 0) {
                return -1.0f;
            }

            for (int i = 0; i < channelCount; i++) {
                dataArray[i] = new double[windowSize];
                for (int j = 0; j < currentData.size(); j++) {
                    dataArray[i][j] = currentData.get(j)[exgChannels[i]];
                }
            }

            int[] channelsInDataArray = ArrayUtils.toPrimitive(
                    focusChanSelect.activeChan.toArray(
                        new Integer[focusChanSelect.activeChan.size()]
                    ));

            //Full Source Code for this method: https://github.com/brainflow-dev/brainflow/blob/c5f0ad86683e6eab556e30965befb7c93e389a3b/src/data_handler/data_handler.cpp#L1115
            Pair<double[], double[]> bands = DataFilter.get_avg_band_powers (dataArray, channelsInDataArray, currentBoard.getSampleRate(), true);
            double[] featureVector = bands.getLeft ();

            //Left array is Averages, right array is Standard Deviations. Update values using Averages.
            updateBandPowerTableValues(bands.getLeft());

            //Keep this here
            double prediction = mlModel.predict(featureVector)[0];
            //println("Concentration: " + prediction);

            //Send band power and prediction data to AuditoryNeurofeedback class
            auditoryNeurofeedback.update(bands.getLeft(), (float)prediction);
            
            return prediction;

        } catch (BrainFlowError e) {
            e.printStackTrace();
            println("Error updating focus state!");
            return -1d;
        }
    }

    private void updateBandPowerTableValues(double[] bandPowers) {
        for (int i = 0; i < bandPowers.length; i++) {
            dataGrid.setString(df.format(bandPowers[i]), 1 + i, 1);
        }
    }

    private void drawStatusCircle() {
        int fillColor;
        int strokeColor;
        StringBuilder sb = new StringBuilder("");
        if (predictionExceedsThreshold) {
            fillColor = cFocus;
            strokeColor = cFocus;
        } else {
            fillColor = cDark;
            strokeColor = cDark;
            sb.append("Not ");
        }
        sb.append(focusMetric.getIdealStateString());
        //Draw status graphic
        pushStyle();
        noStroke();
        fill(fillColor);
        stroke(strokeColor);
        ellipseMode(CENTER);
        ellipse(xc, yc, wc, hc);
        noStroke();
        textAlign(CENTER);
        text(sb.toString(), xc, yc + hc/2 + 16);
        popStyle();
    }

    private void initBrainFlowMetric() {
        BrainFlowModelParams modelParams = new BrainFlowModelParams(
                focusMetric.getMetric().get_code(),
                focusClassifier.getClassifier().get_code()
                );
        mlModel = new MLModel (modelParams);
        try {
            mlModel.prepare();
        } catch (BrainFlowError e) {
            e.printStackTrace();
        }
    }

    //Called on haltSystem() when GUI exits or session stops
    public void endSession() {
        try {
            mlModel.release();
        } catch (BrainFlowError e) {
            e.printStackTrace();
        }
    }

    private void onColorChange() {
        switch(focusColors) {
            case GREEN:
                cBack = 0xFFFFFFFF;   //white
                cDark = 0xFF3068A6;   //medium/dark blue
                cMark = 0xFF4D91D9;    //lighter blue
                cFocus = 0xFFB8DC69;   //theme green
                cWave = 0xFFFFDD3A;    //yellow
                cPanel = 0xFFF5F5F5;   //little grey
                break;
            case ORANGE:
                cBack = 0xFFFFFFFF;   //white
                cDark = 0xFF377BC4;   //medium/dark blue
                cMark = 0xFF5E9EE2;    //lighter blue
                cFocus = 0xFFFCCE51;   //orange
                cWave = 0xFFFFDD3A;    //yellow
                cPanel = 0xFFF5F5F5;   //little grey
                break;
            case CYAN:
                cBack = 0xFFFFFFFF;   //white
                cDark = 0xFF377BC4;   //medium/dark blue
                cMark = 0xFF5E9EE2;    //lighter blue
                cFocus = 0xFF91F4FC;   //cyan
                cWave = 0xFFFFDD3A;    //yellow
                cPanel = 0xFFF5F5F5;   //little grey
                break;
        }
    }

    public void channelSelectFlexWidgetUI() {
        focusBar.setPlotPosAndOuterDim(focusChanSelect.isVisible());
        int factor = focusChanSelect.isVisible() ? 1 : -1;
        yc += navHeight * factor;
        resizeTable();
        updateAuditoryNeurofeedbackPosition();
    }

    public void setFocusHorizScale(int n) {
        xLimit = xLimit.values()[n];
        focusBar.adjustTimeAxis(xLimit.getValue());
    }

    public void setMetric(int n) {
        focusMetric = focusMetric.values()[n];
        endSession();
        initBrainFlowMetric();
    }

    public void setClassifier(int n) {
        focusClassifier = focusClassifier.values()[n];
        endSession();
        initBrainFlowMetric();
    }

    public void setThreshold(int n) {
        focusThreshold = focusThreshold.values()[n];
    }

    public int getMetricExceedsThreshold() {
        return predictionExceedsThreshold ? 1 : 0;
    }

    public void killAuditoryFeedback() {
        auditoryNeurofeedback.killAudio();
    }
}; //end of class

//The following global functions are used by the Focus widget dropdowns. This method is the least amount of code.
public void eegMappingWindowDropdown(int n) {
    w_eegMapping.setFocusHorizScale(n);
}

public void eegMappingMetricDropdown(int n) {
    w_eegMapping.setMetric(n);
}

public void eegMappingClassifierDropdown(int n) {
    w_eegMapping.setClassifier(n);
}

public void eegMappingThresholdDropdown(int n) {
    w_eegMapping.setThreshold(n);
}

//This class contains the time series plot for the focus metric over time
class EEGMappingBar {
    int x, y, w, h;
    int focusBarPadding = 30;
    int xOffset;
    final int nPoints = 30 * 1000;

    GPlot plot; //the actual grafica-based GPlot that will be rendering the Time Series trace
    LinkedList<Float> fifoList;
    LinkedList<Float> fifoTimeList;

    int numSeconds;
    int channelColor; //color of plot trace

    EEGMappingBar(PApplet _parent, int xLimit, float yLimit, int _x, int _y, int _w, int _h) { //channel number, x/y location, height, width
        x = _x;
        y = _y;
        w = _w;
        h = _h;
        if (eegDataSource == DATASOURCE_CYTON) {
            xOffset = 22;
        } else {
            xOffset = 0;
        }
        numSeconds = xLimit;

        plot = new GPlot(_parent);
        plot.setPos(x + 36 + 4 + xOffset, y); //match Accelerometer plot position with Time Series
        plot.setDim(w - 36 - 4 - xOffset, h);
        plot.setMar(0f, 0f, 0f, 0f);
        plot.setLineColor((int)channelColors[(NUM_ACCEL_DIMS)%8]);
        plot.setXLim(-numSeconds,0); //set the horizontal scale
        plot.setYLim(0, yLimit); //change this to adjust vertical scale
        //plot.setPointSize(2);
        plot.setPointColor(0);
        plot.getXAxis().setAxisLabelText("Time (s)");
        plot.getYAxis().setAxisLabelText("Metric Value");
        plot.setAllFontProperties("Arial", 0, 14);
        plot.getXAxis().getAxisLabel().setOffset(PApplet.parseFloat(22));
        plot.getYAxis().getAxisLabel().setOffset(PApplet.parseFloat(focusBarPadding));
        plot.getXAxis().setFontColor(OPENBCI_DARKBLUE);
        plot.getXAxis().setLineColor(OPENBCI_DARKBLUE);
        plot.getXAxis().getAxisLabel().setFontColor(OPENBCI_DARKBLUE);
        plot.getYAxis().setFontColor(OPENBCI_DARKBLUE);
        plot.getYAxis().setLineColor(OPENBCI_DARKBLUE);
        plot.getYAxis().getAxisLabel().setFontColor(OPENBCI_DARKBLUE);

        adjustTimeAxis(numSeconds);

        initArrays();

        //set the plot points for X, Y, and Z axes
        plot.addLayer("layer 1", new GPointsArray(30));
        plot.getLayer("layer 1").setLineColor(ACCEL_X_COLOR);
    }

    private void initArrays() {
        fifoList = new LinkedList<Float>();
        fifoTimeList = new LinkedList<Float>();
        for (int i = 0; i < nPoints; i++) {
            fifoList.add(0f);
            fifoTimeList.add(0f);
        }
    }

    public void update(double val) {
        updateGPlotPoints(val);
    }

    public void draw() {
        plot.beginDraw();
        plot.drawBox(); //we won't draw this eventually ...
        plot.drawGridLines(GPlot.BOTH);
        plot.drawLines(); //Draw a Line graph!
        //plot.drawPoints(); //Used to draw Points instead of Lines
        plot.drawYAxis();
        plot.drawXAxis();
        plot.getXAxis().draw();
        plot.endDraw();
    }

    public void adjustTimeAxis(int _newTimeSize) {
        numSeconds = _newTimeSize;
        plot.setXLim(-_newTimeSize,0);
        initArrays();
        //Set the number of axis divisions...
        if (_newTimeSize > 1) {
            plot.getXAxis().setNTicks(_newTimeSize);
        }else{
            plot.getXAxis().setNTicks(10);
        }
    }

    //Used to update the Points within the graph
    private void updateGPlotPoints(double val) {
        float timerVal = (float)millis() / 1000.0f;
        fifoTimeList.removeFirst();
        fifoTimeList.addLast(timerVal);
        fifoList.removeFirst();
        fifoList.addLast((float)val);

        int stopId = 0;
        for (stopId = nPoints - 1; stopId > 0; stopId--) {
            if (timerVal - fifoTimeList.get(stopId) > numSeconds) {
                break;
            }
        }
        int size = nPoints - 1 - stopId;
        GPointsArray focusPoints = new GPointsArray(size);
        for (int i = 0; i < size; i++) {
            focusPoints.set(i, fifoTimeList.get(i + stopId) - timerVal, fifoList.get(i + stopId), "");
        }
        plot.setPoints(focusPoints, "layer 1");
    }

    public void screenResized(int _x, int _y, int _w, int _h) {
        x = _x;
        y = _y;
        w = _w;
        h = _h;
        //reposition & resize the plot
        plot.setPos(x + 36 + 4 + xOffset, y);
        plot.setDim(w - 36 - 4 - xOffset, h);

    }

    public void setPlotPosAndOuterDim(boolean chanSelectIsVisible) {
        int _y = chanSelectIsVisible ? y + 22 : y;
        int _h = chanSelectIsVisible ? h - 22 : h;
        //reposition & resize the plot
        plot.setPos(x + 36 + 4 + xOffset, _y);
        plot.setDim(w - 36 - 4 - xOffset, _h);
    }

}; //end of class
/////////////////////////////////////////////////////////////////////////////////
//
//  Emg_Widget is used to visiualze EMG data by channel, and to trip events
//
//  Created: Colin Fausnaught, December 2016 (with a lot of reworked code from Tao)
//  Modified: Richard Waltman, February 2023
//
//  Custom widget to visiualze EMG data. Features dragable thresholds, serial
//  out communication, channel configuration, digital and analog events.
//
//  KNOWN ISSUES: Cannot resize with window dragging events
//
//  TODO: Add dynamic threshold functionality
////////////////////////////////////////////////////////////////////////////////

class W_emg extends Widget {
    PApplet parent;

    private ControlP5 emgCp5;
    private Button emgSettingsButton;
    private final int EMG_SETTINGS_BUTTON_WIDTH = 125;
    private List<controlP5.Controller> cp5ElementsToCheck;

    public ChannelSelect emgChannelSelect;

    W_emg (PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)
        parent = _parent;

        cp5ElementsToCheck = new ArrayList<controlP5.Controller>();

        //Add channel select dropdown to this widget
        emgChannelSelect = new ChannelSelect(pApplet, this, x, y, w, navH, "EMG_Channels");
        emgChannelSelect.activateAllButtons();
        cp5ElementsToCheck.addAll(emgChannelSelect.getCp5ElementsForOverlapCheck());

        emgCp5 = new ControlP5(ourApplet);
        emgCp5.setGraphics(ourApplet, 0,0);
        emgCp5.setAutoDraw(false);

        createEmgSettingsButton();
        cp5ElementsToCheck.add((controlP5.Controller) emgSettingsButton);
    }

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
        lockElementsOnOverlapCheck(cp5ElementsToCheck);

        //Update channel checkboxes and active channels
        emgChannelSelect.update(x, y, w);
        
        /*
        //Flex the Gplot graph when channel select dropdown is open/closed
        if (bpChanSelect.isVisible() != prevChanSelectIsVisible) {
            flexGPlotSizeAndPosition();
            prevChanSelectIsVisible = bpChanSelect.isVisible();
        }
        */
    }

    public void draw() {
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        drawEmgVisualizations();

        emgCp5.draw();

        //Draw channel select dropdown
        emgChannelSelect.draw();
    }

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)
        emgCp5.setGraphics(ourApplet, 0, 0);
        emgSettingsButton.setPosition(x0 + w - EMG_SETTINGS_BUTTON_WIDTH - 2, y0 + navH + 1);
        emgChannelSelect.screenResized(pApplet);
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
        //Calls channel select mousePressed and checks if clicked
        emgChannelSelect.mousePressed(this.dropdownIsActive);
    }

    private void drawEmgVisualizations() {
        pushStyle();

        float rx = x, ry = y, rw = w, rh = h;
        //Flex the EMG graph when channel select dropdown is open/closed
        ry = emgChannelSelect.isVisible() ? y + emgChannelSelect.getHeight() : y;
        rh = emgChannelSelect.isVisible() ? h - emgChannelSelect.getHeight() : h;
        float scaleFactor = 1.0f;
        float scaleFactorJaw = 1.5f;
        int rowCount = 4;
        int columnCount = ceil(emgChannelSelect.activeChan.size() / (rowCount * 1f));
        float rowOffset = rh / rowCount;
        float colOffset = rw / columnCount;
        float currentX, currentY;
        
        EmgSettingsValues emgSettingsValues = dataProcessing.emgSettings.values;

        int channel = 0;
        for (int i = 0; i < rowCount; i++) {
            for (int j = 0; j < columnCount; j++) {

                int index = i * columnCount + j;

                if (index > emgChannelSelect.activeChan.size() - 1) {
                    continue;
                }
                
                channel = emgChannelSelect.activeChan.get(index);

                int colorIndex = channel % 8;

                pushMatrix();

                currentX = rx + j * colOffset;
                currentY = ry + i * rowOffset; //never name variables on an empty stomach
                translate(currentX, currentY);

                //realtime
                fill(channelColors[colorIndex], 200);
                noStroke();
                circle(2*colOffset/8, rowOffset / 2, scaleFactor * emgSettingsValues.getAverageuV(channel));

                //circle for outer threshold
                noFill();
                strokeWeight(1);
                stroke(OPENBCI_DARKBLUE, 150);
                circle(2*colOffset/8, rowOffset / 2, scaleFactor * emgSettingsValues.getUpperThreshold(channel));

                //circle for inner threshold
                stroke(OPENBCI_DARKBLUE, 150);
                circle(2*colOffset/8, rowOffset / 2, scaleFactor * emgSettingsValues.getLowerThreshold(channel));

                int _x = PApplet.parseInt(5*colOffset/8);
                int _y = PApplet.parseInt(2 * rowOffset / 8);
                int _w = PApplet.parseInt(5*colOffset/32);
                int _h = PApplet.parseInt(4*rowOffset/8);

                //draw normalized bar graph of uV w/ matching channel color
                noStroke();
                fill(channelColors[colorIndex], 200);
                rect(_x, 3*_y + 1, _w, map(emgSettingsValues.getOutputNormalized(channel), 0, 1, 0, (-1) * PApplet.parseInt((4*rowOffset/8))));

                //draw background bar container for mapped uV value indication
                strokeWeight(1);
                stroke(OPENBCI_DARKBLUE, 150);
                noFill();
                rect(_x, _y, _w, _h);

                //draw channel number at upper left corner of row/column cell
                pushStyle();
                stroke(OPENBCI_DARKBLUE);
                fill(OPENBCI_DARKBLUE);
                textFont(h4, 14);
                text((channel + 1), 10, 20);
                popStyle();

                popMatrix();
            }
        }

        popStyle();
    }

    private void createEmgSettingsButton() {
        emgSettingsButton = createButton(emgCp5, "emgSettingsButton", "EMG Settings", 
                (int) (x0 + w - EMG_SETTINGS_BUTTON_WIDTH - 1), (int) (y0 + navH + 1), 
                EMG_SETTINGS_BUTTON_WIDTH, navH - 3, p5, 12, colorNotPressed, OPENBCI_DARKBLUE);
        emgSettingsButton.setBorderColor(OBJECT_BORDER_GREY);
        emgSettingsButton.onRelease(new CallbackListener() {
            public synchronized void controlEvent(CallbackEvent theEvent) {
                if (!emgSettingsPopupIsOpen) {
                    EmgSettingsUI emgSettingsUI = new EmgSettingsUI();
                }
            }
        });
        emgSettingsButton.setDescription("Click to open the EMG Settings UI to adjust how this metric is calculated.");
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                     //
//  w_EMGjoystick was first built in Koblenz Germany (Feb 11, 2023)                                    //
//                                                                                                     //
//  Created: Conor Russomanno, Richard Waltman, Philip Pitts, Blake Larkin, & Christian Bayerlain      //
//                                                                                                     //
//  Custom widget to map EMG signals into a 2D X/Y axis to represent a virtual joystick                //
//                                                                                                     //
//                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////

class W_EMGJoystick extends Widget {

    private ControlP5 emgCp5;
    private Button emgSettingsButton;
    private List<controlP5.Controller> cp5ElementsToCheck;

    EmgSettingsValues emgSettingsValues;

    private final int NUM_EMG_CHANNELS = 4;

    private float joystickRawX;
    private float joystickRawY;
    private float previousJoystickRawX;
    private float previousJoystickRawY;
    private boolean inputIsDisabled;

    //Circular joystick X/Y graph. Made similar to the one found in Accelerometer widget.
    private float polarWindowX;
    private float polarWindowY;
    private int polarWindowDiameter;
    private int polarWindowHalfDiameter;
    private int graphStroke = color(210);
    private int graphBG = color(245);
    private int textColor = OPENBCI_DARKBLUE;
    private int strokeColor = color(138, 146, 153);
    private final int INDICATOR_DIAMETER = 15;
    private final int BAR_WIDTH = 10;
    private final int BAR_HEIGHT = 30;
    private final int BAR_CIRCLE_SPACER = 20; //Space between bar graph and circle graph

    private float topPolarX, topPolarY;         //12:00
    private float rightPolarX, rightPolarY;     //3:00
    private float bottomPolarX, bottomPolarY;   //6:00
    private float leftPolarX, leftPolarY;       //9:00
    private final int EMG_PLOT_OFFSET = 40;     //Used to arrange EMG displays outside of X/Y graph

    private String[] plotChannelLabels = new String[NUM_EMG_CHANNELS];

    public EmgJoystickSmoothing joystickSmoothing = EmgJoystickSmoothing.POINT_9;

    private int DROPDOWN_HEIGHT = navH - 4;
    private int DROPDOWN_WIDTH = 80;
    private int DROPDOWN_SPACER = 10;
    private int DROPDOWN_LABEL_WIDTH = 24;

    public EmgJoystickInput[] emgJoystickInputs = new EmgJoystickInput[NUM_EMG_CHANNELS];

    private ScrollableList xNegativeInputDropdown;
    private ScrollableList xPositiveInputDropdown;
    private ScrollableList yPositiveInputDropdown;
    private ScrollableList yNegativeInputDropdown;

    private TextBox xNegativeInputDropdownLabel;
    private TextBox xPositiveInputDropdownLabel;
    private TextBox yPositiveInputDropdownLabel;
    private TextBox yNegativeInputDropdownLabel;

    private PImage xNegativeInputLabelImage = loadImage("LEFT_100x100.png");
    private PImage xPositiveInputLabelImage = loadImage("RIGHT_100x100.png");
    private PImage yPositiveInputLabelImage = loadImage("UP_100x100.png");
    private PImage yNegativeInputLabelImage = loadImage("DOWN_100x100.png");

    W_EMGJoystick(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        emgCp5 = new ControlP5(ourApplet);
        emgCp5.setGraphics(ourApplet, 0,0);
        emgCp5.setAutoDraw(false);

        createEmgSettingsButton();
        
        cp5ElementsToCheck = new ArrayList<controlP5.Controller>();
        cp5ElementsToCheck.add((controlP5.Controller) emgSettingsButton);

        emgSettingsValues = dataProcessing.emgSettings.values;

        emgJoystickInputs[0] = EmgJoystickInput.CHANNEL_1;
        emgJoystickInputs[1] = EmgJoystickInput.CHANNEL_2;
        emgJoystickInputs[2] = EmgJoystickInput.CHANNEL_3;
        emgJoystickInputs[3] = EmgJoystickInput.CHANNEL_4;

        for (int i = 0; i < NUM_EMG_CHANNELS; i++) {
            plotChannelLabels[i] = Integer.toString(emgJoystickInputs[i].getIndex() + 1);
        }

        addDropdown("emgJoystickSmoothingDropdown", "Smoothing", joystickSmoothing.getEnumStringsAsList(), joystickSmoothing.getIndex());

        createInputDropdowns();
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
    
        updateJoystickInput();
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        drawJoystickXYGraph();

        drawEmgVisualization(emgJoystickInputs[0].getIndex(), leftPolarX, leftPolarY);
        drawEmgVisualization(emgJoystickInputs[1].getIndex(), rightPolarX, rightPolarY);
        drawEmgVisualization(emgJoystickInputs[2].getIndex(), topPolarX, topPolarY);
        drawEmgVisualization(emgJoystickInputs[3].getIndex(), bottomPolarX, bottomPolarY);

        drawInputDropdownLabels();

        emgCp5.draw();
    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        emgCp5.setGraphics(ourApplet, 0, 0);
        emgSettingsButton.setPosition(x0 + 1, y0 + navH + 1);

        updateJoystickGraphSizeAndPosition();
        updateInputDropdownPositions();
    }

    private void updateJoystickGraphSizeAndPosition() {
        //Make a unit circle constrained by the max height or width of the widget
        //Shrink the X/Y plot so that the EMG displays fit on the outside of the circle
        int horizontalPadding = 80;
        int verticalPadding = 48;
        if (h + verticalPadding*2 > w) {
            polarWindowDiameter = w - horizontalPadding*2;
        } else {
            polarWindowDiameter = h - verticalPadding*2;
        }

        polarWindowHalfDiameter = polarWindowDiameter / 2;
        polarWindowX = x + w / 2;
        polarWindowY = y + h / 2;

        topPolarX = polarWindowX;
        topPolarY = polarWindowY - polarWindowHalfDiameter - (EMG_PLOT_OFFSET / 2);

        rightPolarX = polarWindowX + polarWindowHalfDiameter + (EMG_PLOT_OFFSET);
        rightPolarY = polarWindowY;

        bottomPolarX = polarWindowX;
        bottomPolarY =  polarWindowY + polarWindowHalfDiameter + (EMG_PLOT_OFFSET / 2);

        leftPolarX = polarWindowX - polarWindowHalfDiameter - (EMG_PLOT_OFFSET);
        leftPolarY = polarWindowY;
    }

    private void drawJoystickXYGraph() {
        pushStyle();

        /*
        //X and Y axis labels
        fill(50);
        textFont(p4, 14);
        textAlign(CENTER,CENTER);
        text("x", (polarWindowX + polarWindowHalfDiameter) + 8, polarWindowY - 5);
        text("y", polarWindowX, (polarWindowY - polarWindowHalfDiameter) - 14);
        */

        //Background for graph
        fill(graphBG);
        stroke(graphStroke);
        circle(polarWindowX, polarWindowY, polarWindowDiameter);

        //X and Y axis lines
        stroke(180);
        line(polarWindowX - polarWindowHalfDiameter, polarWindowY, polarWindowX + polarWindowHalfDiameter, polarWindowY);
        line(polarWindowX, polarWindowY - polarWindowHalfDiameter, polarWindowX, polarWindowY + polarWindowHalfDiameter);

        //Keep the indicator circle inside the graph by accounting for the size of the indicator
        float min = -polarWindowHalfDiameter + (INDICATOR_DIAMETER * 2);
        float max = polarWindowHalfDiameter - (INDICATOR_DIAMETER  * 2);
        float xMapped = polarWindowX + map(joystickRawX, -1, 1, min, max);
        float yMapped = polarWindowY + map(joystickRawY, 1, -1, min, max); //Inverse drawn position of Y axis

        //Draw middle of graph for reference
        /*
        fill(255, 0, 0);
        stroke(graphStroke);
        circle(polarWindowX, polarWindowY, 15);
        */

        //Draw indicator
        noFill();
        stroke(color(31,69,110));
        strokeWeight(2);
        circle(xMapped, yMapped, INDICATOR_DIAMETER);
        line(xMapped-10, yMapped, xMapped+10, yMapped);
        line(xMapped, yMapped-10, xMapped, yMapped+10);

        popStyle();
    }
    
    //This is the core method that updates the joystick input
    private void updateJoystickInput() {
        previousJoystickRawX = joystickRawX;
        previousJoystickRawY = joystickRawY;

        if (inputIsDisabled) {
            joystickRawX = 0;
            joystickRawY = 0;
            return;
        }

        float xNegativeValue = emgSettingsValues.outputNormalized[emgJoystickInputs[0].getIndex()];
        float xPositiveValue = emgSettingsValues.outputNormalized[emgJoystickInputs[1].getIndex()];
        float yPositiveValue = emgSettingsValues.outputNormalized[emgJoystickInputs[2].getIndex()];
        float yNegativeValue = emgSettingsValues.outputNormalized[emgJoystickInputs[3].getIndex()];
        
        //Here we subtract the value of the right channel from the left channel to get the X axis
        joystickRawX = xPositiveValue - xNegativeValue;
        //Here we subtract the value of the top channel from the bottom channel to get the Y axis
        joystickRawY = yPositiveValue - yNegativeValue;

        //Map the joystick values to a unit circle
        float[] unitCircleXY = mapToUnitCircle(joystickRawX, joystickRawY);
        joystickRawX = unitCircleXY[0];
        joystickRawY = unitCircleXY[1];
        //Lerp the joystick values to smooth them out
        float amount = 1.0f - joystickSmoothing.getValue();
        joystickRawX = lerp(previousJoystickRawX, joystickRawX, amount);
        joystickRawY = lerp(previousJoystickRawY, joystickRawY, amount);
    }

    public float[] getJoystickXY() {
        return new float[] {joystickRawX, joystickRawY};
    }

    public void setInputIsDisabled(boolean value) {
        inputIsDisabled = value;
    }

    public float[] mapToUnitCircle(float _x, float _y) {
        _x = _x * sqrt(1 - (_y * _y) / 2);
        _y = _y * sqrt(1 - (_x * _x) / 2);
        return new float[] {_x, _y};
    }

    private void drawEmgVisualization(int channel, float currentX, float currentY) {
        float scaleFactor = 1.0f;
        float scaleFactorJaw = 1.5f;
        int index = 0;
        int colorIndex = channel % 8;
        
        int barX = (int)currentX + BAR_CIRCLE_SPACER;
        int barY = (int)currentY + BAR_HEIGHT / 2;
        int circleX = (int)currentX - BAR_CIRCLE_SPACER;
        int circleY = (int)currentY;
        

        pushStyle();

        //Realtime
        fill(channelColors[colorIndex], 200);
        noStroke();
        circle(circleX, circleY, scaleFactor * emgSettingsValues.averageuV[channel]);

        //Circle for outer threshold
        noFill();
        strokeWeight(1);
        stroke(OPENBCI_DARKBLUE);
        circle(circleX, circleY, scaleFactor * emgSettingsValues.upperThreshold[channel]);

        //Circle for inner threshold
        stroke(OPENBCI_DARKBLUE);
        circle(circleX, circleY, scaleFactor * emgSettingsValues.lowerThreshold[channel]);

        //Map value for height of bar graph
        float normalizedBAR_HEIGHTeight = map(emgSettingsValues.outputNormalized[channel], 0, 1, 0, BAR_HEIGHT * -1);

        //Draw normalized bar graph of uV w/ matching channel color
        noStroke();
        fill(channelColors[colorIndex], 200);
        rect(barX, barY, BAR_WIDTH, normalizedBAR_HEIGHTeight);

        //Draw background bar container for mapped uV value indication
        strokeWeight(1);
        stroke(OPENBCI_DARKBLUE);
        noFill();
        rect(barX, barY, BAR_WIDTH, BAR_HEIGHT * -1);

        popStyle();
    }

    private void drawChannelLabels() {
        pushStyle();

        fill(OPENBCI_DARKBLUE);
        textFont(p4, 14);
        textLeading(14);
        textAlign(CENTER,CENTER);
        
        text(plotChannelLabels[0], leftPolarX, leftPolarY - BAR_CIRCLE_SPACER * 2);
        text(plotChannelLabels[1], rightPolarX, rightPolarY - BAR_CIRCLE_SPACER *2);
        text(plotChannelLabels[2], topPolarX + BAR_CIRCLE_SPACER * 4, topPolarY);
        text(plotChannelLabels[3], bottomPolarX + BAR_CIRCLE_SPACER * 4, bottomPolarY);

        popStyle();
    }

    public void setJoystickSmoothing(int n) {
        joystickSmoothing = joystickSmoothing.values()[n];
    }

    private void createEmgSettingsButton() {
        emgSettingsButton = createButton(emgCp5, "emgSettingsButton", "EMG Settings", (int) (x0 + 1),
                (int) (y0 + navH + 1), 125, navH - 3, p5, 12, colorNotPressed, OPENBCI_DARKBLUE);
        emgSettingsButton.setBorderColor(OBJECT_BORDER_GREY);
        emgSettingsButton.onRelease(new CallbackListener() {
            public synchronized void controlEvent(CallbackEvent theEvent) {
                if (!emgSettingsPopupIsOpen) {
                    EmgSettingsUI emgSettingsUI = new EmgSettingsUI();
                }
            }
        });
        emgSettingsButton.setDescription("Click to open the EMG Settings UI to adjust how this metric is calculated.");
    }

    private ScrollableList createEmgJoystickInputDropdown(String name, EmgJoystickInput joystickInput, int inputNumber) {
        ScrollableList list = emgCp5.addScrollableList(name)
            .setOpen(false)
            .setColorBackground(WHITE) // text field bg color
            .setColorValueLabel(OPENBCI_DARKBLUE)       // text color
            .setColorCaptionLabel(OPENBCI_DARKBLUE)
            .setColorForeground(color(125))    // border color when not selected
            .setColorActive(BUTTON_PRESSED)       // border color when selected
            .setOutlineColor(OBJECT_BORDER_GREY)
            .setSize(DROPDOWN_WIDTH, DROPDOWN_HEIGHT * 6)//temporary size
            .setBarHeight(DROPDOWN_HEIGHT) //height of top/primary bar
            .setItemHeight(DROPDOWN_HEIGHT) //height of all item/dropdown bars
            .setVisible(true)
            ;
        // this will store the *actual* enum object inside the dropdown!
        for (EmgJoystickInput input : EmgJoystickInput.values()) {
            if (input.getIndex() >= currentBoard.getNumEXGChannels()) {
                continue;
            }
            list.addItem(input.getString(), input);
        }
        //Style the text in the ScrollableList
        list.getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(joystickInput.getString())
            .setFont(h5)
            .setSize(12)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        list.getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(joystickInput.getString())
            .setFont(p6)
            .setSize(10) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
        list.addCallback(new SLCallbackListener(inputNumber));
        return list;
    }

    private class SLCallbackListener implements CallbackListener {
        private int inputNumber;
    
        SLCallbackListener(int _i)  {
            inputNumber = _i;
        }
        public void controlEvent(CallbackEvent theEvent) {
            //Selecting an item from ScrollableList triggers Broadcast
            if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) { 
                int val = (int)(theEvent.getController()).getValue();
                Map bob = ((ScrollableList)theEvent.getController()).getItem(val);
                emgJoystickInputs[inputNumber] = (EmgJoystickInput)bob.get("value");
                verbosePrint("EmgJoystickInput: " + (theEvent.getController()).getName() + " == " + emgJoystickInputs[inputNumber].getString());

                plotChannelLabels[inputNumber] = Integer.toString(emgJoystickInputs[inputNumber].getIndex() + 1);
            }
        }
    }

    private void createInputDropdowns() {
        //Create the dropdowns in reverse order so that top dropdown draws over bottom dropdown
        yNegativeInputDropdown = createEmgJoystickInputDropdown("yNegativeDropdown", emgJoystickInputs[3], 3);
        yPositiveInputDropdown = createEmgJoystickInputDropdown("yPositiveDropdown", emgJoystickInputs[2], 2);
        xPositiveInputDropdown = createEmgJoystickInputDropdown("xPositiveDropdown", emgJoystickInputs[1], 1);
        xNegativeInputDropdown = createEmgJoystickInputDropdown("xNegativeDropdown", emgJoystickInputs[0], 0);
        //Add the dropdowns to the list of cp5 elements to check for mouseover
        cp5ElementsToCheck.add(xNegativeInputDropdown);
        cp5ElementsToCheck.add(xPositiveInputDropdown);
        cp5ElementsToCheck.add(yPositiveInputDropdown);
        cp5ElementsToCheck.add(yNegativeInputDropdown);
        //Create labels for the dropdowns
        int labelBG = color(255,255,255,0);
        xNegativeInputDropdownLabel = new TextBox("X-", x, y, OPENBCI_DARKBLUE, WHITE, 12, h3, LEFT, TOP);
        xPositiveInputDropdownLabel = new TextBox("X+", x, y, OPENBCI_DARKBLUE, WHITE, 12, h3, LEFT, TOP);
        yPositiveInputDropdownLabel = new TextBox("Y+", x, y, OPENBCI_DARKBLUE, WHITE, 12, h3, LEFT, TOP);
        yNegativeInputDropdownLabel = new TextBox("Y-", x, y, OPENBCI_DARKBLUE, WHITE, 12, h3, LEFT, TOP);
    }

    private void updateInputDropdownPositions(){
        final int Y_AXIS_ARROW_LABEL_WIDTH = DROPDOWN_HEIGHT + DROPDOWN_SPACER;
        xNegativeInputDropdown.setPosition((int) (x + navH + DROPDOWN_LABEL_WIDTH), (int) (y + navH + 1));
        xPositiveInputDropdown.setPosition((int) (x + navH + DROPDOWN_LABEL_WIDTH), (int) (y + navH + DROPDOWN_SPACER + DROPDOWN_HEIGHT));
        yPositiveInputDropdown.setPosition((int) (x + w - navH - DROPDOWN_WIDTH - Y_AXIS_ARROW_LABEL_WIDTH), (int) (y + navH + 1));
        yNegativeInputDropdown.setPosition((int) (x + w - navH - DROPDOWN_WIDTH - Y_AXIS_ARROW_LABEL_WIDTH), (int) (y + navH + DROPDOWN_SPACER + DROPDOWN_HEIGHT));
        xNegativeInputDropdownLabel.setPosition((int) xNegativeInputDropdown.getPosition()[0] - DROPDOWN_LABEL_WIDTH, (int) xNegativeInputDropdown.getPosition()[1]);
        xPositiveInputDropdownLabel.setPosition((int) xPositiveInputDropdown.getPosition()[0] - DROPDOWN_LABEL_WIDTH, (int) xPositiveInputDropdown.getPosition()[1]);
        yPositiveInputDropdownLabel.setPosition((int) yPositiveInputDropdown.getPosition()[0] - DROPDOWN_LABEL_WIDTH, (int) yPositiveInputDropdown.getPosition()[1]);
        yNegativeInputDropdownLabel.setPosition((int) yNegativeInputDropdown.getPosition()[0] - DROPDOWN_LABEL_WIDTH, (int) yNegativeInputDropdown.getPosition()[1]);
    }

    private void drawInputDropdownLabels() {
        xNegativeInputDropdownLabel.draw();
        xPositiveInputDropdownLabel.draw();
        yPositiveInputDropdownLabel.draw();
        yNegativeInputDropdownLabel.draw();

        pushStyle();
        final int X_OFFSET = DROPDOWN_WIDTH + DROPDOWN_SPACER;
        image(xNegativeInputLabelImage, xNegativeInputDropdown.getPosition()[0] + X_OFFSET, xNegativeInputDropdown.getPosition()[1] + 2, DROPDOWN_HEIGHT, DROPDOWN_HEIGHT);
        image(xPositiveInputLabelImage, xPositiveInputDropdown.getPosition()[0] + X_OFFSET, xPositiveInputDropdown.getPosition()[1] + 2, DROPDOWN_HEIGHT, DROPDOWN_HEIGHT);
        image(yPositiveInputLabelImage, yPositiveInputDropdown.getPosition()[0] + X_OFFSET, yPositiveInputDropdown.getPosition()[1] + 2, DROPDOWN_HEIGHT, DROPDOWN_HEIGHT);
        image(yNegativeInputLabelImage, yNegativeInputDropdown.getPosition()[0] + X_OFFSET, yNegativeInputDropdown.getPosition()[1] + 2, DROPDOWN_HEIGHT, DROPDOWN_HEIGHT);
    }

    public void updateJoystickInput(int inputNumber, Integer value) {
        if (value == null) {
            return;
        }
        emgJoystickInputs[inputNumber] = EmgJoystickInput.values()[value];
        String inputName = emgJoystickInputs[inputNumber].getString();
        switch (inputNumber) {
            case 0:
                xNegativeInputDropdown.getCaptionLabel().setText(inputName);
                break;
            case 1:
                xPositiveInputDropdown.getCaptionLabel().setText(inputName);
                break;
            case 2:
                yPositiveInputDropdown.getCaptionLabel().setText(inputName);
                break;
            case 3:
                yNegativeInputDropdown.getCaptionLabel().setText(inputName);
                break;
        }
    }

};

public void emgJoystickSmoothingDropdown(int n) {
    w_emgJoystick.setJoystickSmoothing(n);
}

public enum EmgJoystickSmoothing implements IndexingInterface
{
    OFF (0, "Off", 0f),
    POINT_9 (1, "0.9", .9f),
    POINT_95 (2, "0.95", .95f),
    POINT_98 (3, "0.98", .98f),
    POINT_99 (4, "0.99", .99f),
    POINT_999 (5, "0.999", .999f),
    POINT_9999 (6, "0.9999", .9999f);

    private int index;
    private String name;
    private float value;
    private static EmgJoystickSmoothing[] vals = values();
 
    EmgJoystickSmoothing(int index, String name, float value) {
        this.index = index;
        this.name = name;
        this.value = value;
    }

    public int getIndex() {
        return index;
    }
    
    public String getString() {
        return name;
    }

    public float getValue() {
        return value;
    }

    private static List<String> getEnumStringsAsList() {
        List<String> enumStrings = new ArrayList<String>();
        for (IndexingInterface val : vals) {
            enumStrings.add(val.getString());
        }
        return enumStrings;
    }
}

public enum EmgJoystickInput implements IndexingInterface
{
    CHANNEL_1 (0, "Channel 1", 0),
    CHANNEL_2 (1, "Channel 2", 1),
    CHANNEL_3 (2, "Channel 3", 2),
    CHANNEL_4 (3, "Channel 4", 3),
    CHANNEL_5 (4, "Channel 5", 4),
    CHANNEL_6 (5, "Channel 6", 5),
    CHANNEL_7 (6, "Channel 7", 6),
    CHANNEL_8 (7, "Channel 8", 7),
    CHANNEL_9 (8, "Channel 9", 8),
    CHANNEL_10 (9, "Channel 10", 9),
    CHANNEL_11 (10, "Channel 11", 10),
    CHANNEL_12 (11, "Channel 12", 11),
    CHANNEL_13 (12, "Channel 13", 12),
    CHANNEL_14 (13, "Channel 14", 13),
    CHANNEL_15 (14, "Channel 15", 14),
    CHANNEL_16 (15, "Channel 16", 15);

    private int index;
    private String name;
    private int value;
    private static EmgJoystickInput[] vals = values();
 
    EmgJoystickInput(int index, String name, int value) {
        this.index = index;
        this.name = name;
        this.value = value;
    }

    public int getIndex() {
        return index;
    }
    
    public String getString() {
        return name;
    }

    public int getValue() {
        return value;
    }

    private static List<String> getEnumStringsAsList() {
        List<String> enumStrings = new ArrayList<String>();
        for (IndexingInterface val : vals) {
            enumStrings.add(val.getString());
        }
        return enumStrings;
    }
}

////////////////////////////////////////////////////
//
// This class creates an FFT Plot
// It extends the Widget class
//
// Conor Russomanno, November 2016
//
// Requires the plotting library from grafica ...
// replacing the old gwoptics (which is now no longer supported)
//
///////////////////////////////////////////////////

class W_fft extends Widget {

    public ChannelSelect fftChanSelect;
    boolean prevChanSelectIsVisible = false;

    GPlot fft_plot; //create an fft plot for each active channel
    GPointsArray[] fft_points;  //create an array of points for each channel of data (4, 8, or 16)
    
    int[] lineColor = {
        (int)color(129, 129, 129),
        (int)color(124, 75, 141),
        (int)color(54, 87, 158),
        (int)color(49, 113, 89),
        (int)SIGNAL_CHECK_YELLOW,
        (int)color(253, 94, 52),
        (int)BOLD_RED,
        (int)color(162, 82, 49),
        (int)color(129, 129, 129),
        (int)color(124, 75, 141),
        (int)color(54, 87, 158),
        (int)color(49, 113, 89),
        (int)SIGNAL_CHECK_YELLOW,
        (int)color(253, 94, 52),
        (int)BOLD_RED,
        (int)color(162, 82, 49)
    };

    int[] xLimOptions = {20, 40, 60, 100, 120, 250, 500, 800};
    int[] yLimOptions = {10, 50, 100, 1000};

    int xLim = xLimOptions[2];  //maximum value of x axis ... in this case 20 Hz, 40 Hz, 60 Hz, 120 Hz
    int xMax = xLimOptions[xLimOptions.length-1];   //maximum possible frequency in FFT
    int FFT_indexLim = PApplet.parseInt(1.0f*xMax*(getNfftSafe()/currentBoard.getSampleRate()));   // maxim value of FFT index
    int yLim = yLimOptions[2];  //maximum value of y axis ... 100 uV

    List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();

    W_fft(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        //Add channel select dropdown to this widget
        fftChanSelect = new ChannelSelect(pApplet, this, x, y, w, navH, "BP_Channels");
        fftChanSelect.activateAllButtons();
        cp5ElementsToCheck.addAll(fftChanSelect.getCp5ElementsForOverlapCheck());

        //Default FFT plot settings
        settings.fftMaxFrqSave = 2;
        settings.fftMaxuVSave = 2;
        settings.fftLogLinSave = 0;
        settings.fftSmoothingSave = 3;
        settings.fftFilterSave = 0;

        //This is the protocol for setting up dropdowns.
        //Note that these 3 dropdowns correspond to the 3 global functions below
        //You just need to make sure the "id" (the 1st String) has the same name as the corresponding function
        addDropdown("MaxFreq", "Max Freq", Arrays.asList(settings.fftMaxFrqArray), settings.fftMaxFrqSave);
        addDropdown("VertScale", "Max uV", Arrays.asList(settings.fftVertScaleArray), settings.fftMaxuVSave);
        addDropdown("LogLin", "Log/Lin", Arrays.asList(settings.fftLogLinArray), settings.fftLogLinSave);
        addDropdown("Smoothing", "Smooth", Arrays.asList(settings.fftSmoothingArray), smoothFac_ind); //smoothFac_ind is a global variable at the top of W_HeadPlot.pde
        addDropdown("UnfiltFilt", "Filters?", Arrays.asList(settings.fftFilterArray), settings.fftFilterSave);

        fft_points = new GPointsArray[nchan];
        // println("fft_points.length: " + fft_points.length);
        initializeFFTPlot(_parent);

    }

    public void initializeFFTPlot(PApplet _parent) {
        //setup GPlot for FFT
        fft_plot = new GPlot(_parent, x, y-navHeight, w, h+navHeight); //based on container dimensions
        fft_plot.setAllFontProperties("Arial", 0, 14);
        fft_plot.getXAxis().setAxisLabelText("Frequency (Hz)");
        fft_plot.getYAxis().setAxisLabelText("Amplitude (uV)");
        fft_plot.setMar(60, 70, 40, 30); //{ bot=60, left=70, top=40, right=30 } by default
        fft_plot.setLogScale("y");

        fft_plot.setYLim(0.1f, yLim);
        int _nTicks = PApplet.parseInt(yLim/10 - 1); //number of axis subdivisions
        fft_plot.getYAxis().setNTicks(_nTicks);  //sets the number of axis divisions...
        fft_plot.setXLim(0.1f, xLim);
        fft_plot.getYAxis().setDrawTickLabels(true);
        fft_plot.setPointSize(2);
        fft_plot.setPointColor(0);
        fft_plot.getXAxis().setFontColor(OPENBCI_DARKBLUE);
        fft_plot.getXAxis().setLineColor(OPENBCI_DARKBLUE);
        fft_plot.getXAxis().getAxisLabel().setFontColor(OPENBCI_DARKBLUE);
        fft_plot.getYAxis().setFontColor(OPENBCI_DARKBLUE);
        fft_plot.getYAxis().setLineColor(OPENBCI_DARKBLUE);
        fft_plot.getYAxis().getAxisLabel().setFontColor(OPENBCI_DARKBLUE);

        //setup points of fft point arrays
        for (int i = 0; i < fft_points.length; i++) {
            fft_points[i] = new GPointsArray(FFT_indexLim);
        }

        //fill fft point arrays
        for (int i = 0; i < fft_points.length; i++) { //loop through each channel
            for (int j = 0; j < FFT_indexLim; j++) {
                GPoint temp = new GPoint(j, 0);
                fft_points[i].set(j, temp);
            }
        }

        //map fft point arrays to fft plots
        fft_plot.setPoints(fft_points[0]);
    }

    public void update(){

        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
        float sr = currentBoard.getSampleRate();
        int nfft = getNfftSafe();

        //update the points of the FFT channel arrays for all channels
        for (int i = 0; i < fft_points.length; i++) {
            for (int j = 0; j < FFT_indexLim + 2; j++) {  //loop through frequency domain data, and store into points array
                GPoint powerAtBin = new GPoint((1.0f*sr/nfft)*j, fftBuff[i].getBand(j));
                fft_points[i].set(j, powerAtBin);
            }
        }

        //Update channel select checkboxes and active channels
        fftChanSelect.update(x, y, w);

        //Flex the Gplot graph when channel select dropdown is open/closed
        if (fftChanSelect.isVisible() != prevChanSelectIsVisible) {
            flexGPlotSizeAndPosition();
            prevChanSelectIsVisible = fftChanSelect.isVisible();
        }

        if (fftChanSelect.isVisible()) {
            lockElementsOnOverlapCheck(cp5ElementsToCheck);
        }
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        pushStyle();

        //draw FFT Graph w/ all plots
        noStroke();
        fft_plot.beginDraw();
        fft_plot.drawBackground();
        fft_plot.drawBox();
        fft_plot.drawXAxis();
        fft_plot.drawYAxis();
        fft_plot.drawGridLines(GPlot.BOTH);
        //Update and draw active channels that have been selected via channel select for this widget
        for (int j = 0; j < fftChanSelect.activeChan.size(); j++) {
            int chan = fftChanSelect.activeChan.get(j);
            fft_plot.setLineColor(lineColor[chan]);
            //remap fft point arrays to fft plots
            fft_plot.setPoints(fft_points[chan]);
            fft_plot.drawLines();
        }  
        fft_plot.endDraw();

        //for this widget need to redraw the grey bar, bc the FFT plot covers it up...
        fill(200, 200, 200);
        rect(x, y - navHeight, w, navHeight); //button bar

        popStyle();

        fftChanSelect.draw();
    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        //update position/size of FFT plot
        fft_plot.setPos(x, y-navHeight);//update position
        fft_plot.setOuterDim(w, h+navHeight);//update dimensions

        fftChanSelect.screenResized(pApplet);
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
        fftChanSelect.mousePressed(this.dropdownIsActive); //Calls channel select mousePressed and checks if clicked
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
    }

    public void flexGPlotSizeAndPosition() {
        if (fftChanSelect.isVisible()) {
                fft_plot.setPos(x, y);
                fft_plot.setOuterDim(w, h);
        } else {
            fft_plot.setPos(x, y - navHeight);
            fft_plot.setOuterDim(w, h + navHeight);
        }
    }
};

//These functions need to be global! These functions are activated when an item from the corresponding dropdown is selected
//triggered when there is an event in the MaxFreq. Dropdown
public void MaxFreq(int n) {
    /* request the selected item based on index n */
    w_fft.fft_plot.setXLim(0.1f, w_fft.xLimOptions[n]); //update the xLim of the FFT_Plot
    settings.fftMaxFrqSave = n; //save the xLim to variable for save/load settings
}

//triggered when there is an event in the VertScale Dropdown
public void VertScale(int n) {

    w_fft.fft_plot.setYLim(0.1f, w_fft.yLimOptions[n]); //update the yLim of the FFT_Plot
    settings.fftMaxuVSave = n; //save the yLim to variable for save/load settings
}

//triggered when there is an event in the LogLin Dropdown
public void LogLin(int n) {
    if (n==0) {
        w_fft.fft_plot.setLogScale("y");
        //store the current setting to save
        settings.fftLogLinSave = 0;
    } else {
        w_fft.fft_plot.setLogScale("");
        //store the current setting to save
        settings.fftLogLinSave = 1;
    }
}

//triggered when there is an event in the Smoothing Dropdown
public void Smoothing(int n) {
    smoothFac_ind = n;
    settings.fftSmoothingSave = n;
    //since this function is called by both the BandPower and FFT Widgets the dropdown needs to be updated in both
    w_fft.cp5_widget.getController("Smoothing").getCaptionLabel().setText(settings.fftSmoothingArray[n]);
    w_bandPower.cp5_widget.getController("Smoothing").getCaptionLabel().setText(settings.fftSmoothingArray[n]);

}

//triggered when there is an event in the UnfiltFilt Dropdown
public void UnfiltFilt(int n) {
    settings.fftFilterSave = n;
    if (n==0) {
        //have FFT use filtered data -- default
        isFFTFiltered = true;
    } else {
        //have FFT use unfiltered data
        isFFTFiltered = false;
    }
    //since this function is called by both the BandPower and FFT Widgets the dropdown needs to be updated in both
    w_fft.cp5_widget.getController("UnfiltFilt").getCaptionLabel().setText(settings.fftFilterArray[n]);
    w_bandPower.cp5_widget.getController("UnfiltFilt").getCaptionLabel().setText(settings.fftFilterArray[n]);
}
////////////////////////////////////////////////////
//                                                //
//    W_focus.pde (ie "Focus Widget")             //
//    Enums can be found in FocusEnums.pde        //
//                                                //
//                                                //
//    Created by: Richard Waltman, March 2021     //
//                                                //
////////////////////////////////////////////////////














class W_Focus extends Widget {

    //to see all core variables/methods of the Widget class, refer to Widget.pde
    //put your custom variables here...
    //private ControlP5 focus_cp5;
    //private Button widgetTemplateButton;
    private ChannelSelect focusChanSelect;
    private boolean prevChanSelectIsVisible = false;
    private AuditoryNeurofeedback auditoryNeurofeedback;


    private Grid dataGrid;
    private final int NUM_TABLE_ROWS = 6;
    private final int NUM_TABLE_COLUMNS = 2;
    //private final int TABLE_WIDTH = 142;
    private int tableHeight = 0;
    private int cellHeight = 10;
    private DecimalFormat df = new DecimalFormat("#.0000");

    private final int PAD_FIVE = 5;
    private final int PAD_TWO = 2;
    private final int METRIC_DROPDOWN_W = 100;
    private final int CLASSIFIER_DROPDOWN_W = 80;

    private FocusBar focusBar;
    private float focusBarHardYAxisLimit = 1.05f; //Provide slight "breathing room" to avoid GPlot error when metric value == 1.0
    FocusXLim xLimit = FocusXLim.TEN;
    FocusMetric focusMetric = FocusMetric.RELAXATION;
    FocusClassifier focusClassifier = FocusClassifier.REGRESSION;
    FocusThreshold focusThreshold = FocusThreshold.EIGHT_TENTHS;
    private FocusColors focusColors = FocusColors.GREEN;

    int[] exgChannels;
    int channelCount;
    double[][] dataArray;

    MLModel mlModel;
    private double metricPrediction = 0d;
    private boolean predictionExceedsThreshold = false;

    private float xc, yc, wc, hc; // status circle center xy, width and height
    private int graphX, graphY, graphW, graphH;
    private int graphPadding = 30;
    private int cBack, cDark, cMark, cFocus, cWave, cPanel;

    List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();

    W_Focus(PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

         //Add channel select dropdown to this widget
        focusChanSelect = new ChannelSelect(pApplet, this, x, y, w, navH, "FocusChannelSelect");
        focusChanSelect.activateAllButtons();
        cp5ElementsToCheck.addAll(focusChanSelect.getCp5ElementsForOverlapCheck());

        auditoryNeurofeedback = new AuditoryNeurofeedback(x + PAD_FIVE, y + PAD_FIVE, w/2 - PAD_FIVE*2, navBarHeight/2);
        cp5ElementsToCheck.add((controlP5.Controller)auditoryNeurofeedback.startStopButton);
        cp5ElementsToCheck.add((controlP5.Controller)auditoryNeurofeedback.modeButton);

        exgChannels = currentBoard.getEXGChannels();
        channelCount = currentBoard.getNumEXGChannels();
        dataArray = new double[channelCount][];

        // initialize graphics parameters
        onColorChange();
        
        //This is the protocol for setting up dropdowns.
        dropdownWidth = 60; //Override the default dropdown width for this widget
        addDropdown("focusMetricDropdown", "Metric", focusMetric.getEnumStringsAsList(), focusMetric.getIndex());
        addDropdown("focusClassifierDropdown", "Classifier", focusClassifier.getEnumStringsAsList(), focusClassifier.getIndex());
        addDropdown("focusThresholdDropdown", "Threshold", focusThreshold.getEnumStringsAsList(), focusThreshold.getIndex());
        addDropdown("focusWindowDropdown", "Window", xLimit.getEnumStringsAsList(), xLimit.getIndex());
        

        //Create data table
        dataGrid = new Grid(NUM_TABLE_ROWS, NUM_TABLE_COLUMNS, cellHeight);
        dataGrid.setTableFontAndSize(p6, 10);
        dataGrid.setDrawTableBorder(true);
        dataGrid.setString("Metric Value", 0, 0);
        dataGrid.setString("Delta (1.5-4Hz)", 1, 0);
        dataGrid.setString("Theta (4-8Hz)", 2, 0);
        dataGrid.setString("Alpha (7.5-13Hz)", 3, 0);
        dataGrid.setString("Beta (13-30Hz)", 4, 0);
        dataGrid.setString("Gamma (30-45Hz)", 5, 0);

        //Instantiate local cp5 for this box. This allows extra control of drawing cp5 elements specifically inside this class.
        //focus_cp5 = new ControlP5(ourApplet);
        //focus_cp5.setGraphics(ourApplet, 0,0);
        //focus_cp5.setAutoDraw(false);

        //create our focus graph
        updateGraphDims();
        focusBar = new FocusBar(_parent, xLimit.getValue(), focusBarHardYAxisLimit, graphX, graphY, graphW, graphH);

        initBrainFlowMetric();
    }

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        //Update channel checkboxes and active channels
        focusChanSelect.update(x, y, w);

        //Flex the Gplot graph when channel select dropdown is open/closed
        if (focusChanSelect.isVisible() != prevChanSelectIsVisible) {
            channelSelectFlexWidgetUI();
            prevChanSelectIsVisible = focusChanSelect.isVisible();
        }

        if (currentBoard.isStreaming()) {
            metricPrediction = updateFocusState();
            dataGrid.setString(df.format(metricPrediction), 0, 1);
            focusBar.update(metricPrediction);
            predictionExceedsThreshold = metricPrediction > focusThreshold.getValue();
        }

        lockElementsOnOverlapCheck(cp5ElementsToCheck);
    }

    public void draw() {
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)
        //remember to refer to x,y,w,h which are the positioning variables of the Widget class

        //Draw data table
        dataGrid.draw();

        drawStatusCircle();

        if (false) {
            //Draw some guides to help develop this widget faster
            pushStyle();
            stroke(OPENBCI_DARKBLUE);
            //Main guides
            line(x, y+(h/2), x+w, y+(h/2));
            line(x+(w/2), y, x+(w/2), y+(h/2));
            //Top left container center
            line(x+(w/4), y, x+(w/4), y+(h/2));
            line(x, y+(h/4), x+(w/2), y+(h/4));
            popStyle();
        }

        //This draws all cp5 objects in the local instance
        //focus_cp5.draw();
        auditoryNeurofeedback.draw();
        
        //Draw the graph
        focusBar.draw();

        focusChanSelect.draw();
    }

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        //Very important to allow users to interact with objects after app resize        
        //focus_cp5.setGraphics(ourApplet, 0, 0);

        resizeTable();

        //We need to set the position of our Cp5 object after the screen is resized
        //widgetTemplateButton.setPosition(x + w/2 - widgetTemplateButton.getWidth()/2, y + h/2 - widgetTemplateButton.getHeight()/2);

        updateStatusCircle();
        updateAuditoryNeurofeedbackPosition();

        updateGraphDims();
        focusBar.screenResized(graphX, graphY, graphW, graphH);
        focusChanSelect.screenResized(pApplet);

        //Custom resize these dropdowns due to longer text strings as options
        cp5_widget.get(ScrollableList.class, "focusMetricDropdown").setWidth(METRIC_DROPDOWN_W);
        cp5_widget.get(ScrollableList.class, "focusMetricDropdown").setPosition(
            x0 + w0 - (dropdownWidth*2) - METRIC_DROPDOWN_W - CLASSIFIER_DROPDOWN_W - (PAD_TWO*4), 
            navH + y0 + PAD_TWO
            );
        cp5_widget.get(ScrollableList.class, "focusClassifierDropdown").setWidth(CLASSIFIER_DROPDOWN_W);
        cp5_widget.get(ScrollableList.class, "focusClassifierDropdown").setPosition(
            x0 + w0 - (dropdownWidth*2) - CLASSIFIER_DROPDOWN_W - (PAD_TWO*3), 
            navH + y0 + PAD_TWO
            );
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
        focusChanSelect.mousePressed(this.dropdownIsActive); //Calls channel select mousePressed and checks if clicked
    }

    private void resizeTable() {
        int extraPadding = focusChanSelect.isVisible() ? navHeight : 0;
        float upperLeftContainerW = w/2;
        float upperLeftContainerH = h/2;
        //float min = min(upperLeftContainerW, upperLeftContainerH);
        int tx = x + PApplet.parseInt(upperLeftContainerW);
        int ty = y + PAD_FIVE + extraPadding;
        int tw = PApplet.parseInt(upperLeftContainerW) - PAD_FIVE*2;
        //tableHeight = tw;
        dataGrid.setDim(tx, ty, tw);
        dataGrid.setTableHeight(PApplet.parseInt(upperLeftContainerH - PAD_FIVE*2));
        dataGrid.dynamicallySetTextVerticalPadding(0, 0);
        dataGrid.setHorizontalCenterTextInCells(true);
    }

    private void updateAuditoryNeurofeedbackPosition() {
        int extraPadding = focusChanSelect.isVisible() ? navHeight : 0;
        int subContainerMiddleX = x + w/4;
        auditoryNeurofeedback.screenResized(subContainerMiddleX, (int)(y + h/2 - navHeight + extraPadding), w/2 - PAD_FIVE*2, navBarHeight/2);
    }

    private void updateStatusCircle() {
        float upperLeftContainerW = w/2;
        float upperLeftContainerH = h/2;
        float min = min(upperLeftContainerW, upperLeftContainerH);
        xc = x + w/4;
        yc = y + h/4 - navHeight;
        wc = min * (3f/5);
        hc = wc;
    }

    private void updateGraphDims() {
        graphW = PApplet.parseInt(w - PAD_FIVE*4);
        graphH = PApplet.parseInt(h/2 - graphPadding - PAD_FIVE*2);
        graphX = x + PAD_FIVE*2;
        graphY = PApplet.parseInt(y + h/2);
    }

    //Core method to fetch and process data
    //Returns a metric value from 0. to 1. When there is an error, returns -1.
    private double updateFocusState() {
        try {
            int windowSize = currentBoard.getSampleRate() * xLimit.getValue();
            // getData in GUI returns data in shape ndatapoints x nchannels, in BrainFlow its transposed
            List<double[]> currentData = currentBoard.getData(windowSize);

            if (currentData.size() != windowSize || focusChanSelect.activeChan.size() <= 0) {
                return -1.0f;
            }

            for (int i = 0; i < channelCount; i++) {
                dataArray[i] = new double[windowSize];
                for (int j = 0; j < currentData.size(); j++) {
                    dataArray[i][j] = currentData.get(j)[exgChannels[i]];
                }
            }

            int[] channelsInDataArray = ArrayUtils.toPrimitive(
                    focusChanSelect.activeChan.toArray(
                        new Integer[focusChanSelect.activeChan.size()]
                    ));

            //Full Source Code for this method: https://github.com/brainflow-dev/brainflow/blob/c5f0ad86683e6eab556e30965befb7c93e389a3b/src/data_handler/data_handler.cpp#L1115
            Pair<double[], double[]> bands = DataFilter.get_avg_band_powers (dataArray, channelsInDataArray, currentBoard.getSampleRate(), true);
            double[] featureVector = bands.getLeft ();

            //Left array is Averages, right array is Standard Deviations. Update values using Averages.
            updateBandPowerTableValues(bands.getLeft());

            //Keep this here
            double prediction = mlModel.predict(featureVector)[0];
            //println("Concentration: " + prediction);

            //Send band power and prediction data to AuditoryNeurofeedback class
            auditoryNeurofeedback.update(bands.getLeft(), (float)prediction);
            
            return prediction;

        } catch (BrainFlowError e) {
            e.printStackTrace();
            println("Error updating focus state!");
            return -1d;
        }
    }

    private void updateBandPowerTableValues(double[] bandPowers) {
        for (int i = 0; i < bandPowers.length; i++) {
            dataGrid.setString(df.format(bandPowers[i]), 1 + i, 1);
        }
    }

    private void drawStatusCircle() {
        int fillColor;
        int strokeColor;
        StringBuilder sb = new StringBuilder("");
        if (predictionExceedsThreshold) {
            fillColor = cFocus;
            strokeColor = cFocus;
        } else {
            fillColor = cDark;
            strokeColor = cDark;
            sb.append("Not ");
        }
        sb.append(focusMetric.getIdealStateString());
        //Draw status graphic
        pushStyle();
        noStroke();
        fill(fillColor);
        stroke(strokeColor);
        ellipseMode(CENTER);
        ellipse(xc, yc, wc, hc);
        noStroke();
        textAlign(CENTER);
        text(sb.toString(), xc, yc + hc/2 + 16);
        popStyle();
    }

    private void initBrainFlowMetric() {
        BrainFlowModelParams modelParams = new BrainFlowModelParams(
                focusMetric.getMetric().get_code(),
                focusClassifier.getClassifier().get_code()
                );
        mlModel = new MLModel (modelParams);
        try {
            mlModel.prepare();
        } catch (BrainFlowError e) {
            e.printStackTrace();
        }
    }

    //Called on haltSystem() when GUI exits or session stops
    public void endSession() {
        try {
            mlModel.release();
        } catch (BrainFlowError e) {
            e.printStackTrace();
        }
    }

    private void onColorChange() {
        switch(focusColors) {
            case GREEN:
                cBack = 0xFFFFFFFF;   //white
                cDark = 0xFF3068A6;   //medium/dark blue
                cMark = 0xFF4D91D9;    //lighter blue
                cFocus = 0xFFB8DC69;   //theme green
                cWave = 0xFFFFDD3A;    //yellow
                cPanel = 0xFFF5F5F5;   //little grey
                break;
            case ORANGE:
                cBack = 0xFFFFFFFF;   //white
                cDark = 0xFF377BC4;   //medium/dark blue
                cMark = 0xFF5E9EE2;    //lighter blue
                cFocus = 0xFFFCCE51;   //orange
                cWave = 0xFFFFDD3A;    //yellow
                cPanel = 0xFFF5F5F5;   //little grey
                break;
            case CYAN:
                cBack = 0xFFFFFFFF;   //white
                cDark = 0xFF377BC4;   //medium/dark blue
                cMark = 0xFF5E9EE2;    //lighter blue
                cFocus = 0xFF91F4FC;   //cyan
                cWave = 0xFFFFDD3A;    //yellow
                cPanel = 0xFFF5F5F5;   //little grey
                break;
        }
    }

    public void channelSelectFlexWidgetUI() {
        focusBar.setPlotPosAndOuterDim(focusChanSelect.isVisible());
        int factor = focusChanSelect.isVisible() ? 1 : -1;
        yc += navHeight * factor;
        resizeTable();
        updateAuditoryNeurofeedbackPosition();
    }

    public void setFocusHorizScale(int n) {
        xLimit = xLimit.values()[n];
        focusBar.adjustTimeAxis(xLimit.getValue());
    }

    public void setMetric(int n) {
        focusMetric = focusMetric.values()[n];
        endSession();
        initBrainFlowMetric();
    }

    public void setClassifier(int n) {
        focusClassifier = focusClassifier.values()[n];
        endSession();
        initBrainFlowMetric();
    }

    public void setThreshold(int n) {
        focusThreshold = focusThreshold.values()[n];
    }

    public int getMetricExceedsThreshold() {
        return predictionExceedsThreshold ? 1 : 0;
    }

    public void killAuditoryFeedback() {
        auditoryNeurofeedback.killAudio();
    }
}; //end of class

//The following global functions are used by the Focus widget dropdowns. This method is the least amount of code.
public void focusWindowDropdown(int n) {
    w_focus.setFocusHorizScale(n);
}

public void focusMetricDropdown(int n) {
    w_focus.setMetric(n);
}

public void focusClassifierDropdown(int n) {
    w_focus.setClassifier(n);
}

public void focusThresholdDropdown(int n) {
    w_focus.setThreshold(n);
}

//This class contains the time series plot for the focus metric over time
class FocusBar {
    int x, y, w, h;
    int focusBarPadding = 30;
    int xOffset;
    final int nPoints = 30 * 1000;

    GPlot plot; //the actual grafica-based GPlot that will be rendering the Time Series trace
    LinkedList<Float> fifoList;
    LinkedList<Float> fifoTimeList;

    int numSeconds;
    int channelColor; //color of plot trace

    FocusBar(PApplet _parent, int xLimit, float yLimit, int _x, int _y, int _w, int _h) { //channel number, x/y location, height, width
        x = _x;
        y = _y;
        w = _w;
        h = _h;
        if (eegDataSource == DATASOURCE_CYTON) {
            xOffset = 22;
        } else {
            xOffset = 0;
        }
        numSeconds = xLimit;

        plot = new GPlot(_parent);
        plot.setPos(x + 36 + 4 + xOffset, y); //match Accelerometer plot position with Time Series
        plot.setDim(w - 36 - 4 - xOffset, h);
        plot.setMar(0f, 0f, 0f, 0f);
        plot.setLineColor((int)channelColors[(NUM_ACCEL_DIMS)%8]);
        plot.setXLim(-numSeconds,0); //set the horizontal scale
        plot.setYLim(0, yLimit); //change this to adjust vertical scale
        //plot.setPointSize(2);
        plot.setPointColor(0);
        plot.getXAxis().setAxisLabelText("Time (s)");
        plot.getYAxis().setAxisLabelText("Metric Value");
        plot.setAllFontProperties("Arial", 0, 14);
        plot.getXAxis().getAxisLabel().setOffset(PApplet.parseFloat(22));
        plot.getYAxis().getAxisLabel().setOffset(PApplet.parseFloat(focusBarPadding));
        plot.getXAxis().setFontColor(OPENBCI_DARKBLUE);
        plot.getXAxis().setLineColor(OPENBCI_DARKBLUE);
        plot.getXAxis().getAxisLabel().setFontColor(OPENBCI_DARKBLUE);
        plot.getYAxis().setFontColor(OPENBCI_DARKBLUE);
        plot.getYAxis().setLineColor(OPENBCI_DARKBLUE);
        plot.getYAxis().getAxisLabel().setFontColor(OPENBCI_DARKBLUE);

        adjustTimeAxis(numSeconds);

        initArrays();

        //set the plot points for X, Y, and Z axes
        plot.addLayer("layer 1", new GPointsArray(30));
        plot.getLayer("layer 1").setLineColor(ACCEL_X_COLOR);
    }

    private void initArrays() {
        fifoList = new LinkedList<Float>();
        fifoTimeList = new LinkedList<Float>();
        for (int i = 0; i < nPoints; i++) {
            fifoList.add(0f);
            fifoTimeList.add(0f);
        }
    }

    public void update(double val) {
        updateGPlotPoints(val);
    }

    public void draw() {
        plot.beginDraw();
        plot.drawBox(); //we won't draw this eventually ...
        plot.drawGridLines(GPlot.BOTH);
        plot.drawLines(); //Draw a Line graph!
        //plot.drawPoints(); //Used to draw Points instead of Lines
        plot.drawYAxis();
        plot.drawXAxis();
        plot.getXAxis().draw();
        plot.endDraw();
    }

    public void adjustTimeAxis(int _newTimeSize) {
        numSeconds = _newTimeSize;
        plot.setXLim(-_newTimeSize,0);
        initArrays();
        //Set the number of axis divisions...
        if (_newTimeSize > 1) {
            plot.getXAxis().setNTicks(_newTimeSize);
        }else{
            plot.getXAxis().setNTicks(10);
        }
    }

    //Used to update the Points within the graph
    private void updateGPlotPoints(double val) {
        float timerVal = (float)millis() / 1000.0f;
        fifoTimeList.removeFirst();
        fifoTimeList.addLast(timerVal);
        fifoList.removeFirst();
        fifoList.addLast((float)val);

        int stopId = 0;
        for (stopId = nPoints - 1; stopId > 0; stopId--) {
            if (timerVal - fifoTimeList.get(stopId) > numSeconds) {
                break;
            }
        }
        int size = nPoints - 1 - stopId;
        GPointsArray focusPoints = new GPointsArray(size);
        for (int i = 0; i < size; i++) {
            focusPoints.set(i, fifoTimeList.get(i + stopId) - timerVal, fifoList.get(i + stopId), "");
        }
        plot.setPoints(focusPoints, "layer 1");
    }

    public void screenResized(int _x, int _y, int _w, int _h) {
        x = _x;
        y = _y;
        w = _w;
        h = _h;
        //reposition & resize the plot
        plot.setPos(x + 36 + 4 + xOffset, y);
        plot.setDim(w - 36 - 4 - xOffset, h);

    }

    public void setPlotPosAndOuterDim(boolean chanSelectIsVisible) {
        int _y = chanSelectIsVisible ? y + 22 : y;
        int _h = chanSelectIsVisible ? h - 22 : h;
        //reposition & resize the plot
        plot.setPos(x + 36 + 4 + xOffset, _y);
        plot.setDim(w - 36 - 4 - xOffset, _h);
    }

}; //end of class

////////////////////////////////////////////////////
//
//    W_template.pde (ie "Widget Template")
//
//    This is a Template Widget, intended to be used as a starting point for OpenBCI Community members that want to develop their own custom widgets!
//    Good luck! If you embark on this journey, please let us know. Your contributions are valuable to everyone!
//
//    Created by: Conor Russomanno, November 2016
//
///////////////////////////////////////////////////,


class W_GanglionImpedance extends Widget {
    Button startStopCheck;
    int padding = 24;

    W_GanglionImpedance(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        createStartStopCheck("startStopCheck", "Start Impedance Check", x + padding, y + padding, 200, navHeight, p4, 14, colorNotPressed, OPENBCI_DARKBLUE);
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        pushStyle();

        //divide by 2 ... we do this assuming that the D_G (driven ground) electrode is "comprable in impedance" to the electrode being used.
        fill(OPENBCI_DARKBLUE);
        textFont(p4, 14);

        BoardGanglion ganglion = (BoardGanglion)currentBoard;
        if (!ganglion.isCheckingImpedance()) {
            return;
        }

        int resistanceChannels[] = ganglion.getResistanceChannels();
        List<double[]> data = ganglion.getData(1);

        // todo format in brainflow, 4 channels and reference. Does it match this code
        for(int i = 0; i < resistanceChannels.length; i++){
            String toPrint;
            float adjustedImpedance = (float)data.get(0)[resistanceChannels[i]]/2.0f;
            if(i == (resistanceChannels.length - 1)) {
                toPrint = "Reference Impedance \u2248 " + adjustedImpedance + " k\u2126";
            } else {
                toPrint = "Channel[" + i + "] Impedance \u2248 " + adjustedImpedance + " k\u2126";
            }
            text(toPrint, x + padding + 40, y + padding*2 + 12 + startStopCheck.getHeight() + padding*(i));

            pushStyle();
            stroke(OPENBCI_DARKBLUE);
            //change the fill color based on the signal quality...
            if(adjustedImpedance <= 0){ //no data yet...
                fill(255);
            } else if(adjustedImpedance > 0 && adjustedImpedance <= 10){ //very good signal quality
                fill(49, 113, 89); //dark green
            } else if(adjustedImpedance > 10 && adjustedImpedance <= 50){ //good signal quality
                fill(184, 220, 105); //yellow green
            } else if(adjustedImpedance > 50 && adjustedImpedance <= 100){ //acceptable signal quality
                fill(221, 178, 13); //yellow
            } else if(adjustedImpedance > 100 && adjustedImpedance <= 150){ //questionable signal quality
                fill(253, 94, 52); //orange
            } else if(adjustedImpedance > 150){ //bad signal quality
                fill(224, 56, 45); //red
            }

            ellipse(x + padding + 10, y + padding*2 + 7 + startStopCheck.getHeight() + padding*(i), padding/2, padding/2);
            popStyle();
        }

        image(loadingGIF_blue, x + padding + startStopCheck.getWidth() + 15, y + padding - 8, 40, 40);
        popStyle();
    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)
        startStopCheck.setPosition(x + padding, y + padding);
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
    }

    private void createStartStopCheck(String name, String text, int _x, int _y, int _w, int _h, PFont _font, int _fontSize, int _bg, int _textColor) {
        startStopCheck = createButton(cp5_widget, name, text, _x, _y, _w, _h, _font, _fontSize, _bg, _textColor);
        startStopCheck.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (currentBoard instanceof BoardGanglion) {
                    // ganglion is the only board which can check impedance, so we don't have an interface for it.
                    // if that changes in the future, consider making an interface.
                    BoardGanglion ganglionBoard = (BoardGanglion)currentBoard;
                    if (!ganglionBoard.isCheckingImpedance()) {
                        // We need to either stop the time series data, or allow it to scroll, like currently. 
                        // the values in time series are not meaningful when Impedance check is active
                        println("Starting Ganglion impedance check...");
                        //Start impedance check
                        ganglionBoard.setCheckingImpedance(true);
                        startStopCheck.getCaptionLabel().setText("Stop Impedance Check");
                    } else {
                        //Stop impedance check
                        ganglionBoard.setCheckingImpedance(false);
                        startStopCheck.getCaptionLabel().setText("Start Impedance Check");
                    }
                }
            }
        });
        startStopCheck.setDescription("Click this button to start or stop checking impedance.");
    }
};

////////////////////////////////////////////////////
//
//    W_template.pde (ie "Widget Template")
//
//    This is a Template Widget, intended to be used as a starting point for OpenBCI Community members that want to develop their own custom widgets!
//    Good luck! If you embark on this journey, please let us know. Your contributions are valuable to everyone!
//
//    Created by: Conor Russomanno, November 2016
//    Based on code written by: Chip Audette, Oct 2013
//
///////////////////////////////////////////////////,


float[] smoothFac = new float[]{0.0f, 0.5f, 0.75f, 0.9f, 0.95f, 0.98f, 0.99f, 0.999f}; //used by FFT & Headplot
int smoothFac_ind = 3;    //initial index into the smoothFac array = 0.75 to start .. used by FFT & Head Plots

class W_HeadPlot extends Widget {
    HeadPlot headPlot;

    W_HeadPlot(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        //Headplot settings
        settings.hpIntensitySave = 2;
        settings.hpPolaritySave = 0;
        settings.hpContoursSave = 0;
        settings.hpSmoothingSave = 3;
        //This is the protocol for setting up dropdowns.
        //Note that these 3 dropdowns correspond to the 3 global functions below
        //You just need to make sure the "id" (the 1st String) has the same name as the corresponding function
        // addDropdown("Ten20", "Layout", Arrays.asList("10-20", "5-10"), 0);
        // addDropdown("Headset", "Headset", Arrays.asList("None", "Mark II", "Mark III", "Mark IV "), 0);
        addDropdown("Intensity", "Intensity", Arrays.asList("4x", "2x", "1x", "0.5x", "0.2x", "0.02x"), vertScaleFactor_ind);
        addDropdown("Polarity", "Polarity", Arrays.asList("+/-", " + "), settings.hpPolaritySave);
        addDropdown("ShowContours", "Contours", Arrays.asList("ON", "OFF"), settings.hpContoursSave);
        addDropdown("SmoothingHeadPlot", "Smooth", Arrays.asList("0.0", "0.5", "0.75", "0.9", "0.95", "0.98"), smoothFac_ind);
        //Initialize the headplot
        updateHeadPlot(nchan);
    }

    public void updateHeadPlot(int _nchan) {
        headPlot = new HeadPlot(x, y, w, h, win_w, win_h);
        //FROM old Gui_Manager
        headPlot.setIntensityData_byRef(dataProcessing.data_std_uV, is_railed);
        headPlot.setPolarityData_byRef(dataProcessing.polarity);
        setSmoothFac(smoothFac[smoothFac_ind]);
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
        headPlot.update();
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)
        headPlot.draw(); //draw the actual headplot
    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)
        headPlot.hp_x = x;
        headPlot.hp_y = y;
        headPlot.hp_w = w;
        headPlot.hp_h = h;
        headPlot.hp_win_x = x;
        headPlot.hp_win_y = y;

        thread("doHardCalcs");
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
        headPlot.mousePressed();
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
        headPlot.mouseReleased();
    }

    public void mouseDragged(){
        super.mouseDragged(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
        headPlot.mouseDragged();
    }

    //add custom class functions here
    public void setSmoothFac(float fac) {
        headPlot.smooth_fac = fac;
    }
};

//triggered when there is an event in the Polarity Dropdown
public void Polarity(int n) {

    if (n==0) {
        w_headPlot.headPlot.use_polarity = true;
    } else {
        w_headPlot.headPlot.use_polarity = false;
    }
    settings.hpPolaritySave = n;
}

public void ShowContours(int n){
    if(n==0){
        //turn headplot contours on
        w_headPlot.headPlot.drawHeadAsContours = true;
    } else if(n==1){
        //turn headplot contours off
        w_headPlot.headPlot.drawHeadAsContours = false;
    }
    settings.hpContoursSave = n;
}

//triggered when there is an event in the SmoothingHeadPlot Dropdown
public void SmoothingHeadPlot(int n) {
    w_headPlot.setSmoothFac(smoothFac[n]);
    settings.hpSmoothingSave = n;
}

public void Intensity(int n){
    vertScaleFactor_ind = n;
    updateVertScale();
    settings.hpIntensitySave = n;
}

// ----- these variable/methods are used for adjusting the intensity factor of the headplot opacity ---------------------------------------------------------------------------------------------------------
float default_vertScale_uV = 200.0f; //this defines the Y-scale on the montage plots...this is the vertical space between traces
float[] vertScaleFactor = { 0.25f, 0.5f, 1.0f, 2.0f, 5.0f, 50.0f};
int vertScaleFactor_ind = 2;
float vertScale_uV = default_vertScale_uV;

public void setVertScaleFactor_ind(int ind) {
    vertScaleFactor_ind = max(0,ind);
    if (ind >= vertScaleFactor.length) vertScaleFactor_ind = 0;
    updateVertScale();
}

public void updateVertScale() {
    vertScale_uV = default_vertScale_uV * vertScaleFactor[vertScaleFactor_ind];
    w_headPlot.headPlot.setMaxIntensity_uV(vertScale_uV);
}

public void doHardCalcs() {
    if (!w_headPlot.headPlot.threadLock) {
        w_headPlot.headPlot.threadLock = true;
        w_headPlot.headPlot.setPositionSize(w_headPlot.headPlot.hp_x, w_headPlot.headPlot.hp_y, w_headPlot.headPlot.hp_w, w_headPlot.headPlot.hp_h, w_headPlot.headPlot.hp_win_x, w_headPlot.headPlot.hp_win_y);
        w_headPlot.headPlot.hardCalcsDone = true;
        w_headPlot.headPlot.threadLock = false;
    }
}

//---------------------------------------------------------------------------------------------------------------------------------------

//////////////////////////////////////////////////////////////
//
// HeadPlot Class
//
// This class creates and manages the head-shaped plot used by the GUI.
// The head includes circles representing the different EEG electrodes.
// The color (brightness) of the electrodes can be adjusted so that the
// electrodes' brightness values dynamically reflect the intensity of the
// EEG signal.  All EEG processing must happen outside of this class.
//
// Created by: Chip Audette 2013
//
///////////////////////////////////////////////////////////////

// Note: This routine uses aliasing to know which data should be used to
// set the brightness of the electrodes.

class HeadPlot {
    private float rel_posX, rel_posY, rel_width, rel_height;
    private int circ_x, circ_y, circ_diam;
    private int earL_x, earL_y, earR_x, earR_y, ear_width, ear_height;
    private int[] nose_x, nose_y;
    private float[][] electrode_xy;
    private float[] ref_electrode_xy;
    private float[][][] electrode_color_weightFac;
    private int[][] electrode_rgb;
    private float[][] headVoltage;
    private int elec_diam;
    PFont font;
    public float[] intensity_data_uV;
    public float[] polarity_data;
    private DataStatus[] is_railed;
    private float intense_min_uV=0.0f, intense_max_uV=1.0f, assumed_railed_voltage_uV=1.0f;
    private float log10_intense_min_uV = 0.0f, log10_intense_max_uV=1.0f;
    PImage headImage;
    private int image_x, image_y;
    public boolean drawHeadAsContours;
    private boolean plot_color_as_log = true;
    public float smooth_fac = 0.0f;
    private boolean use_polarity = true;
    private int mouse_over_elec_index = -1;
    private boolean isDragging = false;
    private float drag_x, drag_y;
    public int hp_win_x = 0;
    public int hp_win_y = 0;
    public int hp_x = 0;
    public int hp_y = 0;
    public int hp_w = 0;
    public int hp_h = 0;
    public boolean hardCalcsDone = false;
    public boolean threadLock = false;

    HeadPlot(int _x, int _y, int _w, int _h, int _win_x, int _win_y) {
        final int n_elec = nchan;  //set number of electrodes using the global nchan variable
        nose_x = new int[3];
        nose_y = new int[3];
        electrode_xy = new float[n_elec][2];   //x-y position of electrodes (pixels?)
        ref_electrode_xy = new float[2];  //x-y position of reference electrode
        electrode_rgb = new int[3][n_elec];  //rgb color for each electrode
        font = p5;
        drawHeadAsContours = true; //set this to be false for slower computers

        hp_x = _x;
        hp_y = _y;
        hp_w = _w;
        hp_h = _h;
        hp_win_x = _win_x;
        hp_win_y = _win_y;
        setMaxIntensity_uV(200.0f);  //default intensity scaling for electrodes
    }

    public void setPositionSize(int _x, int _y, int _w, int _h, int _win_x, int _win_y) {
        float percentMargin = 0.1f;
        _x = _x + (int)(PApplet.parseFloat(_w)*percentMargin);
        _y = _y + (int)(PApplet.parseFloat(_h)*percentMargin)-navHeight/2;
        _w = (int)(PApplet.parseFloat(_w)-(2*(PApplet.parseFloat(_w)*percentMargin)));
        _h = (int)(PApplet.parseFloat(_h)-(2*(PApplet.parseFloat(_h)*percentMargin)));

        rel_posX = PApplet.parseFloat(_x)/_win_x;
        rel_posY = PApplet.parseFloat(_y)/_win_y;
        rel_width = PApplet.parseFloat(_w)/_win_x;
        rel_height = PApplet.parseFloat(_h)/_win_y;
        setWindowDimensions(_win_x, _win_y);
    }

    public void setIntensityData_byRef(float[] data, DataStatus[] is_rail) {
        intensity_data_uV = data;  //simply alias the data held externally.  DOES NOT COPY THE DATA ITSEF!  IT'S SIMPLY LINKED!
        is_railed = is_rail;
    }

    public void setPolarityData_byRef(float[] data) {
        polarity_data = data;//simply alias the data held externally.  DOES NOT COPY THE DATA ITSEF!  IT'S SIMPLY LINKED!
    }

    public String getUsePolarityTrueFalse() {
        if (use_polarity) {
            return "True";
        } else {
            return "False";
        }
    }

    public void setMaxIntensity_uV(float val_uV) {
        intense_max_uV = val_uV;
        intense_min_uV = intense_max_uV / 200.0f * 5.0f;  //set to 200, get 5
        assumed_railed_voltage_uV = intense_max_uV;

        log10_intense_max_uV = log10(intense_max_uV);
        log10_intense_min_uV = log10(intense_min_uV);
    }

    public void set_plotColorAsLog(boolean state) {
        plot_color_as_log = state;
    }

    //this method defines all locations of all the subcomponents
    public void setWindowDimensions(int win_width, int win_height) {
        final int n_elec = electrode_xy.length;

        //define the head itself
        float nose_relLen = 0.075f;
        float nose_relWidth = 0.05f;
        float nose_relGutter = 0.02f;
        float ear_relLen = 0.15f;
        float ear_relWidth = 0.075f;

        float square_width = min(rel_width*(float)win_width,
            rel_height*(float)win_height);  //choose smaller of the two

        float total_width = square_width;
        float total_height = square_width;
        float nose_width = total_width * nose_relWidth;
        float nose_height = total_height * nose_relLen;
        ear_width = (int)(ear_relWidth * total_width);
        ear_height = (int)(ear_relLen * total_height);
        int circ_width_foo = (int)(total_width - 2.f*((float)ear_width)/2.0f);
        int circ_height_foo = (int)(total_height - nose_height);
        circ_diam = min(circ_width_foo, circ_height_foo);

        //locations: circle center, measured from upper left
        circ_x = (int)((rel_posX+0.5f*rel_width)*(float)win_width);                  //center of head
        circ_y = (int)((rel_posY+0.5f*rel_height)*(float)win_height + nose_height);  //center of head

        //locations: ear centers, measured from upper left
        earL_x = circ_x - circ_diam/2;
        earR_x = circ_x + circ_diam/2;
        earL_y = circ_y;
        earR_y = circ_y;

        //locations nose vertexes, measured from upper left
        nose_x[0] = circ_x - (int)((nose_relWidth/2.f)*(float)win_width);
        nose_x[1] = circ_x + (int)((nose_relWidth/2.f)*(float)win_width);
        nose_x[2] = circ_x;
        nose_y[0] = circ_y - (int)((float)circ_diam/2.0f - nose_relGutter*(float)win_height);
        nose_y[1] = nose_y[0];
        nose_y[2] = circ_y - (int)((float)circ_diam/2.0f + nose_height);


        //define the electrode positions as the relative position [-1.0 +1.0] within the head
        //remember that negative "Y" is up and positive "Y" is down
        float elec_relDiam = 0.12f; //was 0.1425 prior to 2014-03-23
        elec_diam = (int)(elec_relDiam*((float)circ_diam));
        setElectrodeLocations(n_elec, elec_relDiam);

        //define image to hold all of this
        image_x = PApplet.parseInt(round(circ_x - 0.5f*circ_diam - 0.5f*ear_width));
        image_y = nose_y[2];
        headImage = createImage(PApplet.parseInt(total_width), PApplet.parseInt(total_height), ARGB);

        //initialize the image
        for (int Iy=0; Iy < headImage.height; Iy++) {
            for (int Ix = 0; Ix < headImage.width; Ix++) {
                headImage.set(Ix, Iy, WHITE);
            }
        }

        //define the weighting factors to go from the electrode voltages
        //outward to the full the contour plot
        if (false) {
            //here is a simple distance-based algorithm that works every time, though
            //is not really physically accurate.  It looks decent enough
            computePixelWeightingFactors();
        } else {
            //here is the better solution that is more physical.  It involves an iterative
            //solution, which could be really slow or could fail.  If it does poorly,
            //switch to using the algorithm above.
            int n_wide_full = PApplet.parseInt(total_width);
            int n_tall_full = PApplet.parseInt(total_height);
            computePixelWeightingFactors_multiScale(n_wide_full, n_tall_full);
        }
    } //end of method


    private void setElectrodeLocations(int n_elec, float elec_relDiam) {
        //try loading the positions from a file
        int n_elec_to_load = n_elec+1;  //load the n_elec plus the reference electrode
        Table elec_relXY = new Table();
        String default_fname = "electrode_positions_default.txt";
        //String default_fname = "electrode_positions_12elec_scalp9.txt";
        try {
            elec_relXY = loadTable(default_fname, "header,csv"); //try loading the default file
        }
        catch (NullPointerException e) {
        };

        //get the default locations if the file didn't exist
        if ((elec_relXY == null) || (elec_relXY.getRowCount() < n_elec_to_load)) {
            println("headPlot: electrode position file not found or was wrong size: " + default_fname);
            println("        : using defaults...");
            elec_relXY = createDefaultElectrodeLocations(default_fname, elec_relDiam);
        }

        //define the actual locations of the electrodes in pixels
        for (int i=0; i < min(electrode_xy.length, elec_relXY.getRowCount()); i++) {
            electrode_xy[i][0] = circ_x+(int)(elec_relXY.getFloat(i, 0)*((float)circ_diam));
            electrode_xy[i][1] = circ_y+(int)(elec_relXY.getFloat(i, 1)*((float)circ_diam));
        }

        //the referenece electrode is last in the file
        ref_electrode_xy[0] = circ_x+(int)(elec_relXY.getFloat(elec_relXY.getRowCount()-1, 0)*((float)circ_diam));
        ref_electrode_xy[1] = circ_y+(int)(elec_relXY.getFloat(elec_relXY.getRowCount()-1, 1)*((float)circ_diam));
    }

    private Table createDefaultElectrodeLocations(String fname, float elec_relDiam) {

        //regular electrodes
        float[][] elec_relXY = new float[16][2];
        elec_relXY[0][0] = -0.125f;
        elec_relXY[0][1] = -0.5f + elec_relDiam*(0.5f+0.2f); //FP1
        elec_relXY[1][0] = -elec_relXY[0][0];
        elec_relXY[1][1] = elec_relXY[0][1]; //FP2

        elec_relXY[2][0] = -0.2f;
        elec_relXY[2][1] = 0f; //C3
        elec_relXY[3][0] = -elec_relXY[2][0];
        elec_relXY[3][1] = elec_relXY[2][1]; //C4

        elec_relXY[4][0] = -0.3425f;
        elec_relXY[4][1] = 0.27f; //T5 (aka P7)
        elec_relXY[5][0] = -elec_relXY[4][0];
        elec_relXY[5][1] = elec_relXY[4][1]; //T6 (aka P8)

        elec_relXY[6][0] = -0.125f;
        elec_relXY[6][1] = +0.5f - elec_relDiam*(0.5f+0.2f); //O1
        elec_relXY[7][0] = -elec_relXY[6][0];
        elec_relXY[7][1] = elec_relXY[6][1];  //O2

        elec_relXY[8][0] = elec_relXY[4][0];
        elec_relXY[8][1] = -elec_relXY[4][1]; //F7
        elec_relXY[9][0] = -elec_relXY[8][0];
        elec_relXY[9][1] = elec_relXY[8][1]; //F8

        elec_relXY[10][0] = -0.18f;
        elec_relXY[10][1] = -0.15f; //C3
        elec_relXY[11][0] = -elec_relXY[10][0];
        elec_relXY[11][1] = elec_relXY[10][1]; //C4

        elec_relXY[12][0] =  -0.5f +elec_relDiam*(0.5f+0.15f);
        elec_relXY[12][1] = 0f; //T3 (aka T7?)
        elec_relXY[13][0] = -elec_relXY[12][0];
        elec_relXY[13][1] = elec_relXY[12][1]; //T4 (aka T8)

        elec_relXY[14][0] = elec_relXY[10][0];
        elec_relXY[14][1] = -elec_relXY[10][1]; //CP3
        elec_relXY[15][0] = -elec_relXY[14][0];
        elec_relXY[15][1] = elec_relXY[14][1]; //CP4

        //reference electrode
        float[] ref_elec_relXY = new float[2];
        ref_elec_relXY[0] = 0.0f;
        ref_elec_relXY[1] = 0.0f;

        //put it all into a table
        Table table_elec_relXY = new Table();
        table_elec_relXY.addColumn("X", Table.FLOAT);
        table_elec_relXY.addColumn("Y", Table.FLOAT);
        for (int I = 0; I < elec_relXY.length; I++) {
            table_elec_relXY.addRow();
            table_elec_relXY.setFloat(I, "X", elec_relXY[I][0]);
            table_elec_relXY.setFloat(I, "Y", elec_relXY[I][1]);
        }

        //last one is the reference electrode
        table_elec_relXY.addRow();
        table_elec_relXY.setFloat(table_elec_relXY.getRowCount()-1, "X", ref_elec_relXY[0]);
        table_elec_relXY.setFloat(table_elec_relXY.getRowCount()-1, "Y", ref_elec_relXY[1]);

        //try writing it to a file
        String full_fname = "Data\\" + fname;
        try {
            saveTable(table_elec_relXY, full_fname, "csv");
        }
        catch (NullPointerException e) {
            println("headPlot: createDefaultElectrodeLocations: could not write file to " + full_fname);
        };

        //return
        return table_elec_relXY;
    } //end of method

    //Here, we do a two-step solution to get the weighting factors.
    //We do a coarse grid first.  We do our iterative solution on the coarse grid.
    //Then, we formulate the full resolution fine grid.  We interpolate these points
    //from the data resulting from the coarse grid.
    private void computePixelWeightingFactors_multiScale(int n_wide_full, int n_tall_full) {
        int n_elec = electrode_xy.length;

        //define the coarse grid data structures and pixel locations
        int decimation = 10;
        int n_wide_small = n_wide_full / decimation + 1;
        int n_tall_small = n_tall_full / decimation + 1;
        float weightFac[][][] = new float[n_elec][n_wide_small][n_tall_small];
        int pixelAddress[][][] = new int[n_wide_small][n_tall_small][2];
        for (int Ix=0; Ix<n_wide_small; Ix++) {
            for (int Iy=0; Iy<n_tall_small; Iy++) {
                pixelAddress[Ix][Iy][0] = Ix*decimation;
                pixelAddress[Ix][Iy][1] = Iy*decimation;
            };
        };

        //compute the weighting factors of the coarse grid
        computePixelWeightingFactors_trueAverage(pixelAddress, weightFac);

        //define the fine grid data structures
        electrode_color_weightFac = new float[n_elec][n_wide_full][n_tall_full];
        headVoltage = new float[n_wide_full][n_tall_full];

        //interpolate to get the fine grid from the coarse grid
        float dx_frac, dy_frac;
        for (int Ix=0; Ix<n_wide_full; Ix++) {
            int Ix_source = Ix/decimation;
            dx_frac = PApplet.parseFloat(Ix - Ix_source*decimation)/PApplet.parseFloat(decimation);
            for (int Iy=0; Iy < n_tall_full; Iy++) {
                int Iy_source = Iy/decimation;
                dy_frac = PApplet.parseFloat(Iy - Iy_source*decimation)/PApplet.parseFloat(decimation);

                for (int Ielec=0; Ielec<n_elec; Ielec++) {
                    //println("    : Ielec = " + Ielec);
                    if ((Ix_source < (n_wide_small-1)) && (Iy_source < (n_tall_small-1))) {
                        //normal 2-D interpolation
                        electrode_color_weightFac[Ielec][Ix][Iy] = interpolate2D(weightFac[Ielec], Ix_source, Iy_source, Ix_source+1, Iy_source+1, dx_frac, dy_frac);
                    } else if (Ix_source < (n_wide_small-1)) {
                        //1-D interpolation in X
                        dy_frac = 0.0f;
                        electrode_color_weightFac[Ielec][Ix][Iy] = interpolate2D(weightFac[Ielec], Ix_source, Iy_source, Ix_source+1, Iy_source, dx_frac, dy_frac);
                    } else if (Iy_source < (n_tall_small-1)) {
                        //1-D interpolation in Y
                        dx_frac = 0.0f;
                        electrode_color_weightFac[Ielec][Ix][Iy] = interpolate2D(weightFac[Ielec], Ix_source, Iy_source, Ix_source, Iy_source+1, dx_frac, dy_frac);
                    } else {
                        //no interpolation, just use the last value
                        electrode_color_weightFac[Ielec][Ix][Iy] = weightFac[Ielec][Ix_source][Iy_source];
                    }  //close the if block selecting the interpolation configuration
                } //close Ielec loop
            } //close Iy loop
        } // close Ix loop

        //clean up the boundaries of our interpolated results to make the look nicer
        int pixelAddress_full[][][] = new int[n_wide_full][n_tall_full][2];
        for (int Ix=0; Ix<n_wide_full; Ix++) {
            for (int Iy=0; Iy<n_tall_full; Iy++) {
                pixelAddress_full[Ix][Iy][0] = Ix;
                pixelAddress_full[Ix][Iy][1] = Iy;
            };
        };
        cleanUpTheBoundaries(pixelAddress_full, electrode_color_weightFac);
    } //end of method


    private float interpolate2D(float[][] weightFac, int Ix1, int Iy1, int Ix2, int Iy2, float dx_frac, float dy_frac) {
        if (Ix1 >= weightFac.length) {
            println("headPlot: interpolate2D: Ix1 = " + Ix1 + ", weightFac.length = " + weightFac.length);
        }
        float foo1 = (weightFac[Ix2][Iy1] - weightFac[Ix1][Iy1])*dx_frac + weightFac[Ix1][Iy1];
        float foo2 = (weightFac[Ix2][Iy2] - weightFac[Ix1][Iy2])*dx_frac + weightFac[Ix1][Iy2];
        return (foo2 - foo1) * dy_frac + foo1;
    }


    //here is the simpler and more robust algorithm.  It's not necessarily physically real, though.
    //but, it will work every time.  So, if the other method fails, go with this one.
    private void computePixelWeightingFactors() {
        int n_elec = electrode_xy.length;
        float dist;
        int withinElecInd = -1;
        float elec_radius = 0.5f*elec_diam;
        int pixel_x, pixel_y;
        float sum_weight_fac = 0.0f;
        float weight_fac[] = new float[n_elec];
        float foo_dist;

        //loop over each pixel
        for (int Iy=0; Iy < headImage.height; Iy++) {
            pixel_y = image_y + Iy;
            for (int Ix = 0; Ix < headImage.width; Ix++) {
                pixel_x = image_x + Ix;

                if (isPixelInsideHead(pixel_x, pixel_y)==false) {
                    for (int Ielec=0; Ielec < n_elec; Ielec++) {
                        //outside of head...no color from electrodes
                        electrode_color_weightFac[Ielec][Ix][Iy]= -1.0f; //a negative value will be a flag that it is outside of the head
                    }
                } else {
                    //inside of head, compute weighting factors

                    //compute distances of this pixel to each electrode
                    sum_weight_fac = 0.0f; //reset for this pixel
                    withinElecInd = -1;    //reset for this pixel
                    for (int Ielec=0; Ielec < n_elec; Ielec++) {
                        //compute distance
                        dist = max(1.0f, calcDistance(pixel_x, pixel_y, electrode_xy[Ielec][0], electrode_xy[Ielec][1]));
                        if (dist < elec_radius) withinElecInd = Ielec;

                        //compute the first part of the weighting factor
                        foo_dist = max(1.0f, abs(dist - elec_radius));  //remove radius of the electrode
                        weight_fac[Ielec] = 1.0f/foo_dist;  //arbitrarily chosen
                        weight_fac[Ielec] = weight_fac[Ielec]*weight_fac[Ielec]*weight_fac[Ielec];  //again, arbitrary
                        sum_weight_fac += weight_fac[Ielec];
                    }

                    //finalize the weight factor
                    for (int Ielec=0; Ielec < n_elec; Ielec++) {
                        //is this pixel within an electrode?
                        if (withinElecInd > -1) {
                            //yes, it is within an electrode
                            if (Ielec == withinElecInd) {
                                //use this signal electrode as the color
                                electrode_color_weightFac[Ielec][Ix][Iy] = 1.0f;
                            } else {
                                //ignore all other electrodes
                                electrode_color_weightFac[Ielec][Ix][Iy] = 0.0f;
                            }
                        } else {
                            //no, this pixel is not in an electrode.  So, use the distance-based weight factor,
                            //after dividing by the sum of the weight factors, resulting in an averaging operation
                            electrode_color_weightFac[Ielec][Ix][Iy] = weight_fac[Ielec]/sum_weight_fac;
                        }
                    }
                }
            }
        }
    } //end of method

    public void computePixelWeightingFactors_trueAverage(int pixelAddress[][][], float weightFac[][][]) {
        int n_wide = pixelAddress.length;
        int n_tall = pixelAddress[0].length;
        int n_elec = electrode_xy.length;
        int withinElectrode[][] = new int[n_wide][n_tall]; //which electrode is this pixel within (-1 means that it is not within any electrode)
        boolean withinHead[][] = new boolean[n_wide][n_tall]; //is the pixel within the head?
        int toPixels[][][][] = new int[n_wide][n_tall][4][2];
        int toElectrodes[][][] = new int[n_wide][n_tall][4];
        //int numConnections[][] = new int[n_wide][n_tall];
        // println("  HeadPlot B 2 0 -- " + millis());

        //find which pixesl are within the head and which pixels are within an electrode
        whereAreThePixels(pixelAddress, withinHead, withinElectrode);
        // println("  HeadPlot B 2 1 -- " + millis());

        //loop over the pixels and make all the connections
        makeAllTheConnections(withinHead, withinElectrode, toPixels, toElectrodes);
        // println("  HeadPlot B 2 3 -- " + millis());

        //compute the pixel values when lighting up each electrode invididually
        for (int Ielec=0; Ielec<n_elec; Ielec++) {
            computeWeightFactorsGivenOneElectrode_iterative(toPixels, toElectrodes, Ielec, weightFac);
        }
        // println("  HeadPlot B 2 4 -- " + millis());

    }

    private void cleanUpTheBoundaries(int pixelAddress[][][], float weightFac[][][]) {
        int n_wide = pixelAddress.length;
        int n_tall = pixelAddress[0].length;
        int n_elec = electrode_xy.length;
        int withinElectrode[][] = new int[n_wide][n_tall]; //which electrode is this pixel within (-1 means that it is not within any electrode)
        boolean withinHead[][] = new boolean[n_wide][n_tall]; //is the pixel within the head?

        //find which pixels are within the head and which pixels are within an electrode
        whereAreThePixels(pixelAddress, withinHead, withinElectrode);

        //loop over the pixels and change the weightFac to reflext where it is
        for (int Ix=0; Ix<n_wide; Ix++) {
            for (int Iy=0; Iy<n_tall; Iy++) {
                if (withinHead[Ix][Iy]==false) {
                    //this pixel is outside of the head
                    for (int Ielec=0; Ielec<n_elec; Ielec++) {
                        weightFac[Ielec][Ix][Iy]=-1.0f;  //this means to ignore this weight
                    }
                } else {
                    //we are within the head...there are a couple of things to clean up

                    //first, is this a legit value?  It should be >= 0.0.  If it isn't, it was a
                    //quantization problem.  let's clean it up.
                    for (int Ielec=0; Ielec<n_elec; Ielec++) {
                        if (weightFac[Ielec][Ix][Iy] < 0.0f) {
                            weightFac[Ielec][Ix][Iy] = getClosestWeightFac(weightFac[Ielec], Ix, Iy);
                        }
                    }

                    //next, is our pixel within an electrode.  If so, ensure it's weights
                    //set the value to be the same as the electrode
                    if (withinElectrode[Ix][Iy] > -1) {
                        //we are!  set the weightFac to reflect this electrode only
                        for (int Ielec=0; Ielec<n_elec; Ielec++) {
                            weightFac[Ielec][Ix][Iy] = 0.0f; //ignore all other electrodes
                            if (Ielec == withinElectrode[Ix][Iy]) {
                                weightFac[Ielec][Ix][Iy] = 1.0f;  //become equal to this electrode
                            }
                        }
                    } //close "if within electrode"
                } //close "if within head"
            } //close Iy
        } // close Ix
    } //close method

    //find the closest legitimate weightFac
    private float getClosestWeightFac(float weightFac[][], int Ix, int Iy) {
        int n_wide = weightFac.length;
        int n_tall = weightFac[0].length;
        float sum = 0.0f;
        int n_sum = 0;
        float new_weightFac=-1.0f;


        int step = 1;
        int Ix_test, Iy_test;
        boolean done = false;
        boolean anyWithinBounds;
        while (!done) {
            anyWithinBounds = false;

            //search the perimeter at this distance
            sum = 0.0f;
            n_sum = 0;

            //along the top
            Iy_test = Iy + step;
            if ((Iy_test >= 0) && (Iy_test < n_tall)) {
                for (Ix_test=Ix-step; Ix_test<=Ix+step; Ix_test++) {
                    if ((Ix_test >=0) && (Ix_test < n_wide)) {
                        anyWithinBounds=true;
                        if (weightFac[Ix_test][Iy_test] >= 0.0f) {
                            sum += weightFac[Ix_test][Iy_test];
                            n_sum++;
                        }
                    }
                }
            }

            //along the right
            Ix_test = Ix + step;
            if ((Ix_test >= 0) && (Ix_test < n_wide)) {
                for (Iy_test=Iy-step; Iy_test<=Iy+step; Iy_test++) {
                    if ((Iy_test >=0) && (Iy_test < n_tall)) {
                        anyWithinBounds=true;
                        if (weightFac[Ix_test][Iy_test] >= 0.0f) {
                            sum += weightFac[Ix_test][Iy_test];
                            n_sum++;
                        }
                    }
                }
            }
            //along the bottom
            Iy_test = Iy - step;
            if ((Iy_test >= 0) && (Iy_test < n_tall)) {
                for (Ix_test=Ix-step; Ix_test<=Ix+step; Ix_test++) {
                    if ((Ix_test >=0) && (Ix_test < n_wide)) {
                        anyWithinBounds=true;
                        if (weightFac[Ix_test][Iy_test] >= 0.0f) {
                            sum += weightFac[Ix_test][Iy_test];
                            n_sum++;
                        }
                    }
                }
            }

            //along the left
            Ix_test = Ix - step;
            if ((Ix_test >= 0) && (Ix_test < n_wide)) {
                for (Iy_test=Iy-step; Iy_test<=Iy+step; Iy_test++) {
                    if ((Iy_test >=0) && (Iy_test < n_tall)) {
                        anyWithinBounds=true;
                        if (weightFac[Ix_test][Iy_test] >= 0.0f) {
                            sum += weightFac[Ix_test][Iy_test];
                            n_sum++;
                        }
                    }
                }
            }

            if (n_sum > 0) {
                //some good pixels were found, so we have our answer
                new_weightFac = sum / n_sum; //complete the averaging process
                done = true; //we're done
            } else {
                //we did not find any good pixels.  Step outward one more pixel and repeat the search
                step++;  //step outwward
                if (anyWithinBounds) {  //did the last iteration have some pixels that were at least within the domain
                    //some pixels were within the domain, so we have space to try again
                    done = false;
                } else {
                    //no pixels were within the domain.  We're out of space.  We're done.
                    done = true;
                }
            }
        }
        return new_weightFac; //good or bad, return our new value
    }

    private void computeWeightFactorsGivenOneElectrode_iterative(int toPixels[][][][], int toElectrodes[][][], int Ielec, float pixelVal[][][]) {
        //Approach: pretend that one electrode is set to 1.0 and that all other electrodes are set to 0.0.
        //Assume all of the pixels start at zero.  Then, begin the simulation as if it were a transient
        //solution where energy is coming in from the connections.  Any excess energy will accumulate
        //and cause the local pixel's value to increase.  Iterate until the pixel values stabalize.

        int n_wide = toPixels.length;
        int n_tall = toPixels[0].length;
        int n_dir = toPixels[0][0].length;
        float prevVal[][] = new float[n_wide][n_tall];
        float total, dVal;
        int Ix_targ, Iy_targ;
        float min_val=0.0f, max_val=0.0f;
        boolean anyConnections = false;
        int pixel_step = 1;

        //initialize all pixels to zero
        //for (int Ix=0; Ix<n_wide;Ix++) { for (int Iy=0; Iy<n_tall;Iy++) { pixelVal[Ielec][Ix][Iy]=0.0f; }; };

        //define the iteration limits
        int lim_iter_count = 2000;  //set to something big enough to get the job done, but not so big that it could take forever
        float dVal_threshold = 0.00001f;  //set to something arbitrarily small
        float change_fac = 0.2f; //must be small enough to keep this iterative solution stable.  Goes unstable above 0.25

        //begin iteration
        int iter_count = 0;
        float max_dVal = 10.0f*dVal_threshold;  //initilize to large value to ensure that it starts
        while ((iter_count < lim_iter_count) && (max_dVal > dVal_threshold)) {
            //increment the counter
            iter_count++;

            //reset our test value to a large value
            max_dVal = 0.0f;

            //reset other values that I'm using for debugging
            min_val = 1000.0f; //init to a big val
            max_val = -1000.f; //init to a small val

            //copy current values
            for (int Ix=0; Ix<n_wide; Ix++) {
                for (int Iy=0; Iy<n_tall; Iy++) {
                    prevVal[Ix][Iy]=pixelVal[Ielec][Ix][Iy];
                };
            };

            //compute the new pixel values
            for (int Ix=0; Ix<n_wide; Ix+=pixel_step) {
                for (int Iy=0; Iy<n_tall; Iy+=pixel_step) {
                    //reset variables related to this one pixel
                    total=0.0f;
                    anyConnections = false;

                    for (int Idir=0; Idir<n_dir; Idir++) {
                        //do we connect to a real pixel?
                        if (toPixels[Ix][Iy][Idir][0] > -1) {
                            Ix_targ = toPixels[Ix][Iy][Idir][0];  //x index of target pixel
                            Iy_targ = toPixels[Ix][Iy][Idir][1];  //y index of target pixel
                            total += (prevVal[Ix_targ][Iy_targ]-prevVal[Ix][Iy]);  //difference relative to target pixel
                            anyConnections = true;
                        }
                        //do we connect to an electrode?
                        if (toElectrodes[Ix][Iy][Idir] > -1) {
                            //do we connect to the electrode that we're stimulating
                            if (toElectrodes[Ix][Iy][Idir] == Ielec) {
                                //yes, this is the active high one
                                total += (1.0f-prevVal[Ix][Iy]);  //difference relative to HIGH electrode
                            } else {
                                //no, this is a low one
                                total += (0.0f-prevVal[Ix][Iy]);  //difference relative to the LOW electrode
                            }
                            anyConnections = true;
                        }
                    }

                    //compute the new pixel value
                    //if (numConnections[Ix][Iy] > 0) {
                    if (anyConnections) {

                        //dVal = change_fac * (total - float(numConnections[Ix][Iy])*prevVal[Ix][Iy]);
                        dVal = change_fac * total;
                        pixelVal[Ielec][Ix][Iy] = prevVal[Ix][Iy] + dVal;

                        //is this our worst change in value?
                        max_dVal = max(max_dVal, abs(dVal));

                        //update our other debugging values, too
                        min_val = min(min_val, pixelVal[Ielec][Ix][Iy]);
                        max_val = max(max_val, pixelVal[Ielec][Ix][Iy]);
                    } else {
                        pixelVal[Ielec][Ix][Iy] = -1.0f; //means that there are no connections
                    }
                }
            }
            //println("headPlot: computeWeightFactor: Ielec " + Ielec + ", iter = " + iter_count + ", max_dVal = " + max_dVal);
        }
        //println("headPlot: computeWeightFactor: Ielec " + Ielec + ", solution complete with " + iter_count + " iterations. min and max vals = " + min_val + ", " + max_val);
        if (iter_count >= lim_iter_count) println("headPlot: computeWeightFactor: Ielec " + Ielec + ", solution complete with " + iter_count + " iterations. max_dVal = " + max_dVal);
    } //end of method

    private void makeAllTheConnections(boolean withinHead[][], int withinElectrode[][], int toPixels[][][][], int toElectrodes[][][]) {

        int n_wide = toPixels.length;
        int n_tall = toPixels[0].length;
        int n_elec = electrode_xy.length;
        int curPixel, Ipix, Ielec;
        int n_pixels = n_wide * n_tall;
        int Ix_try, Iy_try;

        //loop over every pixel in the image
        for (int Iy=0; Iy < n_tall; Iy++) {
            for (int Ix=0; Ix < n_wide; Ix++) {

                //loop over the four connections: left, right, up, down
                for (int Idirection = 0; Idirection < 4; Idirection++) {

                    Ix_try = -1;
                    Iy_try=-1; //nonsense values
                    switch (Idirection) {
                    case 0:
                        Ix_try = Ix-1;
                        Iy_try = Iy; //left
                        break;
                    case 1:
                        Ix_try = Ix+1;
                        Iy_try = Iy; //right
                        break;
                    case 2:
                        Ix_try = Ix;
                        Iy_try = Iy-1; //up
                        break;
                    case 3:
                        Ix_try = Ix;
                        Iy_try = Iy+1; //down
                        break;
                    }

                    //initalize to no connection
                    toPixels[Ix][Iy][Idirection][0] = -1;
                    toPixels[Ix][Iy][Idirection][1] = -1;
                    toElectrodes[Ix][Iy][Idirection] = -1;

                    //does the target pixel exist
                    if ((Ix_try >= 0) && (Ix_try < n_wide)  && (Iy_try >= 0) && (Iy_try < n_tall)) {
                        //is the target pixel an electrode
                        if (withinElectrode[Ix_try][Iy_try] >= 0) {
                            //the target pixel is within an electrode
                            toElectrodes[Ix][Iy][Idirection] = withinElectrode[Ix_try][Iy_try];
                        } else {
                            //the target pixel is not within an electrode.  is it within the head?
                            if (withinHead[Ix_try][Iy_try]) {
                                toPixels[Ix][Iy][Idirection][0] = Ix_try; //save the address of the target pixel
                                toPixels[Ix][Iy][Idirection][1] = Iy_try; //save the address of the target pixel
                            }
                        }
                    }
                } //end loop over direction of the target pixel
            } //end loop over Ix
        } //end loop over Iy
    } // end of method

    private void whereAreThePixels(int pixelAddress[][][], boolean[][] withinHead, int[][] withinElectrode) {
        int n_wide = pixelAddress.length;
        int n_tall = pixelAddress[0].length;
        int n_elec = electrode_xy.length;
        int pixel_x, pixel_y;
        int withinElecInd=-1;
        float dist;
        float elec_radius = 0.5f*elec_diam;

        for (int Iy=0; Iy < n_tall; Iy++) {
            //pixel_y = image_y + Iy;
            for (int Ix = 0; Ix < n_wide; Ix++) {
                //pixel_x = image_x + Ix;

                pixel_x = pixelAddress[Ix][Iy][0]+image_x;
                pixel_y = pixelAddress[Ix][Iy][1]+image_y;

                //is it within the head
                withinHead[Ix][Iy] = isPixelInsideHead(pixel_x, pixel_y);

                //compute distances of this pixel to each electrode
                withinElecInd = -1;    //reset for this pixel
                for (int Ielec=0; Ielec < n_elec; Ielec++) {
                    //compute distance
                    dist = max(1.0f, calcDistance(pixel_x, pixel_y, electrode_xy[Ielec][0], electrode_xy[Ielec][1]));
                    if (dist < elec_radius) withinElecInd = Ielec;
                }
                withinElectrode[Ix][Iy] = withinElecInd;  //-1 means not inside an electrode
            } //close Ix loop
        } //close Iy loop

        //ensure that each electrode is at at least one pixel
        for (int Ielec=0; Ielec<n_elec; Ielec++) {
            //find closest pixel
            float min_dist = 1.0e10f;  //some huge number
            int best_Ix=0, best_Iy=0;
            for (int Iy=0; Iy < n_tall; Iy++) {
                //pixel_y = image_y + Iy;
                for (int Ix = 0; Ix < n_wide; Ix++) {
                    //pixel_x = image_x + Ix;

                    pixel_x = pixelAddress[Ix][Iy][0]+image_x;
                    pixel_y = pixelAddress[Ix][Iy][1]+image_y;

                    dist = calcDistance(pixel_x, pixel_y, electrode_xy[Ielec][0], electrode_xy[Ielec][1]);
                    ;

                    if (dist < min_dist) {
                        min_dist = dist;
                        best_Ix = Ix;
                        best_Iy = Iy;
                    }
                } //close Iy loop
            } //close Ix loop

            //define this closest point to be within the electrode
            withinElectrode[best_Ix][best_Iy] = Ielec;
        } //close Ielec loop
    } //close method


    //step through pixel-by-pixel to update the image
    private void updateHeadImage() {
        for (int Iy=0; Iy < headImage.height; Iy++) {
            for (int Ix = 0; Ix < headImage.width; Ix++) {
                //is this pixel inside the head?
                if (electrode_color_weightFac[0][Ix][Iy] >= 0.0f) { //zero and positive values are inside the head
                    //it is inside the head.  set the color based on the electrodes
                    headImage.set(Ix, Iy, calcPixelColor(Ix, Iy));
                } else {  //negative values are outside of the head
                    //pixel is outside the head.  set to black.
                    headImage.set(Ix, Iy, WHITE);
                }
            }
        }
    }

    private void convertVoltagesToHeadImage() {
        for (int Iy=0; Iy < headImage.height; Iy++) {
            for (int Ix = 0; Ix < headImage.width; Ix++) {
                //is this pixel inside the head?
                if (electrode_color_weightFac[0][Ix][Iy] >= 0.0f) { //zero and positive values are inside the head
                    //it is inside the head.  set the color based on the electrodes
                    headVoltage[Ix][Iy] = calcPixelVoltage(Ix, Iy, headVoltage[Ix][Iy]);
                    headImage.set(Ix, Iy, calcPixelColor(headVoltage[Ix][Iy]));
                } else {  //negative values are outside of the head
                    //pixel is outside the head.  set to black.
                    headVoltage[Ix][Iy] = -1.0f;
                    headImage.set(Ix, Iy, WHITE);
                }
            }
        }
    }

    private float calcPixelVoltage(int pixel_Ix, int pixel_Iy, float prev_val) {
        float weight, elec_volt;
        int n_elec = electrode_xy.length;
        float voltage = 0.0f;
        float low = intense_min_uV;
        float high = intense_max_uV;

        for (int Ielec=0; Ielec<n_elec; Ielec++) {
            weight = electrode_color_weightFac[Ielec][pixel_Ix][pixel_Iy];
            elec_volt = max(low, min(intensity_data_uV[Ielec], high));

            if (use_polarity) elec_volt = elec_volt*polarity_data[Ielec];

            if (is_railed[Ielec].is_railed) elec_volt = assumed_railed_voltage_uV;
            voltage += weight*elec_volt;
        }

        //smooth in time
        if (smooth_fac > 0.0f) voltage = smooth_fac*prev_val + (1.0f-smooth_fac)*voltage;

        return voltage;
    }


    private int calcPixelColor(float pixel_volt_uV) {
        // float new_rgb[] = {255.0, 0.0, 0.0}; //init to red
        //224, 56, 45
        float new_rgb[] = {224.0f, 56.0f, 45.0f}; //init to red
        // float new_rgb[] = {0.0, 255.0, 0.0}; //init to red
        //54, 87, 158
        if (pixel_volt_uV < 0.0f) {
            //init to blue instead
            new_rgb[0]=54.0f;
            new_rgb[1]=87.0f;
            new_rgb[2]=158.0f;
            // new_rgb[0]=0.0;
            // new_rgb[1]=0.0;
            // new_rgb[2]=255.0;
        }
        float val;


        float intensity = constrain(abs(pixel_volt_uV), intense_min_uV, intense_max_uV);
        if (plot_color_as_log) {
            intensity = map(log10(intensity),
                log10_intense_min_uV,
                log10_intense_max_uV,
                0.0f, 1.0f);
        } else {
            intensity = map(intensity,
                intense_min_uV,
                intense_max_uV,
                0.0f, 1.0f);
        }

        //make the intensity fade NOT from black->color, but from white->color
        for (int i=0; i < 3; i++) {
            val = ((float)new_rgb[i]) / 255.f;
            new_rgb[i] = ((val + (1.0f - val)*(1.0f-intensity))*255.f); //adds in white at low intensity.  no white at high intensity
            new_rgb[i] = constrain(new_rgb[i], 0.0f, 255.0f);
        }

        //quantize the color to make contour-style plot?
        if (true) quantizeColor(new_rgb);

        return color(PApplet.parseInt(new_rgb[0]), PApplet.parseInt(new_rgb[1]), PApplet.parseInt(new_rgb[2]), 255);
    }

    private void quantizeColor(float new_rgb[]) {
        int n_colors = 12;
        int ticks_per_color = 256 / (n_colors+1);
        for (int Irgb=0; Irgb<3; Irgb++) new_rgb[Irgb] = min(255.0f, PApplet.parseFloat(PApplet.parseInt(new_rgb[Irgb]/ticks_per_color))*ticks_per_color);
    }


    //compute the color of the pixel given the location
    private int calcPixelColor(int pixel_Ix, int pixel_Iy) {
        float weight;

        //compute the weighted average using the precomputed factors
        float new_rgb[] = {0.0f, 0.0f, 0.0f}; //init to zeros
        for (int Ielec=0; Ielec < electrode_xy.length; Ielec++) {
            //int Ielec = 0;
            weight = electrode_color_weightFac[Ielec][pixel_Ix][pixel_Iy];
            for (int Irgb=0; Irgb<3; Irgb++) {
                new_rgb[Irgb] += weight*electrode_rgb[Irgb][Ielec];
            }
        }

        //quantize the color to make contour-style plot?
        if (true) quantizeColor(new_rgb);

        return color(PApplet.parseInt(new_rgb[0]), PApplet.parseInt(new_rgb[1]), PApplet.parseInt(new_rgb[2]), 255);
    }

    private float calcDistance(int x, int y, float ref_x, float ref_y) {
        float dx = PApplet.parseFloat(x) - ref_x;
        float dy = PApplet.parseFloat(y) - ref_y;
        return sqrt(dx*dx + dy*dy);
    }

    //compute color for the electrode value
    private void updateElectrodeColors() {
        int rgb[] = new int[]{255, 0, 0}; //color for the electrode when fully light
        float intensity;
        float val;
        int new_rgb[] = new int[3];
        float low = intense_min_uV;
        float high = intense_max_uV;
        float log_low = log10_intense_min_uV;
        float log_high = log10_intense_max_uV;
        for (int Ielec=0; Ielec < electrode_xy.length; Ielec++) {
            intensity = constrain(intensity_data_uV[Ielec], low, high);
            if (plot_color_as_log) {
                intensity = map(log10(intensity), log_low, log_high, 0.0f, 1.0f);
            } else {
                intensity = map(intensity, low, high, 0.0f, 1.0f);
            }

            //make the intensity fade NOT from black->color, but from white->color
            for (int i=0; i < 3; i++) {
                val = ((float)rgb[i]) / 255.f;
                new_rgb[i] = (int)((val + (1.0f - val)*(1.0f-intensity))*255.f); //adds in white at low intensity.  no white at high intensity
                new_rgb[i] = constrain(new_rgb[i], 0, 255);
            }

            //change color to dark RED if railed
            if (is_railed[Ielec].is_railed)  new_rgb = new int[]{127, 0, 0};

            //set the electrode color
            electrode_rgb[0][Ielec] = new_rgb[0];
            electrode_rgb[1][Ielec] = new_rgb[1];
            electrode_rgb[2][Ielec] = new_rgb[2];
        }
    }

    private boolean isMouseOverElectrode(int n){
        float elec_mouse_x_dist = electrode_xy[n][0] - mouseX;
        float elec_mouse_y_dist = electrode_xy[n][1] - mouseY;
        return elec_mouse_x_dist * elec_mouse_x_dist + elec_mouse_y_dist * elec_mouse_y_dist < elec_diam * elec_diam / 4;
    }

    private boolean isDraggedElecInsideHead() {
        int dx = mouseX - circ_x;
        int dy = mouseY - circ_y;
        return dx * dx + dy * dy < (circ_diam - elec_diam) * (circ_diam - elec_diam) / 4;
    }

    public void mousePressed() {
        if (mouse_over_elec_index > -1) {
            isDragging = true;
            drag_x = mouseX - electrode_xy[mouse_over_elec_index][0];
            drag_y = mouseY - electrode_xy[mouse_over_elec_index][1];
        } else {
            isDragging = false;
        }
    }

    public void mouseDragged() {
        if (isDragging && mouse_over_elec_index > -1 && isDraggedElecInsideHead()) {
            electrode_xy[mouse_over_elec_index][0] = mouseX - drag_x;
            electrode_xy[mouse_over_elec_index][1] = mouseY - drag_y;
        }
    }

    public void mouseReleased() {
        isDragging = false;
    }

    public boolean isPixelInsideHead(int pixel_x, int pixel_y) {
        int dx = pixel_x - circ_x;
        int dy = pixel_y - circ_y;
        float r = sqrt(PApplet.parseFloat(dx*dx) + PApplet.parseFloat(dy*dy));
        if (r <= 0.5f*circ_diam) {
            return true;
        } else {
            return false;
        }
    }

    public void update() {
        //do this when new data is available
        if (!hardCalcsDone) {
            thread("doHardCalcs");
        }

        //update electrode colors
        updateElectrodeColors();

        if (false) {
            //update the head image
            if (drawHeadAsContours) updateHeadImage();
        } else {
            //update head voltages
            if (!threadLock && hardCalcsDone) {
                convertVoltagesToHeadImage();
            }
        }
    }

    public void draw() {

        if (!hardCalcsDone) {
            return;
        }

        pushStyle();
        smooth();
        //draw head parts
        fill(WHITE);
        stroke(GREY_125);
        triangle(nose_x[0], nose_y[0], nose_x[1], nose_y[1], nose_x[2], nose_y[2]);  //nose
        ellipse(earL_x, earL_y, ear_width, ear_height); //little circle for the ear
        ellipse(earR_x, earR_y, ear_width, ear_height); //little circle for the ear

        //draw head itself
        fill(WHITE);  //fill in a white head
        strokeWeight(1);
        ellipse(circ_x, circ_y, circ_diam, circ_diam); //big circle for the head
        if (drawHeadAsContours) {
            //add the contnours
            image(headImage, image_x, image_y);
            noFill(); //overlay a circle as an outline, but no fill
            strokeWeight(1);
            ellipse(circ_x, circ_y, circ_diam, circ_diam); //big circle for the head
        }

        //draw electrodes on the head
        if (!isDragging) {
            mouse_over_elec_index = -1;
        }
        for (int Ielec=0; Ielec < electrode_xy.length; Ielec++) {
            if (drawHeadAsContours) {
                noFill(); //make transparent to allow color to come through from below
            } else {
                fill(electrode_rgb[0][Ielec], electrode_rgb[1][Ielec], electrode_rgb[2][Ielec]);
            }
            if (!isDragging && isMouseOverElectrode(Ielec)) {
                //electrode with a bigger index gets priority in dragging
                mouse_over_elec_index = Ielec;
                strokeWeight(2);
            } else if (mouse_over_elec_index == Ielec) {
                strokeWeight(2);
            } else{
                strokeWeight(1);
            }
            ellipse(electrode_xy[Ielec][0], electrode_xy[Ielec][1], elec_diam, elec_diam); //electrode circle
        }

        //add labels to electrodes
        fill(OPENBCI_DARKBLUE);
        textFont(font);
        textAlign(CENTER, CENTER);
        for (int i=0; i < electrode_xy.length; i++) {
            //text(Integer.toString(i),electrode_xy[i][0], electrode_xy[i][1]);
            text(i+1, electrode_xy[i][0], electrode_xy[i][1]);
        }
        text("R", ref_electrode_xy[0], ref_electrode_xy[1]);

        popStyle();
    } //end of draw method
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    W_Networking.pde (Networking Widget)                                   //
//                                                                           //            
//    This widget provides networking capabilities in the OpenBCI GUI.       //
//    The networking protocols can be used for outputting data               //
//    from the OpenBCI GUI to any program that can receive UDP, OSC,         //
//    or LSL input, such as Matlab, MaxMSP, Python, C/C++, etc.              //
//                                                                           //
//    The protocols included are: UDP, OSC, and LSL.                         //
//                                                                           //
//                                                                           //
//    Created by: Gabriel Ibagon (github.com/gabrielibagon), January 2017    //
//    Refactored: Richard Waltman, June 2023                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



class W_Networking extends Widget {

    /* Variables for protocol selection */
    public int protocolIndex;
    public String protocolMode;

    /* Widget CP5 */
    public ControlP5 cp5_networking;
    public ControlP5 cp5_networking_dropdowns;
    public ControlP5 cp5_networking_baudRate;
    public ControlP5 cp5_networking_portName;

    /* UI Organization */
    /* Widget grid */
    private int column0, column1, column2, column3, column4;
    private int fullColumnWidth;
    private int halfWidth;
    private int row0, row1, row2, row3, row4, row5;
    private int itemWidth = 96;
    private final float datatypeDropdownScaling = .45f;

    /* UI */
    private Boolean osc_visible;
    private Boolean udp_visible;
    private Boolean lsl_visible;
    private Boolean serial_visible;

    private Boolean cp5ElementsAreActive = false;
    private Boolean previousCP5State = false;
    private Button startButton;
    private Button guideButton;
    private Button dataOutputsButton;

    /* Networking */
    private Boolean networkActive;

    /* Streams Objects */
    private Stream stream1;
    private Stream stream2;
    private Stream stream3;
    private Stream stream4;

    private List<String> serialNetworkingComPorts;
    private int comPortToSave;
    private String defaultBaud;

    public LinkedList<String> protocols = new LinkedList<String>(Arrays.asList("UDP", "LSL", "OSC", "Serial"));
    public LinkedList<String> dataTypes = new LinkedList<String>(Arrays.asList("None", "Focus", "EMGJoystick", "AvgBandPower",
            "TimeSeriesFilt", "TimeSeriesRaw", "EMG", "Accel/Aux", "Pulse", "BandPower", "FFT"));
    public LinkedList<String> baudRates = new LinkedList<String>(Arrays.asList("57600", "115200", "250000", "500000"));
    public LinkedList<String> dataTypeNames = new LinkedList<String>(
            Arrays.asList("dataType1", "dataType2", "dataType3", "dataType4"));

    private String[] oscTextFieldNames = { "OSC_ip1", "OSC_port1", "OSC_ip2", "OSC_port2",
            "OSC_ip3", "OSC_port3", "OSC_ip4", "OSC_port4" };
    private String[] oscTextDefaultVals = { "127.0.0.1", "12345", "127.0.0.1", "12346", "127.0.0.1",
            "12347", "127.0.0.1", "12348" };
    private String[] udpTextFieldNames = { "UDP_ip1", "UDP_port1", "UDP_ip2", "UDP_port2", "UDP_ip3", "UDP_port3" };
    private String[] udpTextDefaultVals = { "127.0.0.1", "12345", "127.0.0.1", "12346", "127.0.0.1", "12347", "127.0.0.1",
            "12348" };
    private String[] lslTextFieldNames = { "LSL_name1", "LSL_type1", "LSL_name2", "LSL_type2", "LSL_name3", "LSL_type3" };
    private String[] lslTextDefaultVals = { "obci_eeg1", "EEG", "obci_eeg2", "EEG", "obci_eeg3", "EEG" };
    private final String NETWORKING_GUIDE_URL = "https://docs.openbci.com/Software/OpenBCISoftware/GUIWidgets/#networking";
    private final String NETWORKING_DATA_OUTPUTS_URL = "https://docs.google.com/document/d/e/2PACX-1vR_4DXPTh1nuiOwWKwIZN3NkGP3kRwpP4Hu6fQmy3jRAOaydOuEI1jket6V4V6PG4yIG15H1N7oFfdV/pub";
    private boolean configIsVisible = false;
    private boolean layoutIsVisible = false;

    private LinkedList<double[]> dataAccumulationQueue;
    private LinkedList<float[]> dataAccumulationQueueFiltered;
    public float[][] dataBufferToSend;
    public float[][] dataBufferToSend_Filtered;
    public AtomicBoolean[] networkingFrameLocks = new AtomicBoolean[4];
    public AtomicBoolean newTimeSeriesDataToSend = new AtomicBoolean(false);
    public AtomicBoolean newTimeSeriesDataToSendFiltered = new AtomicBoolean(false);

    public HashMap<String, Object> cp5Map = new HashMap<String, Object>();

    private List<controlP5.Controller> cp5ElementsToCheck;

    W_Networking(PApplet _parent) {
        super(_parent);
        // ourApplet = _parent;

        networkActive = false;
        stream1 = null;
        stream2 = null;
        stream3 = null;
        stream4 = null;

        networkingFrameLocks[0] = new AtomicBoolean(false);
        networkingFrameLocks[1] = new AtomicBoolean(false);
        networkingFrameLocks[2] = new AtomicBoolean(false);
        networkingFrameLocks[3] = new AtomicBoolean(false);

        // default data types for streams 1-4 in Networking widget
        settings.nwDataType1 = 0;
        settings.nwDataType2 = 0;
        settings.nwDataType3 = 0;
        settings.nwDataType4 = 0;
        settings.nwSerialPort = "None";
        settings.nwProtocolSave = protocolIndex;
                                                 
        // Only show pulse data type when using Cyton in Live
        if (eegDataSource != DATASOURCE_CYTON) {
            dataTypes.remove("Pulse");
        }
        
        protocolMode = "UDP"; // Set Default to UDP
        protocolIndex = 0; // Set Default to UDP
        addDropdown("Protocol", "Protocol", protocols, protocolIndex);
        serialNetworkingComPorts = new ArrayList<String>(getComPorts());
        defaultBaud = "57600";
        verbosePrint("serialNetworkingComPorts = " + serialNetworkingComPorts);
        comPortToSave = 0;

        initialize_UI();

        putCP5DataIntoMap();

        dataBufferToSend = new float[currentBoard.getNumEXGChannels()][nPointsPerUpdate];
        dataAccumulationQueue = new LinkedList<double[]>();
        dataBufferToSend_Filtered = new float[currentBoard.getNumEXGChannels()][nPointsPerUpdate];
        dataAccumulationQueueFiltered = new LinkedList<float[]>();

        cp5ElementsToCheck = new ArrayList<controlP5.Controller>();
        cp5ElementsToCheck.add((controlP5.Controller) guideButton);
        cp5ElementsToCheck.add((controlP5.Controller) dataOutputsButton);
        cp5ElementsToCheck.add((controlP5.Controller) cp5_networking_dropdowns.get(ScrollableList.class, "dataType1"));
        cp5ElementsToCheck.add((controlP5.Controller) cp5_networking_baudRate.get(ScrollableList.class, "baud_rate"));
    }

    private LinkedList<String> getComPorts() {
        final SerialPort[] allCommPorts = SerialPort.getCommPorts();
        LinkedList<String> cuCommPorts = new LinkedList<String>();
        for (SerialPort port : allCommPorts) {
            // Filter out .tty ports for Mac users, to only show .cu addresses
            if (isMac() && port.getSystemPortName().startsWith("tty")) {
                continue;
            }
            StringBuilder found = new StringBuilder("");
            if (isMac() || isLinux())
                found.append("/dev/");
            found.append(port.getSystemPortName());
            cuCommPorts.add(found.toString());
        }
        return cuCommPorts;
    }

    // Used to update the Hashmap
    public void putCP5DataIntoMap() {
        for (int i = 0; i < dataTypeNames.size(); i++) {
            //datatypes
            cp5Map.put(dataTypeNames.get(i), PApplet.parseInt(cp5_networking_dropdowns.get(ScrollableList.class, dataTypeNames.get(i)).getValue()));
        }
        //osc textfields
        copyCP5TextToMap(oscTextFieldNames, cp5Map);
        //udp textfields
        copyCP5TextToMap(udpTextFieldNames, cp5Map);
        //lsl textfields
        copyCP5TextToMap(lslTextFieldNames, cp5Map);
        //Serial baud rate and port name
        cp5Map.put("baud_rate", PApplet.parseInt(cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").getValue()));
        String s = cp5_networking_portName.get(ScrollableList.class, "port_name").getItem(comPortToSave).get("name").toString();
        cp5Map.put("port_name", s);
        //println(cp5Map);
    }

    private void copyCP5TextToMap(String[] keys, HashMap m) {
        for (int i = 0; i < keys.length; i++) {
            m.put(keys[i], cp5_networking.get(Textfield.class, keys[i]).getText());
        }
    }

    public Map getCP5Map() {
        return cp5Map;
    }

    public void update() {
        super.update();
        if (protocolMode.equals("LSL")) {
            if (stream1 != null) {
                stream1.run();
            }
            if (stream2 != null) {
                stream2.run();
            }
            if (stream3 != null) {
                stream3.run();
            }
        }

        checkTopNavEvents();

        // ignore top left button interaction when widgetSelector dropdown is active
        List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();
        cp5ElementsToCheck.add((controlP5.Controller) guideButton);
        cp5ElementsToCheck.add((controlP5.Controller) dataOutputsButton);
        // lock left button interaction and certain dropdowns when widgetSelector
        // dropdown is active
        lockElementsOnOverlapCheck(cp5ElementsToCheck);
        checkOverlappingSerialDropdown();

        if (protocolMode.equals("OSC")) {
            cp5ElementsAreActive = textfieldsAreActive(oscTextFieldNames);
            for (int i = 0; i < oscTextFieldNames.length; i++) {
                copyPaste.checkForCopyPaste(cp5_networking.get(Textfield.class, oscTextFieldNames[i]));
            }
        } else if (protocolMode.equals("UDP")) {
            cp5ElementsAreActive = textfieldsAreActive(udpTextFieldNames);
            for (int i = 0; i < udpTextFieldNames.length; i++) {
                copyPaste.checkForCopyPaste(cp5_networking.get(Textfield.class, udpTextFieldNames[i]));
            }
        } else if (protocolMode.equals("LSL")) {
            cp5ElementsAreActive = textfieldsAreActive(lslTextFieldNames);
            for (int i = 0; i < lslTextFieldNames.length; i++) {
                copyPaste.checkForCopyPaste(cp5_networking.get(Textfield.class, lslTextFieldNames[i]));
            }
        } else {
            // For serial mode, disable fft output by switching to bandpower instead
            this.disableCertainOutputs((int) getCP5Map().get(dataTypeNames.get(0)));
        }

        if (cp5ElementsAreActive != previousCP5State) {
            if (!cp5ElementsAreActive) {
                // Cp5 textfield elements state change from 1 to 0, so save cp5 data
                putCP5DataIntoMap();
            }
            previousCP5State = cp5ElementsAreActive;
        }

        if (currentBoard.isStreaming()) {
            accumulateNewData();
            checkIfEnoughDataToSend();
        }

        // Check if any textfields are active and also for copy/paste if active
        updateNetworkingTextfields();
    }

    public void accumulateNewData() {
        // accumulate data
        double[][] newData = currentBoard.getFrameData();
        int[] exgChannels = currentBoard.getEXGChannels();

        if (newData[exgChannels[0]].length == 0) {
            return;
        }

        int start = dataProcessingFilteredBuffer[0].length - newData[exgChannels[0]].length;

        for (int iSample = 0; iSample < newData[exgChannels[0]].length; iSample++) {

            double[] sample = new double[exgChannels.length];
            float[] sample_filtered = new float[exgChannels.length];

            for (int iChan = 0; iChan < exgChannels.length; iChan++) {
                sample[iChan] = newData[exgChannels[iChan]][iSample];
                sample_filtered[iChan] = dataProcessingFilteredBuffer[iChan][start + iSample];
                // println("CHAN== "+iChan+" || SAMPLE== "+iSample+" DATA=="+sample[iChan]);
            }
            dataAccumulationQueue.add(sample);
            dataAccumulationQueueFiltered.add(sample_filtered);
        }
    }

    public void checkIfEnoughDataToSend() {
        newTimeSeriesDataToSend.set(dataAccumulationQueue.size() >= nPointsPerUpdate);

        if (newTimeSeriesDataToSend.get()) {
            for (int iSample = 0; iSample < nPointsPerUpdate; iSample++) {
                double[] sample = dataAccumulationQueue.pop();

                for (int iChan = 0; iChan < sample.length; iChan++) {
                    dataBufferToSend[iChan][iSample] = (float) sample[iChan];
                }
            }
        }

        newTimeSeriesDataToSendFiltered.set(dataAccumulationQueueFiltered.size() >= nPointsPerUpdate);

        if (newTimeSeriesDataToSendFiltered.get()) {
            for (int iSample = 0; iSample < nPointsPerUpdate; iSample++) {
                float[] sample = dataAccumulationQueueFiltered.pop();

                for (int iChan = 0; iChan < sample.length; iChan++) {
                    dataBufferToSend_Filtered[iChan][iSample] = sample[iChan];
                }
            }
        }
    }

    private Boolean textfieldsAreActive(String[] names) {
        boolean isActive = false;
        for (String name : names) {
            if (cp5_networking.get(Textfield.class, name).isFocus()) {
                isActive = true;
            }
        }
        return isActive;
    }

    public void draw() {
        super.draw();
        pushStyle();

        showCP5();

        cp5_networking.draw();

        if (protocolMode.equals("Serial")) {
            cp5_networking_portName.draw();
            cp5_networking_baudRate.draw();
        }

        // Draw background boxes behind data type dropdowns
        for (int i = 0; i < dataTypeNames.size(); i++) {
            if (cp5_networking_dropdowns.get(ScrollableList.class, dataTypeNames.get(i)).isVisible()
                    && cp5_networking_dropdowns.get(ScrollableList.class, dataTypeNames.get(i)).isOpen()) {
                float[] pos = cp5_networking_dropdowns.get(ScrollableList.class, dataTypeNames.get(i)).getPosition();
                int width = itemWidth + 2;
                int height = cp5_networking_dropdowns.get(ScrollableList.class, dataTypeNames.get(i)).getHeight();
                fill(0, 0, 0);
                rect(pos[0] - 1, pos[1] - 1, width, height);
            }
        }

        cp5_networking_dropdowns.draw();

        int headerFontSize = 18;
        fill(OPENBCI_DARKBLUE);
        textFont(h1, headerFontSize);

        if (!protocolMode.equals("Serial")) {
            text(" Stream 1", column1, row0);
            text(" Stream 2", column2, row0);
            text(" Stream 3", column3, row0);
        }
        if (protocolMode.equals("OSC")) {
            text(" Stream 4", column4, row0);
        }
        text("Data Type", column0, row1);

        if (protocolMode.equals("OSC")) {
            textFont(f4, 40);
            text("OSC", x + 20, y + h / 8 + 15);
            textFont(h1, headerFontSize);
            text("IP", column0, row2);
            text("Port", column0, row3);
        } else if (protocolMode.equals("UDP")) {
            textFont(f4, 40);
            text("UDP", x + 20, y + h / 8 + 15);
            textFont(h1, headerFontSize);
            text("IP", column0, row2);
            text("Port", column0, row3);
        } else if (protocolMode.equals("LSL")) {
            textFont(f4, 40);
            text("LSL", x + 20, y + h / 8 + 15);
            textFont(h1, headerFontSize);
            text("Name", column0, row2);
            text("Type", column0, row3);
        } else if (protocolMode.equals("Serial")) {
            textFont(f4, 40);
            text("Serial", x + 20, y + h / 8 + 15);
            textFont(h1, headerFontSize);
            text("Baud/Port", column0, row2);
            // text("Port Name", column0,row3);
        }
        popStyle();

    }

    private void initialize_UI() {
        cp5_networking = new ControlP5(pApplet);
        cp5_networking_dropdowns = new ControlP5(pApplet);
        cp5_networking_baudRate = new ControlP5(pApplet);
        cp5_networking_portName = new ControlP5(pApplet);

        cp5_networking.setAutoDraw(false);
        cp5_networking_dropdowns.setAutoDraw(false);
        cp5_networking_portName.setAutoDraw(false);
        cp5_networking_baudRate.setAutoDraw(false);

        createTextFields(oscTextFieldNames, oscTextDefaultVals);
        createTextFields(udpTextFieldNames, udpTextDefaultVals);
        createTextFields(lslTextFieldNames, lslTextDefaultVals);

        // Serial
        boolean noComPortsFound = serialNetworkingComPorts.size() == 0 ? true : false;
        createPortDropdown("port_name", serialNetworkingComPorts, noComPortsFound);
        createBaudDropdown("baud_rate", baudRates);

        for (int i = 0; i < dataTypeNames.size(); i++) {
            createDropdown(dataTypeNames.get(i), dataTypes);
        }

        createStartButton();
        createGuideButton();
        createDataOutputsButton();
    }

    // Shows and Hides appropriate CP5 elements within widget
    public void showCP5() {

        osc_visible = false;
        udp_visible = false;
        lsl_visible = false;
        serial_visible = false;

        if (protocolMode.equals("OSC")) {
            osc_visible = true;
        } else if (protocolMode.equals("UDP")) {
            udp_visible = true;
        } else if (protocolMode.equals("LSL")) {
            lsl_visible = true;
        } else if (protocolMode.equals("Serial")) {
            serial_visible = true;
        }

        setTextFieldVisible(oscTextFieldNames, osc_visible);
        setTextFieldVisible(udpTextFieldNames, udp_visible);
        setTextFieldVisible(lslTextFieldNames, lsl_visible);

        cp5_networking_portName.get(ScrollableList.class, "port_name").setVisible(serial_visible);
        cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").setVisible(serial_visible);

        cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setVisible(true);
        if (!serial_visible) {
            cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setVisible(true);
            cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setVisible(true);
        } else {
            cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setVisible(false);
            cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setVisible(false);
        }

        // Draw a 4th Data Type dropdown menu if we are using OSC!
        if (protocolMode.equals("OSC")) {
            cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").setVisible(true);
        } else {
            cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").setVisible(false);
        }
    }

    private void setTextFieldVisible(String[] textFieldNames, boolean isVisible) {
        for (int i = 0; i < textFieldNames.length; i++) {
            cp5_networking.get(Textfield.class, textFieldNames[i]).setVisible(isVisible);
        }
    }

    // Lock text fields by setting _lock = true, unlock using false
    private void lockTextFields(String[] textFieldNames, boolean _lock) {
        for (int i = 0; i < textFieldNames.length; i++) {
            if (_lock) {
                cp5_networking.get(Textfield.class, textFieldNames[i]).lock();
            } else {
                cp5_networking.get(Textfield.class, textFieldNames[i]).unlock();
            }
        }
    }

    private void createTextFields(String[] textFieldNames, String[] defaultValues) {
        for (int i = 0; i < textFieldNames.length; i++) {
            createTextField(textFieldNames[i], defaultValues[i]);
        }
    }

    /* Create textfields for network parameters */
    private void createTextField(String name, String default_text) {
        cp5_networking.addTextfield(name).align(10, 100, 10, 100) // Alignment
                .setSize(120, 20) // Size of textfield
                .setFont(f2)
                .setFocus(false) // Deselects textfield
                .setColor(OPENBCI_DARKBLUE)
                .setColorBackground(color(255, 255, 255)) // text field bg color
                .setColorValueLabel(OPENBCI_DARKBLUE) // text color
                .setColorForeground(OPENBCI_DARKBLUE) // border color when not selected
                .setColorActive(isSelected_color) // border color when selected
                .setColorCursor(OPENBCI_DARKBLUE)
                .setText(default_text) // Default text in the field
                .setCaptionLabel("") // Remove caption label
                .setVisible(false) // Initially hidden
                .setAutoClear(true) // Autoclear
        ;
    }

    private void createStartButton() {
        startButton = createButton(cp5_networking, "startStopNetworkStream", "Start " + protocolMode + " Stream",
                x + w / 2 - 70, y + h - 40, 200, 20, 0, p4, 14, TURN_ON_GREEN, OPENBCI_DARKBLUE, BUTTON_HOVER,
                BUTTON_PRESSED, OBJECT_BORDER_GREY, 0);
        startButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (!networkActive) {
                    try {
                        startButton.setColorBackground(TURN_OFF_RED);
                        startButton.getCaptionLabel().setText("Stop " + protocolMode + " Stream");
                        initializeStreams(); // Establish stream
                        startNetwork(); // Begin streaming
                        output("Network Stream Started");
                    } catch (Exception e) {
                        e.printStackTrace();
                        String exception = e.toString();
                        String[] nwError = split(exception, ':');
                        outputError("Networking Error - Port: " + nwError[2]);
                        shutDown();
                        networkActive = false;
                        startButton.setColorBackground(TURN_ON_GREEN);
                        startButton.getCaptionLabel().setText("Start " + protocolMode + " Stream");
                        return;
                    }
                } else {
                    startButton.setColorBackground(TURN_ON_GREEN);
                    startButton.getCaptionLabel().setText("Start " + protocolMode + " Stream");
                    stopNetwork(); // Stop streams
                    output("Network Stream Stopped");
                }
            }
        });
        startButton.setDescription("Click here to Start and Stop the network stream for the chosen protocol.");
    }

    // Change appearance of networking start/stop button to Off
    private void turnOffButton() {
        startButton.setColorBackground(TURN_ON_GREEN);
        startButton.getCaptionLabel().setText("Start " + protocolMode + " Stream");
    }

    private void createGuideButton() {
        guideButton = createButton(cp5_networking, "networkingGuideButton", "Networking Guide", (int) (x0 + 1),
                (int) (y0 + navH + 1), 125, navH - 3, p5, 12, colorNotPressed, OPENBCI_DARKBLUE);
        guideButton.setBorderColor(OBJECT_BORDER_GREY);
        guideButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                openURLInBrowser(NETWORKING_GUIDE_URL);
                output("Opening Networking Widget Guide using default browser.");
            }
        });
        guideButton.setDescription("Click to open the Networking Widget Guide in your default browser.");
    }

    private void createDataOutputsButton() {
        dataOutputsButton = createButton(cp5_networking, "dataOutputsButton", "Data Outputs",
                x0 + 1 + 3 + guideButton.getWidth(), y0 + navH + 1, 100, navH - 3, p5, 12, colorNotPressed,
                OPENBCI_DARKBLUE);
        dataOutputsButton.setBorderColor(OBJECT_BORDER_GREY);
        dataOutputsButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                openURLInBrowser(NETWORKING_DATA_OUTPUTS_URL);
                output("Opening Networking Data Outputs Guide using default browser.");
            }
        });
        dataOutputsButton.setDescription("Click to open the Networking Data Outputs Guide in your default browser.");
    }

    /* Creating DataType Dropdowns */
    private void createDropdown(String name, List<String> _items) {

        ScrollableList scrollList = cp5_networking_dropdowns.addScrollableList(name)
                .setOpen(false)
                .setOutlineColor(OPENBCI_DARKBLUE)
                .setColorBackground(OPENBCI_BLUE) // text field bg color
                .setColorValueLabel(color(255)) // text color
                .setColorCaptionLabel(color(255))
                .setColorForeground(color(125)) // border color when not selected
                .setColorActive(BUTTON_PRESSED) // border color when selected
                // .setColorCursor(color(26,26,26))
                .setSize(itemWidth, (_items.size() + 1) * (navH - 4))// + maxFreqList.size())
                .setBarHeight(navH - 4) // height of top/primary bar
                .setItemHeight(navH - 4) // height of all item/dropdown bars
                .addItems(_items) // used to be .addItems(maxFreqList)
                .setVisible(false);
        cp5_networking_dropdowns.getController(name)
                .getCaptionLabel() // the caption label is the text object in the primary bar
                .toUpperCase(false) // DO NOT AUTOSET TO UPPERCASE!!!
                .setText("None").setFont(h4).setSize(14)
                .getStyle().setPaddingTop(4); // need to grab style before affecting the paddingTop                           
        cp5_networking_dropdowns.getController(name)
                .getValueLabel() // the value label is connected to the text objects in the dropdown item bars
                .toUpperCase(false) // DO NOT AUTOSET TO UPPERCASE!!!
                .setText("None").setFont(h5).setSize(12) // set the font size of the item bars to 14pt
                .getStyle() // need to grab style before affecting the paddingTop
                .setPaddingTop(3) // 4-pixel vertical offset to center text
        ;
    }

    private void createBaudDropdown(String name, List<String> _items) {
        ScrollableList scrollList = cp5_networking_baudRate.addScrollableList(name).setOpen(false)
                .setOutlineColor(OPENBCI_DARKBLUE).setColorBackground(OPENBCI_BLUE) // text field bg color
                .setColorValueLabel(color(255)) // text color
                .setColorCaptionLabel(color(255))
                .setColorForeground(color(125)) // border color when not selected
                .setColorActive(BUTTON_PRESSED) // border color when selected
                // .setColorCursor(color(26,26,26))
                .setSize(itemWidth, (_items.size() + 1) * (navH - 4))// + maxFreqList.size())
                .setBarHeight(navH - 4) // height of top/primary bar
                .setItemHeight(navH - 4) // height of all item/dropdown bars
                .addItems(_items) // used to be .addItems(maxFreqList)
                .setVisible(false);
        cp5_networking_baudRate.getController(name)
                .getCaptionLabel() // the caption label is the text object in the primary bar
                .toUpperCase(false) // DO NOT AUTOSET TO UPPERCASE!!!
                .setText(defaultBaud).setFont(h4).setSize(14)
                .getStyle() // need to grab style before affecting the paddingTop
                .setPaddingTop(4);
        cp5_networking_baudRate.getController(name)
                .getValueLabel() // the value label is connected to the text objects in the dropdown item bars
                .toUpperCase(false) // DO NOT AUTOSET TO UPPERCASE!!!
                .setText("None").setFont(h5).setSize(12) // set the font size of the item bars to 14pt
                .getStyle() // need to grab style before affecting the paddingTop
                .setPaddingTop(3) // 4-pixel vertical offset to center text
        ;
    }

    private void createPortDropdown(String name, List<String> _items, boolean isEmpty) {
        if (isEmpty)
            _items.add("None"); // Fix #642 and #637
        ScrollableList scrollList = cp5_networking_portName.addScrollableList(name).setOpen(false)
                .setOutlineColor(OPENBCI_DARKBLUE)
                .setColorBackground(OPENBCI_BLUE) // text field bg color
                .setColorValueLabel(color(255)) // text color
                .setColorCaptionLabel(color(255))
                .setColorForeground(color(125)) // border color when not selected
                .setColorActive(BUTTON_PRESSED) // border color when selected
                // .setColorCursor(color(26,26,26))
                .setSize(itemWidth, (_items.size() + 1) * (navH - 4))// + maxFreqList.size())
                .setBarHeight(navH - 4) // height of top/primary bar
                .setItemHeight(navH - 4) // height of all item/dropdown bars
                .addItems(_items) // used to be .addItems(maxFreqList)
                .setVisible(false);
        cp5_networking_portName.getController(name)
                .getCaptionLabel() // the caption label is the text object in the primary bar
                .toUpperCase(false) // DO NOT AUTOSET TO UPPERCASE!!!
                .setText("None").setFont(h4).setSize(14)
                .getStyle() // need to grab style before affecting the paddingTop
                .setPaddingTop(4);
        cp5_networking_portName.getController(name)
                .getValueLabel() // the value label is connected to the text objects in the dropdown item bars
                .toUpperCase(false) // DO NOT AUTOSET TO UPPERCASE!!!
                .setText("None").setFont(h5).setSize(12) // set the font size of the item bars to 14pt
                .getStyle() // need to grab style before affecting the paddingTop
                .setPaddingTop(3) // 4-pixel vertical offset to center text
        ;
    }

    // loop through networking textfields and find out if any are active
    private void updateNetworkingTextfields() {
        List<Textfield> allTextfields = cp5_networking.getAll(Textfield.class);
        for (int i = 0; i < allTextfields.size(); i++) {
            textfieldUpdateHelper.checkTextfield(allTextfields.get(i));
        }
    }

    public void screenResized() {
        super.screenResized();

        //Very important to allow users to interact with objects after app resize
        cp5_networking.setGraphics(pApplet, 0,0);
        cp5_networking_dropdowns.setGraphics(pApplet, 0,0);
        cp5_networking_baudRate.setGraphics(pApplet, 0,0);
        cp5_networking_portName.setGraphics(pApplet, 0,0);

        //scale the item width of all elements in the networking widget
        itemWidth = PApplet.parseInt(map(width, 1024, 1920, 100, 120)) - 4;

        column0 = x+w/22-12;
        int widthd = 46;//This value has been fine-tuned to look proper in windowed mode 1024*768 and fullscreen on 1920x1080

        if (protocolMode.equals("UDP") || protocolMode.equals("LSL")) {
            widthd = 38;
            itemWidth = PApplet.parseInt(map(width, 1024, 1920, 120, 140)) - 4;
        }

        column1 = x+12*w/widthd-25;//This value has been fine-tuned to look proper in windowed mode 1024*768 and fullscreen on 1920x1080
        column2 = x+(12+9*1)*w/widthd-25;
        column3 = x+(12+9*2)*w/widthd-25;
        column4 = x+(12+9*3)*w/widthd-25;
        halfWidth = (column2+100) - column1;
        fullColumnWidth = (column4+100) - column1;
        row0 = y+h/4+10;
        row1 = y+4*h/10;
        row2 = y+5*h/10;
        row3 = y+6*h/10;
        row4 = y+7*h/10;
        row5 = y+8*h/10;
        int offset = 15;//This value has been fine-tuned to look proper in windowed mode 1024*768 and fullscreen on 1920x1080

        //reset the button positions using new x and y
        startButton.setPosition(x + w/2 - 70, y + h - 40 );
        guideButton.setPosition(x0 + 1, y0 + navH + 1);
        dataOutputsButton.setPosition(x0 + 1 + 2 + guideButton.getWidth() , y0 + navH + 1);

        //Responsively scale the data types dropdown height
        int dropdownsItemsToShow = min(floor((this.h0 * datatypeDropdownScaling) / (this.navH - 4)), dataTypes.size());
        int dropdownHeight = (dropdownsItemsToShow) * (this.navH - 4);
        int maxDropdownHeight = (dataTypes.size() + 1) * (this.navH - 4);
        if (dropdownHeight > maxDropdownHeight) dropdownHeight = maxDropdownHeight;

        for (String datatypeName : dataTypeNames) {
            cp5_networking_dropdowns.get(ScrollableList.class, datatypeName).setSize(itemWidth, dropdownHeight);
        }

        if (protocolMode.equals("OSC")) {
            for (String textField : oscTextFieldNames) {
                cp5_networking.get(Textfield.class, textField).setWidth(itemWidth);
            }
            cp5_networking.get(Textfield.class, "OSC_ip1").setPosition(column1, row2 - offset);
            cp5_networking.get(Textfield.class, "OSC_port1").setPosition(column1, row3 - offset);
            cp5_networking.get(Textfield.class, "OSC_ip2").setPosition(column2, row2 - offset);
            cp5_networking.get(Textfield.class, "OSC_port2").setPosition(column2, row3 - offset);
            cp5_networking.get(Textfield.class, "OSC_ip3").setPosition(column3, row2 - offset);
            cp5_networking.get(Textfield.class, "OSC_port3").setPosition(column3, row3 - offset);
            cp5_networking.get(Textfield.class, "OSC_ip4").setPosition(column4, row2 - offset);
            cp5_networking.get(Textfield.class, "OSC_port4").setPosition(column4, row3 - offset);
        } else if (protocolMode.equals("UDP")) {
            for (String textField : udpTextFieldNames) {
                cp5_networking.get(Textfield.class, textField).setWidth(itemWidth);
            }
            cp5_networking.get(Textfield.class, "UDP_ip1").setPosition(column1, row2 - offset);
            cp5_networking.get(Textfield.class, "UDP_port1").setPosition(column1, row3 - offset);
            cp5_networking.get(Textfield.class, "UDP_ip2").setPosition(column2, row2 - offset);
            cp5_networking.get(Textfield.class, "UDP_port2").setPosition(column2, row3 - offset);
            cp5_networking.get(Textfield.class, "UDP_ip3").setPosition(column3, row2 - offset);
            cp5_networking.get(Textfield.class, "UDP_port3").setPosition(column3, row3 - offset);
        } else if (protocolMode.equals("LSL")) {
            for (String textField : lslTextFieldNames) {
                cp5_networking.get(Textfield.class, textField).setWidth(itemWidth);
            }
            cp5_networking.get(Textfield.class, "LSL_name1").setPosition(column1,row2 - offset);
            cp5_networking.get(Textfield.class, "LSL_type1").setPosition(column1,row3 - offset);
            cp5_networking.get(Textfield.class, "LSL_name2").setPosition(column2,row2 - offset);
            cp5_networking.get(Textfield.class, "LSL_type2").setPosition(column2,row3 - offset);
            cp5_networking.get(Textfield.class, "LSL_name3").setPosition(column3,row2 - offset);
            cp5_networking.get(Textfield.class, "LSL_type3").setPosition(column3,row3 - offset);
        } else if (protocolMode.equals("Serial")) {
            //Serial Specific
            cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").setPosition(column1, row2-offset);
            cp5_networking_portName.get(ScrollableList.class, "port_name").setPosition(column2, row2-offset);
            cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").setSize(itemWidth, (baudRates.size()+1)*(navH-4));
            cp5_networking_portName.get(ScrollableList.class, "port_name").setSize(halfWidth, (5)*(navH-4));
        }

        cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setPosition(column1, row1-offset);
        cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setPosition(column2, row1-offset);
        cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setPosition(column3, row1-offset);
        cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").setPosition(column4, row1-offset);
    }

    private void hideAllTextFields(String[] textFieldNames) {
        for (int i = 0; i < textFieldNames.length; i++) {
            cp5_networking.get(Textfield.class, textFieldNames[i]).setVisible(false);
        }
    }

    /* Function call to hide all widget CP5 elements */
    private void hideElements() {
        String[] allTextFields = concat(oscTextFieldNames, udpTextFieldNames);
        allTextFields = concat(allTextFields, lslTextFieldNames);
        hideAllTextFields(allTextFields);

        cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setVisible(false);
        cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setVisible(false);
        cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setVisible(false);
        cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").setVisible(false);
        cp5_networking_portName.get(ScrollableList.class, "port_name").setVisible(false);
        cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").setVisible(false);
    }

    public boolean getNetworkActive() {
        return networkActive;
    }

    /*
     * Call to shutdown some UI stuff. Called from W_manager, maybe do this
     * differently..
     */
    public void shutDown() {
        hideElements();
    }

    private void initializeStreams() {
        String ip;
        int port;
        String name;
        int numLslDataPoints;
        int baudRate;
        String type;
        int streamNumber;

        String dt1 = dataTypes.get((int) cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").getValue());
        String dt2 = dataTypes.get((int) cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").getValue());
        String dt3 = dataTypes.get((int) cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").getValue());
        String dt4 = dataTypes.get((int) cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").getValue());
        networkActive = true;

        // Establish OSC Streams
        if (protocolMode.equals("OSC")) {
            final String baseAddress = "/openbci";
            if (!dt1.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "OSC_ip1").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "OSC_port1").getText());
                streamNumber = 0;
                stream1 = new Stream(dt1, ip, port, baseAddress, streamNumber);
            } else {
                stream1 = null;
            }
            if (!dt2.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "OSC_ip2").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "OSC_port2").getText());
                streamNumber = 1;
                stream2 = new Stream(dt2, ip, port, baseAddress, streamNumber);
            } else {
                stream2 = null;
            }
            if (!dt3.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "OSC_ip3").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "OSC_port3").getText());
                streamNumber = 2;
                stream3 = new Stream(dt3, ip, port, baseAddress, streamNumber);
            } else {
                stream3 = null;
            }
            if (!dt4.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "OSC_ip4").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "OSC_port4").getText());
                streamNumber = 3;
                stream4 = new Stream(dt4, ip, port, baseAddress, streamNumber);
            } else {
                stream4 = null;
            }

            // Establish UDP Streams
        } else if (protocolMode.equals("UDP")) {
            if (!dt1.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "UDP_ip1").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "UDP_port1").getText());
                streamNumber = 0;
                stream1 = new Stream(dt1, ip, port, streamNumber);
            } else {
                stream1 = null;
            }
            if (!dt2.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "UDP_ip2").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "UDP_port2").getText());
                streamNumber = 1;
                stream2 = new Stream(dt2, ip, port, streamNumber);
            } else {
                stream2 = null;
            }
            if (!dt3.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "UDP_ip3").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "UDP_port3").getText());
                streamNumber = 2;
                stream3 = new Stream(dt3, ip, port, streamNumber);
            } else {
                stream3 = null;
            }

            // Establish LSL Streams
        } else if (protocolMode.equals("LSL")) {
            if (!dt1.equals("None")) {
                name = cp5_networking.get(Textfield.class, "LSL_name1").getText();
                type = cp5_networking.get(Textfield.class, "LSL_type1").getText();
                numLslDataPoints = getDataTypeNumChanLSL(dt1);
                streamNumber = 0;
                stream1 = new Stream(dt1, name, type, numLslDataPoints, streamNumber);
            } else {
                stream1 = null;
            }
            if (!dt2.equals("None")) {
                name = cp5_networking.get(Textfield.class, "LSL_name2").getText();
                type = cp5_networking.get(Textfield.class, "LSL_type2").getText();
                numLslDataPoints = getDataTypeNumChanLSL(dt2);
                streamNumber = 1;
                stream2 = new Stream(dt2, name, type, numLslDataPoints, streamNumber);
            } else {
                stream2 = null;
            }
            if (!dt3.equals("None")) {
                name = cp5_networking.get(Textfield.class, "LSL_name3").getText();
                type = cp5_networking.get(Textfield.class, "LSL_type3").getText();
                numLslDataPoints = getDataTypeNumChanLSL(dt3);
                streamNumber = 2;
                stream3 = new Stream(dt3, name, type, numLslDataPoints, streamNumber);
            } else {
                stream3 = null;
            }
        } else if (protocolMode.equals("Serial")) {
            if (!dt1.equals("None")) {
                name = serialNetworkingComPorts
                        .get((int) (cp5_networking_portName.get(ScrollableList.class, "port_name").getValue()));
                println("ComPort: " + name);
                println("Baudrate: " + Integer.parseInt(baudRates
                        .get((int) (cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").getValue()))));
                baudRate = Integer.parseInt(baudRates
                        .get((int) (cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").getValue())));
                stream1 = new Stream(dt1, name, baudRate, pApplet);
            } else {
                stream1 = null;
            }
        }
    }

    /* Start networking */
    public void startNetwork() {
        if (stream1 != null) {
            stream1.start();
        }
        if (stream2 != null) {
            stream2.start();
        }
        if (stream3 != null) {
            stream3.start();
        }
        if (stream4 != null) {
            stream4.start();
        }
    }

    /* Stop networking */
    public void stopNetwork() {
        networkActive = false;

        if (stream1 != null) {
            stream1.quit();
            stream1 = null;
        }
        if (stream2 != null) {
            stream2.quit();
            stream2 = null;
        }
        if (stream3 != null) {
            stream3.quit();
            stream3 = null;
        }
        if (stream4 != null) {
            stream4.quit();
            stream4 = null;
        }
    }

    // Fix #644 - Remove confusing #Chan textfield from Networking Widget and
    // account for this here
    private int getDataTypeNumChanLSL(String dataType) {
        if (dataType.equals("TimeSeriesFilt") || dataType.equals("TimeSeriesRaw")) {
            return currentBoard.getNumEXGChannels();
        } else if (dataType.equals("Focus")) {
            return 1;
        } else if (dataType.equals("FFT")) {
            return 125;
        } else if (dataType.equals("EMG")) {
            return currentBoard.getNumEXGChannels();
        } else if (dataType.equals("AvgBandPower")) {
            return 5;
        } else if (dataType.equals("BandPower")) {
            return 5;
        } else if (dataType.equals("Pulse")) {
            return 3;
        } else if (dataType.equals("Accel/Aux")) {
            if (currentBoard instanceof AccelerometerCapableBoard) {
                AccelerometerCapableBoard accelBoard = (AccelerometerCapableBoard) currentBoard;
                if (accelBoard.isAccelerometerActive()) {
                    return accelBoard.getAccelerometerChannels().length;
                }
            }
            if (currentBoard instanceof AnalogCapableBoard) {
                AnalogCapableBoard analogBoard = (AnalogCapableBoard) currentBoard;
                if (analogBoard.isAnalogActive()) {
                    return analogBoard.getAnalogChannels().length;
                }
            }
            if (currentBoard instanceof DigitalCapableBoard) {
                DigitalCapableBoard digitalBoard = (DigitalCapableBoard) currentBoard;
                if (digitalBoard.isDigitalActive()) {
                    return digitalBoard.getDigitalChannels().length;
                }
            }
        } else if (dataType.equals("EMGJoystick")) {
            return 2;
        }
        throw new IllegalArgumentException("IllegalArgumentException: Error detecting number of channels for LSL stream data... please fix!");
    }

    private void checkOverlappingSerialDropdown() {
        // When using serial mode, lock baud rate dropdown when datatype dropdown is in
        // use
        if (protocolMode.equals("Serial")) {

            if (cp5_networking_dropdowns.get(ScrollableList.class, dataTypeNames.get(0)).isOpen()) {
                cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").lock();
            } else {
                if (cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").isLock()) {
                    cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").unlock();
                }
            }
        }
    }

    private void checkTopNavEvents() {
        // Check if a change has occured in TopNav
        if ((topNav.configSelector.isVisible != configIsVisible)
                || (topNav.layoutSelector.isVisible != layoutIsVisible)) {
            // lock/unlock the controllers within networking widget when using TopNav
            // Objects
            if (topNav.configSelector.isVisible || topNav.layoutSelector.isVisible) {
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").lock();
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").lock();
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").lock();
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").lock();
                cp5_networking_portName.getController("port_name").lock();
                lockTextFields(oscTextFieldNames, true);
                lockTextFields(udpTextFieldNames, true);
                lockTextFields(lslTextFieldNames, true);
                // println("##LOCKED NETWORKING CP5 CONTROLLERS##");
            } else {
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").unlock();
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").unlock();
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").unlock();
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").unlock();
                cp5_networking_portName.getController("port_name").unlock();
                lockTextFields(oscTextFieldNames, false);
                lockTextFields(udpTextFieldNames, false);
                lockTextFields(lslTextFieldNames, false);
            }
            configIsVisible = topNav.configSelector.isVisible;
            layoutIsVisible = topNav.layoutSelector.isVisible;
        }
    }

    public void setComPortToSave(int n) {
        comPortToSave = n;
    }

    public void disableCertainOutputs(int n) {
        // Disable serial fft ouput and display message, it's too much data for serial
        // coms
        if (w_networking.protocolMode.equals("Serial")) {
            if (n == dataTypes.indexOf("FFT")) {
                outputError("Please use Band Power instead of FFT for Serial Output. Changing data type...");
                println("Networking: Changing data type from FFT to BandPower. FFT data is too large to send over Serial communication.");
                cp5_networking_dropdowns.getController("dataType1").getCaptionLabel().setText("BandPower");
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType1")
                        .setValue(dataTypes.indexOf("BandPower"));
            }
            ;
        }
    }

    public void compareAndSetNetworkingFrameLocks() {
        for (int i = 0; i < networkingFrameLocks.length; i++) {
            networkingFrameLocks[i].compareAndSet(false, true);
        }
    }
}; // End of w_networking class

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

class Stream extends Thread {
    private String protocol;
    private int streamNumber;
    private String dataType;
    private String ip;
    private int port;
    private String baseOscAddress;
    private String streamType;
    private String streamName;
    private int numLslDataPoints;
    private int numExgChannels;
    private DecimalFormat threeDecimalPlaces;
    private DecimalFormat fourLeadingPlaces;

    public Boolean isStreaming;
    private int start;
    private float[] dataToSend;
    private double[][] previousFrameData;

    private int samplesSent = 0;
    private int sampleRateClock = 0;
    private int sampleRateClockInterval = 10000;

    // OSC Objects
    private OscP5 osc;
    private NetAddress oscNetAddress;
    private OscMessage msg;
    // UDP Objects
    private UDP udp;
    // LSL objects
    private LSL.StreamInfo info_data;
    private LSL.StreamOutlet outlet_data;

    // Serial objects %%%%%
    private processing.serial.Serial serial_networking;
    private String portName;
    private int baudRate;
    private String serialMessage = "";

    private PApplet pApplet;

    // OSC Stream
    Stream(String dataType, String ip, int port, String baseAddress, int _streamNumber) {
        this.protocol = "OSC";
        this.streamNumber = _streamNumber;
        this.dataType = dataType;
        this.ip = ip;
        this.port = port;
        this.baseOscAddress = baseAddress;
        this.isStreaming = false;
        updateNumChan();
        try {
            closeNetwork();
        } catch (Exception e) {
            outputError("Error closing network while creating OSC Stream: " + e);
        }
    }

    // UDP Stream
    Stream(String dataType, String ip, int port, int _streamNumber) {
        this.protocol = "UDP";
        this.streamNumber = _streamNumber;
        this.dataType = dataType;
        this.ip = ip;
        this.port = port;
        this.isStreaming = false;
        updateNumChan();

        // Force decimal formatting for all Locales
        Locale currentLocale = Locale.getDefault();
        DecimalFormatSymbols otherSymbols = new DecimalFormatSymbols(currentLocale);
        otherSymbols.setDecimalSeparator('.');
        otherSymbols.setGroupingSeparator(',');
        threeDecimalPlaces = new DecimalFormat("0.000", otherSymbols);
        fourLeadingPlaces = new DecimalFormat("####", otherSymbols);

        try {
            closeNetwork();
        } catch (Exception e) {
            outputError("Error closing network while creating UDP Stream: " + e);
        }
    }

    // LSL Stream
    Stream(String dataType, String streamName, String streamType, int numLslDataPoints, int _streamNumber) {
        this.protocol = "LSL";
        this.streamNumber = _streamNumber;
        this.dataType = dataType;
        this.streamName = streamName;
        this.streamType = streamType;
        this.numLslDataPoints = numLslDataPoints;
        this.isStreaming = false;
        updateNumChan();
        try {
            closeNetwork();
        } catch (Exception e) {
            outputError("Error closing network while creating LSL Stream: " + e);
        }
    }

    // Serial Stream
    Stream(String dataType, String portName, int baudRate, PApplet _this) {
        this.protocol = "Serial";
        this.streamNumber = 0;
        this.dataType = dataType;
        this.portName = portName;
        this.baudRate = baudRate;
        this.isStreaming = false;
        this.pApplet = _this;
        updateNumChan();

        // Force decimal formatting for all Locales
        Locale currentLocale = Locale.getDefault();
        DecimalFormatSymbols otherSymbols = new DecimalFormatSymbols(currentLocale);
        otherSymbols.setDecimalSeparator('.');
        otherSymbols.setGroupingSeparator(',');
        threeDecimalPlaces = new DecimalFormat("0.000", otherSymbols);
        fourLeadingPlaces = new DecimalFormat("####", otherSymbols);

        try {
            closeNetwork();
        } catch (Exception e) {
            outputError("Error closing network while creating Serial Stream: " + e);
        }
    }

    public void start() {
        this.isStreaming = true;
        if (!this.protocol.equals("LSL")) {
            super.start();
        } else {
            openNetwork();
        }
    }

    public void run() {
        if (!this.protocol.equals("LSL")) {
            openNetwork();
            while (this.isStreaming) {
                if (!currentBoard.isStreaming()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        println(e.getMessage());
                    }
                } else {
                    if (checkForData()) {
                        sendData();
                    } else {
                        try {
                            Thread.sleep(1);
                        } catch (InterruptedException e) {
                            println(e.getMessage());
                        }
                    }
                }
            }
        } else if (this.protocol.equals("LSL")) {
            if (!currentBoard.isStreaming()) {
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    println(e.getMessage());
                }
            } else {
                // This method has been updated to reduce duplicate packets - RW 3/15/23
                if (checkForData()) {
                    sendData();
                }
            }
        }
    }

    private void updateNumChan() {
        numExgChannels = currentBoard.getNumEXGChannels();
        dataToSend = new float[numExgChannels * nPointsPerUpdate];
        // Bug #638: ArrayOutOfBoundsException was thrown if
        // nPointsPerUpdate was larger than 10, as start was
        // set to dataProcessingFilteredBuffer[0].length - 10.
        start = dataProcessingFilteredBuffer[0].length - nPointsPerUpdate;
    }

    // This method has been updated to reduce duplicate packets - RW 3/15/23
    private synchronized Boolean checkForData() {
        if (this.dataType.equals("TimeSeriesRaw")) {
            return w_networking.newTimeSeriesDataToSend.compareAndSet(true, false);
        }

        if (this.dataType.equals("TimeSeriesFilt")) {
            return w_networking.newTimeSeriesDataToSendFiltered.compareAndSet(true, false);
        }

        if (w_networking.networkingFrameLocks[this.streamNumber].compareAndSet(true, false)) {
            return true;
        } else {
            return false;
        }
    }

    private void sendData() {
        if (this.dataType.equals("TimeSeriesFilt") || this.dataType.equals("TimeSeriesRaw")) {
            sendTimeSeriesData();
        } else if (this.dataType.equals("Focus")) {
            sendFocusData();
        } else if (this.dataType.equals("FFT")) {
            sendFFTData();
        } else if (this.dataType.equals("EMG")) {
            sendEMGData();
        } else if (this.dataType.equals("AvgBandPower")) {
            sendNormalizedPowerBandData();
        } else if (this.dataType.equals("BandPower")) {
            sendPowerBandData();
        } else if (this.dataType.equals("Accel/Aux")) {
            if (currentBoard instanceof AccelerometerCapableBoard) {
                AccelerometerCapableBoard accelBoard = (AccelerometerCapableBoard) currentBoard;
                if (accelBoard.isAccelerometerActive()) {
                    sendAccelerometerData();
                }
            }
            if (currentBoard instanceof AnalogCapableBoard) {
                AnalogCapableBoard analogBoard = (AnalogCapableBoard) currentBoard;
                if (analogBoard.isAnalogActive()) {
                    sendAnalogReadData();
                }
            }
            if (currentBoard instanceof DigitalCapableBoard) {
                DigitalCapableBoard digitalBoard = (DigitalCapableBoard) currentBoard;
                if (digitalBoard.isDigitalActive()) {
                    sendDigitalReadData();
                }
            }
        } else if (this.dataType.equals("Pulse")) {
            sendPulseData();
        } else if (this.dataType.equals("EMGJoystick")) {
            sendEMGJoystickData();
        }
    }

    private void sendTimeSeriesData() {

        float[][] newDataFromBuffer = new float[currentBoard.getNumEXGChannels()][nPointsPerUpdate];
        String udpDataTypeName = "timeSeriesRaw";
        String oscDataTypeName = "time-series-raw";

        if (this.dataType.equals("TimeSeriesRaw")) {
            // Unfiltered
            for (int i = 0; i < newDataFromBuffer.length; i++) {
                newDataFromBuffer[i] = w_networking.dataBufferToSend[i];
            }
        } else {
            // Filtered
            udpDataTypeName = "timeSeriesFilt";
            oscDataTypeName = "time-series-filtered";
            for (int i = 0; i < newDataFromBuffer.length; i++) {
                newDataFromBuffer[i] = w_networking.dataBufferToSend_Filtered[i];
            }
        }

        /*
         * //Debugging if (sampleRateClock == 0) sampleRateClock = millis(); samplesSent
         * = samplesSent + nPointsPerUpdate; if (millis() > sampleRateClock +
         * sampleRateClockInterval) { float timeDelta = float(millis() -
         * sampleRateClock) / 1000; float sampleRateCheck = samplesSent / timeDelta;
         * println("\nNumber of samples collected = " + samplesSent);
         * println("Time Interval (Desired) = " + (sampleRateClockInterval / 1000));
         * println("Time Interval (Actual) = " + timeDelta);
         * println("Sample Rate (Desired) = " + currentBoard.getSampleRate());
         * println("Sample Rate (Actual) = " + sampleRateCheck); sampleRateClock = 0;
         * samplesSent = 0; }
         */

        if (this.protocol.equals("UDP")) {

            StringBuilder output = new StringBuilder();
            output.append("{\"type\":\"");
            output.append(udpDataTypeName);
            output.append("\",\"data\":[");

            for (int i = 0; i < newDataFromBuffer.length; i++) {
                output.append("[");
                for (int j = 0; j < newDataFromBuffer[i].length; j++) {
                    output.append(str(newDataFromBuffer[i][j]));
                    if (j != newDataFromBuffer[i].length - 1) {
                        output.append(",");
                    }
                }
                String channelArrayEnding = i != newDataFromBuffer.length - 1 ? "]," : "]";
                output.append(channelArrayEnding);
            }

            // End of entire packet
            output.append("]}\r\n");

            try {
                this.udp.send(output.toString(), this.ip, this.port);
            } catch (Exception e) {
                println(e.getMessage());
            }

        } else if (this.protocol.equals("OSC")) {

            for (int i = 0; i < newDataFromBuffer.length; i++) {
                msg.clearArguments();
                msg.setAddrPattern(baseOscAddress + "/" + oscDataTypeName + "/ch" + i);
                for (int j = 0; j < newDataFromBuffer[i].length; j++) {
                    msg.add(newDataFromBuffer[i][j]);
                }
                try {
                    this.osc.send(msg, this.oscNetAddress);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }

        } else if (this.protocol.equals("LSL")) {
            int numChannels = newDataFromBuffer.length;
            int numSamples = newDataFromBuffer[0].length;
            float[] _dataToSend = new float[numChannels * numSamples];
            for (int sample = 0; sample < numSamples; sample++) {
                for (int channel = 0; channel < numChannels; channel++) {
                    _dataToSend[channel + sample * numChannels] = newDataFromBuffer[channel][sample];
                }
            }
            // From LSLLink Library: The time stamps of other samples are automatically
            // derived based on the sampling rate of the stream.
            outlet_data.push_chunk(_dataToSend);

        } else if (this.protocol.equals("Serial")) {

            // Time Series over serial port should be disabled as there is no reasonable usage for this
            StringBuilder serialMessage = new StringBuilder();
            for (int i = 0; i < newDataFromBuffer.length; i++) {
                serialMessage.append("[");
                for (int j = 0; j < newDataFromBuffer[i].length; j++) {
                    float chan_uV = newDataFromBuffer[i][j];
                    
                    serialMessage.append(threeDecimalPlaces.format(chan_uV));
                    if (i < numExgChannels - 1) {
                        // add a comma to serialMessage to separate chan values, as long as it isn't last value...
                        serialMessage.append(","); 
                    }
                }
                serialMessage.append("]"); // close the message w/ "]"
                try {
                    // Write message to serial
                    this.serial_networking.write(serialMessage.toString());
                    // println(serialMesage.toString());
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }

        }
    }

    // Send out 1 or 0 as an integer over all networking data types for "Focus" data
    private void sendFocusData() {
        final int IS_METRIC = w_focus.getMetricExceedsThreshold();
        if (this.protocol.equals("OSC")) {
            msg.clearArguments();
            msg.setAddrPattern(baseOscAddress + "/focus");
            msg.add(IS_METRIC);
            try {
                this.osc.send(msg, this.oscNetAddress);
            } catch (Exception e) {
                println(e.getMessage());
            }
        } else if (this.protocol.equals("UDP")) {
            StringBuilder sb = new StringBuilder("{\"type\":\"focus\",\"data\":");
            sb.append(str(IS_METRIC));
            sb.append("}\r\n");
            try {
                this.udp.send(sb.toString(), this.ip, this.port);
            } catch (Exception e) {
                println(e.getMessage());
            }
        } else if (this.protocol.equals("LSL")) {
            float[] output = new float[] { (float) IS_METRIC };
            outlet_data.push_sample(output);
            // Serial
        } else if (this.protocol.equals("Serial")) {
            StringBuilder sb = new StringBuilder();
            sb.append(IS_METRIC);
            sb.append("\n");
            try {
                // println("SerialMessage: " + serialMessage);
                this.serial_networking.write(sb.toString());
            } catch (Exception e) {
                println("Networking Serial: Focus Error");
                println(e.getMessage());
            }
        }
    }

    private void sendFFTData() {
        // UNFILTERED & FILTERED ... influenced globally by the FFT filters dropdown
        // EEG/FFT readings above 125Hz don't typically travel through the skull
        // So for now, only send out 0-125Hz with 1 bin per Hz
        // Bin 10 == 10Hz frequency range
        if (this.protocol.equals("OSC")) {
            for (int i = 0; i < numExgChannels; i++) {
                for (int j = 0; j < 125; j++) {
                    msg.clearArguments();
                    msg.setAddrPattern(baseOscAddress + "/fft/ch" + i + "/bin" + j);
                    msg.add(fftBuff[i].getBand(j));
                }
                try {
                    this.osc.send(msg, this.oscNetAddress);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }
        } else if (this.protocol.equals("UDP")) {
            String outputter = "{\"type\":\"fft\",\"data\":[[";
            for (int i = 0; i < numExgChannels; i++) {
                for (int j = 0; j < 125; j++) {
                    outputter += str(fftBuff[i].getBand(j));
                    if (j != 125 - 1) {
                        outputter += ",";
                    }
                }
                if (i != numExgChannels - 1) {
                    outputter += "],[";
                } else {
                    outputter += "]]}\r\n";
                }
            }
            try {
                this.udp.send(outputter, this.ip, this.port);
            } catch (Exception e) {
                println(e.getMessage());
            }
        } else if (this.protocol.equals("LSL")) {
            float[] _dataToSend = new float[numExgChannels * 125];
            for (int i = 0; i < numExgChannels; i++) {
                for (int j = 0; j < 125; j++) {
                    _dataToSend[j + 125 * i] = fftBuff[i].getBand(j);
                }
            }
            // From LSLLink Library: The time stamps of other samples are automatically
            // derived based on the sampling rate of the stream.
            outlet_data.push_chunk(_dataToSend);
        } else if (this.protocol.equals("Serial")) {
            ///////////////////////////////// THIS OUTPUT IS DISABLED
            // Send FFT Data over Serial ...
            /*
                * for (int i=0;i<numExgChannels;i++) { serialMessage = "[" + (i+1) + ","; //clear
                * message for (int j=0;j<125;j++) { float fft_band = fftBuff[i].getBand(j);
                * String fft_band_3dec = threeDecimalPlaces.format(fft_band); serialMessage +=
                * fft_band_3dec; if (j < 125-1) { serialMessage += ","; //add a comma to
                * serialMessage to separate chan values, as long as it isn't last value... } }
                * serialMessage += "]"; try { // println(serialMessage);
                * this.serial_networking.write(serialMessage); } catch (Exception e) {
                * println(e.getMessage()); } }
                */
        }
    }

    private void sendPowerBandData() {
        // UNFILTERED & FILTERED ... influenced globally by the FFT filters dropdown
        // just like the FFT data
        int numBandPower = 5; // DELTA, THETA, ALPHA, BETA, GAMMA

        if (this.protocol.equals("OSC")) {
            for (int i = 0; i < numExgChannels; i++) {
                msg.clearArguments();
                msg.setAddrPattern(baseOscAddress + "/band-power/" + i);
                for (int j = 0; j < numBandPower; j++) {
                    msg.add(dataProcessing.avgPowerInBins[i][j]); // [CHAN][BAND]
                }
                try {
                    this.osc.send(msg, this.oscNetAddress);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }
        } else if (this.protocol.equals("UDP")) {
            // DELTA, THETA, ALPHA, BETA, GAMMA
            String outputter = "{\"type\":\"bandPower\",\"data\":[[";
            for (int i = 0; i < numExgChannels; i++) {
                for (int j = 0; j < numBandPower; j++) {
                    outputter += str(dataProcessing.avgPowerInBins[i][j]); // [CHAN][BAND]
                    if (j != numBandPower - 1) {
                        outputter += ",";
                    }
                }
                if (i != numExgChannels - 1) {
                    outputter += "],[";
                } else {
                    outputter += "]]}\r\n";
                }
            }
            try {
                this.udp.send(outputter, this.ip, this.port);
            } catch (Exception e) {
                println(e.getMessage());
            }
        } else if (this.protocol.equals("LSL")) {
            // DELTA, THETA, ALPHA, BETA, GAMMA
            float[] avgPowerLSL = new float[numExgChannels * numBandPower];
            for (int i = 0; i < numExgChannels; i++) {
                for (int j = 0; j < numBandPower; j++) {
                    avgPowerLSL[j + numBandPower * i] = dataProcessing.avgPowerInBins[i][j];
                }
            }
            outlet_data.push_chunk(avgPowerLSL);
        } else if (this.protocol.equals("Serial")) {
            for (int i = 0; i < numExgChannels; i++) {
                serialMessage = "[" + (i + 1) + ","; // clear message
                for (int j = 0; j < numBandPower; j++) {
                    float power_band = dataProcessing.avgPowerInBins[i][j];
                    String power_band_3dec = threeDecimalPlaces.format(power_band);
                    serialMessage += power_band_3dec;
                    if (j < numBandPower - 1) {
                        serialMessage += ","; // add a comma to serialMessage to separate chan values, as long as it
                                                // isn't last value...
                    }
                }
                serialMessage += "]";
                try {
                    // println(serialMessage);
                    this.serial_networking.write(serialMessage);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }
        }
    }

    private void sendNormalizedPowerBandData() {
        // UNFILTERED & FILTERED ... influenced globally by the FFT filters dropdown ...
        // just like the FFT data
        // Band Power order: DELTA, THETA, ALPHA, BETA, GAMMA
        int numBandPower = 5; 

        if (this.protocol.equals("OSC")) {

            msg.clearArguments();
            for (int i = 0; i < numBandPower; i++) {
                msg.setAddrPattern(baseOscAddress + "/average-band-power/" + i);
                msg.add(w_bandPower.getNormalizedBPSelectedChannels()[i]); // [CHAN][BAND]
                try {
                    this.osc.send(msg, this.oscNetAddress);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }
            
        } else if (this.protocol.equals("UDP")) {

            StringBuilder outputter = new StringBuilder("{\"type\":\"averageBandPower\",\"data\":[");
            for (int i = 0; i < numBandPower; i++) {
                outputter.append(str(w_bandPower.getNormalizedBPSelectedChannels()[i]));
                if (i != numBandPower - 1) {
                    outputter.append(",");
                } else {
                    outputter.append("]}\r\n");
                }
            }
            // println(outputter.toString());
            try {
                this.udp.send(outputter.toString(), this.ip, this.port);
            } catch (Exception e) {
                println(e.getMessage());
            }

        } else if (this.protocol.equals("LSL")) {

            float[] avgPowerLSL = w_bandPower.getNormalizedBPSelectedChannels();
            outlet_data.push_sample(avgPowerLSL);

        } else if (this.protocol.equals("Serial")) {

            serialMessage = "[";
            for (int i = 0; i < numBandPower; i++) {
                float power_band = w_bandPower.getNormalizedBPSelectedChannels()[i];
                String power_band_3dec = threeDecimalPlaces.format(power_band);
                serialMessage += power_band_3dec;
                if (i < numBandPower - 1) {
                    // add a comma to serialMessage to separate chan values, as long as it isn't last value...
                    serialMessage += ","; 
                }
            }
            serialMessage += "]";
            try {
                // println(serialMessage);
                this.serial_networking.write(serialMessage);
            } catch (Exception e) {
                println(e.getMessage());
            }

        }
    }

    private void sendEMGData() {
        EmgSettingsValues emgSettingsValues = dataProcessing.emgSettings.values;
        if (this.protocol.equals("OSC")) {
            for (int i = 0; i < numExgChannels; i++) {
                msg.clearArguments();
                msg.setAddrPattern(baseOscAddress + "/emg/" + i);
                msg.add(emgSettingsValues.getOutputNormalized(i));
                try {
                    this.osc.send(msg, this.oscNetAddress);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }
        } else if (this.protocol.equals("UDP")) {
            String outputter = "{\"type\":\"emg\",\"data\":[";
            for (int i = 0; i < numExgChannels; i++) {
                outputter += str(emgSettingsValues.getOutputNormalized(i));
                if (i != numExgChannels - 1) {
                    outputter += ",";
                } else {
                    outputter += "]}\r\n";
                }
            }
            try {
                this.udp.send(outputter, this.ip, this.port);
            } catch (Exception e) {
                println(e.getMessage());
            }
        } else if (this.protocol.equals("LSL")) {
            for (int i = 0; i < numExgChannels; i++) {
                dataToSend[i] = emgSettingsValues.getOutputNormalized(i);
            }
            outlet_data.push_sample(dataToSend);
        } else if (this.protocol.equals("Serial")) {
            serialMessage = "";
            for (int i = 0; i < numExgChannels; i++) {
                float emg_normalized = emgSettingsValues.getOutputNormalized(i);
                String emg_normalized_3dec = threeDecimalPlaces.format(emg_normalized);
                serialMessage += emg_normalized_3dec;
                if (i != numExgChannels - 1) {
                    serialMessage += ",";
                } else {
                    serialMessage += "\n";
                }
            }
            try {
                println(serialMessage);
                this.serial_networking.write(serialMessage);
            } catch (Exception e) {
                println(e.getMessage());
            }
        }
    }

    private void sendAccelerometerData() {
        if (this.protocol.equals("OSC")) {
            for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                msg.clearArguments();
                if (i == 0) {
                    msg.setAddrPattern(baseOscAddress + "/accelerometer/x");
                } else if (i == 1) {
                    msg.setAddrPattern(baseOscAddress + "/accelerometer/y");
                } else if (i == 2) {
                    msg.setAddrPattern(baseOscAddress + "/accelerometer/z");
                }
                msg.add(w_accelerometer.getLastAccelVal(i));
                try {
                    this.osc.send(msg, this.oscNetAddress);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }
        } else if (this.protocol.equals("UDP")) {
            String outputter = "{\"type\":\"accelerometer\",\"data\":[";
            for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                float accelData = w_accelerometer.getLastAccelVal(i);
                // Formatting in this way is resilient to internationalization
                String accelData_3dec = threeDecimalPlaces.format(accelData);
                outputter += accelData_3dec;
                if (i != NUM_ACCEL_DIMS - 1) {
                    outputter += ",";
                } else {
                    outputter += "]}\r\n";
                }
            }
            try {
                this.udp.send(outputter, this.ip, this.port);
            } catch (Exception e) {
                println(e.getMessage());
            }
        } else if (this.protocol.equals("LSL")) {
            for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                dataToSend[i] = w_accelerometer.getLastAccelVal(i);
            }
            outlet_data.push_sample(dataToSend);
        } else if (this.protocol.equals("Serial")) {
            // Data Format: +0.900,-0.042,+0.254\n
            // 7 chars per axis, including \n char for Z
            serialMessage = "";
            for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                float accelData = w_accelerometer.getLastAccelVal(i);
                String accelData_3dec = threeDecimalPlaces.format(accelData);
                if (accelData >= 0)
                    serialMessage += "+";
                serialMessage += accelData_3dec;
                if (i != NUM_ACCEL_DIMS - 1) {
                    serialMessage += ",";
                } else {
                    serialMessage += "\n";
                }
            }
            try {
                // println(serialMessage);
                this.serial_networking.write(serialMessage);
            } catch (Exception e) {
                println(e.getMessage());
            }
        }
    }

    private void sendAnalogReadData() {
        // this function is only called if the board is analog capable
        int[] analogChannels = ((AnalogCapableBoard) currentBoard).getAnalogChannels();
        List<double[]> lastData = ((AnalogCapableBoard) currentBoard).getDataWithAnalog(1);
        double[] lastSample = lastData.get(0);

        final int NUM_ANALOG_READS = analogChannels.length;

        if (this.protocol.equals("OSC")) {
            for (int i = 0; i < NUM_ANALOG_READS; i++) {
                msg.clearArguments();
                msg.setAddrPattern(baseOscAddress + "/analog/" + i);
                msg.add((int) lastSample[analogChannels[i]]);
                try {
                    this.osc.send(msg, this.oscNetAddress);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }
        } else if (this.protocol.equals("UDP")) {
            String outputter = "{\"type\":\"analog\",\"data\":[";
            for (int i = 0; i < NUM_ANALOG_READS; i++) {
                int auxData = (int) lastSample[analogChannels[i]];
                String auxData_formatted = fourLeadingPlaces.format(auxData);
                outputter += auxData_formatted;
                if (i != NUM_ANALOG_READS - 1) {
                    outputter += ",";
                } else {
                    outputter += "]}\r\n";
                }
            }
            try {
                this.udp.send(outputter, this.ip, this.port);
            } catch (Exception e) {
                println(e.getMessage());
            }
        } else if (this.protocol.equals("LSL")) {
            for (int i = 0; i < NUM_ANALOG_READS; i++) {
                dataToSend[i] = (int) lastSample[analogChannels[i]];
            }
            outlet_data.push_sample(dataToSend);
        } else if (this.protocol.equals("Serial")) {
            // Data Format: 0001,0002,0003\n or 0001,0002\n depending if Wi-Fi Shield is used
            // 5 chars per pin, including \n char for Z
            serialMessage = "";
            for (int i = 0; i < NUM_ANALOG_READS; i++) {
                int auxData = (int) lastSample[analogChannels[i]];
                String auxData_formatted = fourLeadingPlaces.format(auxData);
                serialMessage += auxData_formatted;
                if (i != NUM_ANALOG_READS - 1) {
                    serialMessage += ",";
                } else {
                    serialMessage += "\n";
                }
            }
            try {
                // println(serialMessage);
                this.serial_networking.write(serialMessage);
            } catch (Exception e) {
                println(e.getMessage());
            }
        }
    }

    private void sendDigitalReadData() {
        final int NUM_DIGITAL_READS = w_digitalRead.getNumDigitalReads();

        if (this.protocol.equals("OSC")) {
            for (int i = 0; i < NUM_DIGITAL_READS; i++) {
                msg.clearArguments();
                msg.setAddrPattern(baseOscAddress + "/digital/" + i);
                msg.add(w_digitalRead.digitalReadDots[i].getDigitalReadVal());
                try {
                    this.osc.send(msg, this.oscNetAddress);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }
        } else if (this.protocol.equals("UDP")) {
            String outputter = "{\"type\":\"digital\",\"data\":[";
            for (int i = 0; i < NUM_DIGITAL_READS; i++) {
                int auxData = w_digitalRead.digitalReadDots[i].getDigitalReadVal();
                String auxData_formatted = String.format("%d", auxData);
                outputter += auxData_formatted;
                if (i != NUM_DIGITAL_READS - 1) {
                    outputter += ",";
                } else {
                    outputter += "]}\r\n";
                }
            }
            try {
                this.udp.send(outputter, this.ip, this.port);
            } catch (Exception e) {
                println(e.getMessage());
            }
        } else if (this.protocol.equals("LSL")) {
            for (int i = 0; i < NUM_DIGITAL_READS; i++) {
                dataToSend[i] = w_digitalRead.digitalReadDots[i].getDigitalReadVal();
            }
            outlet_data.push_sample(dataToSend);
        } else if (this.protocol.equals("Serial")) {
            // Data Format: 0,1,0,1,0\n or 0,1,0\n depending if WiFi Shield is used
            // 2 chars per pin, including \n char last pin
            serialMessage = "";
            for (int i = 0; i < NUM_DIGITAL_READS; i++) {
                int auxData = w_digitalRead.digitalReadDots[i].getDigitalReadVal();
                String auxData_formatted = String.format("%d", auxData);
                serialMessage += auxData_formatted;
                if (i != NUM_DIGITAL_READS - 1) {
                    serialMessage += ",";
                } else {
                    serialMessage += "\n";
                }
            }
            try {
                // println(serialMessage);
                this.serial_networking.write(serialMessage);
            } catch (Exception e) {
                println(e.getMessage());
            }
        }
    }

    private void sendPulseData() {
        // Get data from Board that
        int numDataPoints = 2;

        if (this.protocol.equals("OSC")) {

            msg.clearArguments();
            msg.setAddrPattern(baseOscAddress + "/pulse/bpm");
            msg.add(w_pulsesensor.BPM);
            try {
                this.osc.send(msg, this.oscNetAddress);
            } catch (Exception e) {
                println(e.getMessage());
            }

            msg.clearArguments();
            msg.setAddrPattern(baseOscAddress + "/pulse/ibi");
            msg.add(w_pulsesensor.IBI);
            try {
                this.osc.send(msg, this.oscNetAddress);
            } catch (Exception e) {
                println(e.getMessage());
            }

        } else if (this.protocol.equals("UDP")) {

            StringBuilder output = new StringBuilder("{\"type\":\"pulse\",\"data\":[");
            output.append(str(w_pulsesensor.BPM));
            output.append(",");
            output.append(str(w_pulsesensor.IBI));
            output.append("]}\r\n");
            try {
                this.udp.send(output.toString(), this.ip, this.port);
            } catch (Exception e) {
                println(e.getMessage());
            }

        } else if (this.protocol.equals("LSL")) {

            float[] _dataToSend = new float[2];
            _dataToSend[0] = w_pulsesensor.BPM;
            _dataToSend[1] = w_pulsesensor.IBI;
            // From LSLLink Library: The time stamps of other samples are automatically
            // derived based on the sampling rate of the stream.
            outlet_data.push_chunk(_dataToSend);

        } else if (this.protocol.equals("Serial")) {

            serialMessage = ""; // clear message
            serialMessage += w_pulsesensor.BPM + ",";
            serialMessage += w_pulsesensor.IBI;
            try {
                this.serial_networking.write(serialMessage);
            } catch (Exception e) {
                println(e.getMessage());
            }

        }
    }// End sendPulseData

    private void sendEMGJoystickData() {

        final float[] emgJoystickXY = w_emgJoystick.getJoystickXY();

        if (this.protocol.equals("OSC")) {
            for (int i = 0; i < emgJoystickXY.length; i++) {
                msg.clearArguments();
                if (i == 0) {
                    msg.setAddrPattern(baseOscAddress + "/emg-joystick/x");
                } else if (i == 1) {
                    msg.setAddrPattern(baseOscAddress + "/emg-joystick/y");
                }
                msg.add(emgJoystickXY[i]);
                try {
                    this.osc.send(msg, this.oscNetAddress);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }
        } else if (this.protocol.equals("UDP")) {
            StringBuilder output = new StringBuilder("{\"type\":\"emgJoystick\",\"data\":[");
            for (int i = 0; i < emgJoystickXY.length; i++) {
                // Formatting in this way is resilient to internationalization
                String dataFormatted = threeDecimalPlaces.format(emgJoystickXY[i]);
                output.append(dataFormatted);
                if (i != emgJoystickXY.length - 1) {
                    output.append(",");
                } else {
                    output.append("]}\r\n");
                }
            }
            try {
                this.udp.send(output.toString(), this.ip, this.port);
            } catch (Exception e) {
                println(e.getMessage());
            }
        } else if (this.protocol.equals("LSL")) {
            for (int i = 0; i < emgJoystickXY.length; i++) {
                dataToSend[i] = emgJoystickXY[i];
            }
            outlet_data.push_sample(dataToSend);
        } else if (this.protocol.equals("Serial")) {
            // Data Format: +0.900,-0.042\n
            // 7 chars per axis, including \n char
            StringBuilder output = new StringBuilder();
            for (int i = 0; i < emgJoystickXY.length; i++) {
                float data = emgJoystickXY[i];
                String dataFormatted = threeDecimalPlaces.format(data);
                if (data >= 0)
                    output.append("+");
                    output.append(dataFormatted);
                if (i != emgJoystickXY.length - 1) {
                    output.append(",");
                } else {
                    output.append("\n");
                }
            }
            try {
                // println(serialMessage);
                this.serial_networking.write(output.toString());
            } catch (Exception e) {
                println(e.getMessage());
            }
        }
    }

    //// Add new stream function here (ex. sendWidgetData) in the same format as
    //// above

    public void quit() {
        this.isStreaming = false;
        closeNetwork();
        interrupt();
    }

    private void closeNetwork() {
        if (this.protocol.equals("OSC")) {
            try {
                this.osc.stop();
            } catch (Exception e) {
                println(e.getMessage());
            }
        } else if (this.protocol.equals("UDP")) {
            this.udp.close();
        } else if (this.protocol.equals("LSL")) {
            outlet_data.close();
        } else if (this.protocol.equals("Serial")) {
            // Close Serial Port %%%%%
            try {
                serial_networking.clear();
                serial_networking.stop();
                println("Successfully closed SERIAL/COM port " + this.portName);
            } catch (Exception e) {
                println("Failed to close SERIAL/COM port " + this.portName);
            }
        }
    }

    private void openNetwork() {
        println("Networking: " + getAttributes());
        if (this.protocol.equals("OSC")) {
            // Possibly enter a nice custom exception here
            // try {
            this.osc = new OscP5(this, this.port + 1000);
            this.oscNetAddress = new NetAddress(this.ip, this.port);
            this.msg = new OscMessage(this.baseOscAddress);
            // } catch (Exception e) {
            // }
        } else if (this.protocol.equals("UDP")) {
            this.udp = new UDP(this);
            this.udp.setBuffer(20000);
            this.udp.listen(false);
            this.udp.log(false);
            output("UDP successfully connected");
        } else if (this.protocol.equals("LSL")) {
            String stream_id = "openbcigui";
            info_data = new LSL.StreamInfo(this.streamName, this.streamType, this.numLslDataPoints,
                    currentBoard.getSampleRate(), LSL.ChannelFormat.float32, stream_id);
            outlet_data = new LSL.StreamOutlet(info_data);
        } else if (this.protocol.equals("Serial")) {
            // Open Serial Port! %%%%%
            try {
                serial_networking = new processing.serial.Serial(this.pApplet, this.portName, this.baudRate);
                serial_networking.clear();
                verbosePrint("Successfully opened SERIAL/COM: " + this.portName);
                output("Successfully opened SERIAL/COM (" + this.baudRate + "): " + this.portName);
            } catch (Exception e) {
                verbosePrint("W_Networking.pde: could not open SERIAL PORT: " + this.portName);
                println("Error: " + e);
            }
        }
    }

    // Used only to print attributes to the screen
    private StringList getAttributes() {
        StringList attributes = new StringList();
        if (this.protocol.equals("OSC")) {
            attributes.append(this.dataType);
            attributes.append(this.ip);
            attributes.append(str(this.port));
            attributes.append(this.baseOscAddress);
        } else if (this.protocol.equals("UDP")) {
            attributes.append(this.dataType);
            attributes.append(this.ip);
            attributes.append(str(this.port));
        } else if (this.protocol.equals("LSL")) {
            attributes.append(this.dataType);
            attributes.append(this.streamName);
            attributes.append(this.streamType);
            attributes.append(str(this.numLslDataPoints));
        } else if (this.protocol.equals("Serial")) {
            attributes.append(this.dataType);
            attributes.append(this.portName);
            attributes.append(str(this.baudRate));
        }
        return attributes;
    }

}

/* Dropdown Menu Callback Functions */
/**
 * @description Sets the selected protocol mode from the widget's dropdown menu
 * @param `n` {int} - Index of protocol item selected in menu
 */
public void Protocol(int protocolIndex) {
    settings.nwProtocolSave = protocolIndex;
    if (protocolIndex == 0) {
        w_networking.protocolMode = "UDP";
    } else if (protocolIndex == 1) {
        w_networking.protocolMode = "LSL";
    } else if (protocolIndex == 2) {
        w_networking.protocolMode = "OSC";
    } else if (protocolIndex == 3) {
        w_networking.protocolMode = "Serial";
        w_networking.disableCertainOutputs(
                (int) w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").getValue());
    }
    println("Networking: Protocol mode set to " + w_networking.protocolMode + ". Stopping network");
    w_networking.screenResized();
    w_networking.showCP5();
    if (!w_networking.getNetworkActive()) {
        w_networking.turnOffButton();
    }
}

public void dataType1(int n) {
    w_networking.putCP5DataIntoMap();
}

public void dataType2(int n) {
    w_networking.putCP5DataIntoMap();
}

public void dataType3(int n) {
    w_networking.putCP5DataIntoMap();
}

public void dataType4(int n) {
    w_networking.putCP5DataIntoMap();
}

public void port_name(int n) {
    w_networking.setComPortToSave(n);
    w_networking.putCP5DataIntoMap();
}

public void baud_rate(int n) {
    w_networking.putCP5DataIntoMap();
}

enum CalculationWindowSize
    {
        SECONDS1("1 sec", 1*1000),
        SECONDS10("10 sec", 10*1000),
        MINUTE1("1 min", 60*1000);

        private String name;
        private int milliseconds;
    
        CalculationWindowSize(String _name, int _millis) {
            this.name = _name;
            this.milliseconds = _millis;
        }
        
        public String  getName() {
            return name;
        }

        public int getMilliseconds() {
            return milliseconds;
        }
    }

class W_PacketLoss extends Widget {
    private Grid dataGrid;
    private PacketLossTracker packetLossTracker;

    private PacketRecord sessionPacketRecord;
    private PacketRecord streamPacketRecord;
    private PacketRecord lastMillisPacketRecord;

    private ControlP5 cp5;
    private ScrollableList tableDropdown;
    
    private final int padding = 5;
    private final int cellHeight = 20;

    private CalculationWindowSize tableWindowSize = CalculationWindowSize.SECONDS10;

    W_PacketLoss(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        dataGrid = new Grid(5/*numRows*/, 4/*numCols*/, cellHeight);
        packetLossTracker = ((Board)currentBoard).getPacketLossTracker();
        sessionPacketRecord = packetLossTracker.getSessionPacketRecord();
        streamPacketRecord = packetLossTracker.getStreamPacketRecord();

        dataGrid.setString("entire session", 0, 1);
        dataGrid.setString("contiguous stream", 0, 2);

        dataGrid.setString("packets lost", 1, 0);
        dataGrid.setString("packets received", 2, 0);
        dataGrid.setString("packets expected", 3, 0);
        dataGrid.setString("% packets lost", 4, 0);

        createTableDropdown();

        // call once in constructor
        screenResized();
    }

    private void createTableDropdown() {
        tableDropdown = cp5_widget.addScrollableList("TableTimeWindow")
            .setDrawOutline(false)
            .setOpen(false)
            .setColor(settings.dropdownColors)
            .setOutlineColor(OBJECT_BORDER_GREY)
            .setBarHeight(cellHeight) //height of top/primary bar
            .setItemHeight(cellHeight) //height of all item/dropdown bars
            ;

        // for each entry in the enum, add it to the dropdown.
        for (CalculationWindowSize value : CalculationWindowSize.values()) {
            // this will store the *actual* enum object inside the dropdown!
            tableDropdown.addItem(value.getName(), value);
        }

        tableDropdown.getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(tableWindowSize.getName())
            .setFont(h5)
            .setSize(12)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3)
            ;
        tableDropdown.getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText("VALUE LABEL")
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;

        tableDropdown.onChange(new CallbackListener() {
            public void controlEvent(CallbackEvent event) {
                int val = (int)tableDropdown.getValue();
                Map bob = tableDropdown.getItem(val);
                tableWindowSize = (CalculationWindowSize)bob.get("value");
            }
        });
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        lastMillisPacketRecord = packetLossTracker.getCumulativePacketRecordForLast(tableWindowSize.getMilliseconds());

        dataGrid.setString(nfc(sessionPacketRecord.numLost), 1, 1);
        dataGrid.setString(nfc(sessionPacketRecord.numReceived), 2, 1);
        dataGrid.setString(nfc(sessionPacketRecord.getNumExpected()), 3, 1);
        dataGrid.setString(nf(sessionPacketRecord.getLostPercent(), 0, 4 /*decimals*/) + " %", 4, 1);

        dataGrid.setString(nfc(streamPacketRecord.numLost), 1, 2);
        dataGrid.setString(nfc(streamPacketRecord.numReceived), 2, 2);
        dataGrid.setString(nfc(streamPacketRecord.getNumExpected()), 3, 2);
        dataGrid.setString(nf(streamPacketRecord.getLostPercent(), 0, 4 /*decimals*/) + " %", 4, 2);

        dataGrid.setString(nfc(lastMillisPacketRecord.numLost), 1, 3);
        dataGrid.setString(nfc(lastMillisPacketRecord.numReceived), 2, 3);
        dataGrid.setString(nfc(lastMillisPacketRecord.getNumExpected()), 3, 3);
        dataGrid.setString(nf(lastMillisPacketRecord.getLostPercent(), 0, 4 /*decimals*/) + " %", 4, 3);

        // place dropdown on table
        RectDimensions cellDim = dataGrid.getCellDims(0, 3);
        tableDropdown.setPosition(cellDim.x, cellDim.y);

        int dropdownHeight = tableDropdown.getBarHeight() + tableDropdown.getBarHeight() * tableDropdown.getItems().size();
        tableDropdown.setSize(cellDim.w, dropdownHeight);
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        pushStyle();
        fill(OPENBCI_DARKBLUE);
        textFont(p5, 12);
        text("Session length: " + sessionTimeElapsed.toString(), x + padding, y + 15);
        text("Stream length: " + streamTimeElapsed.toString(), x + padding, y + 35);
        popStyle();

        dataGrid.draw();
    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        dataGrid.setDim(x, y + 50, w);
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)

    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

    }

    private float calcPercent(float total, float fraction) {
        if(total == 0) {
            return 0;
        }

        return fraction * 100 / total;
    }

};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    W_playback.pde (ie "Playback History")
//
//    Allow user to load playback files from within GUI without having to restart the system
//                       Created: Richard Waltman - August 2018
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



class W_playback extends Widget {
    //allow access to dataProcessing
    DataProcessing dataProcessing;
    //Set up variables for Playback widget
    ControlP5 cp5_playback;
    Button selectPlaybackFileButton;
    MenuList playbackMenuList;
    //Used for spacing
    int padding = 10;
    List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();

    private boolean menuHasUpdated = false;

    W_playback(PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        cp5_playback = new ControlP5(pApplet);
        cp5_playback.setGraphics(ourApplet, 0,0);
        cp5_playback.setAutoDraw(false);

        int initialWidth = w - padding*2;
        createPlaybackMenuList(cp5_playback, "playbackMenuList", x + padding/2, y + 2, initialWidth, h - padding*2, p3);
        createSelectPlaybackFileButton("selectPlaybackFile_Session", "Select Playback File", x + w/2 - (padding*2), y - navHeight + 2, 200, navHeight - 6);
    }

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
        if (!menuHasUpdated) {
            refreshPlaybackList();
            menuHasUpdated = true;
        }
        //Lock the MenuList if Widget selector is open, otherwise update
        if (cp5_widget.get(ScrollableList.class, "WidgetSelector").isOpen() || topNav.getDropdownMenuIsOpen()) {
            if (!playbackMenuList.isLock()) {
                playbackMenuList.lock();
                playbackMenuList.setUpdate(false);
            }
        } else {
            if (playbackMenuList.isLock()) {
                playbackMenuList.unlock();
                playbackMenuList.setUpdate(true);
            }
            playbackMenuList.updateMenu();
        }
        lockElementsOnOverlapCheck(cp5ElementsToCheck);
    }

    public void draw() {
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        //x,y,w,h are the positioning variables of the Widget class
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x-1, y, w+1, h);
        //Add text if needed
        /*
        fill(OPENBCI_DARKBLUE);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("PLAYBACK FILE", x + padding, y + padding);
        */
        popStyle();

        cp5_playback.draw();
    } //end draw loop

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        //**IMPORTANT FOR CP5**//
        //This makes the cp5 objects within the widget scale properly
        cp5_playback.setGraphics(pApplet, 0, 0);

        //Resize and position cp5 objects within this widget
        selectPlaybackFileButton.setPosition(x + w - selectPlaybackFileButton.getWidth() - 2, y - navHeight + 2);

        playbackMenuList.setPosition(x + padding/2, y + 2);
        playbackMenuList.setSize(w - padding*2, h - padding*2);
        refreshPlaybackList();
    }

    public void refreshPlaybackList() {

        File f = new File(userPlaybackHistoryFile);
        if (!f.exists()) {
            println("OpenBCI_GUI::RefreshPlaybackList: Playback history file not found.");
            return;
        }

        try {
            playbackMenuList.items.clear();
            loadPlaybackHistoryJSON = loadJSONObject(userPlaybackHistoryFile);
            JSONArray loadPlaybackHistoryJSONArray = loadPlaybackHistoryJSON.getJSONArray("playbackFileHistory");
            //println("Array Size:" + loadPlaybackHistoryJSONArray.size());
            int currentFileNameToDraw = 0;
            for (int i = loadPlaybackHistoryJSONArray.size() - 1; i >= 0; i--) { //go through array in reverse since using append
                JSONObject loadRecentPlaybackFile = loadPlaybackHistoryJSONArray.getJSONObject(i);
                int fileNumber = loadRecentPlaybackFile.getInt("recentFileNumber");
                String shortFileName = loadRecentPlaybackFile.getString("id");
                String longFilePath = loadRecentPlaybackFile.getString("filePath");

                int totalPadding = padding + playbackMenuList.padding;
                shortFileName = shortenString(shortFileName, w-totalPadding*2.f, p4);
                //add as an item in the MenuList
                playbackMenuList.addItem(shortFileName, Integer.toString(fileNumber), longFilePath);
                currentFileNameToDraw++;
            }
            playbackMenuList.updateMenu();
        } catch (NullPointerException e) {
            println("PlaybackWidget: Playback history file not found.");
        }
    }

    private void createSelectPlaybackFileButton(String name, String text, int _x, int _y, int _w, int _h) {
        selectPlaybackFileButton = createButton(cp5_playback, name, text, _x, _y, _w, _h);
        selectPlaybackFileButton.setBorderColor(OBJECT_BORDER_GREY);
        selectPlaybackFileButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                output("Select a file for playback");
                selectInput("Select a pre-recorded file for playback:", "playbackSelectedWidgetButton");
            }
        });
        selectPlaybackFileButton.setDescription("Click to open a dialog box to select an OpenBCI playback file (.txt or .csv).");
        cp5ElementsToCheck.add((controlP5.Controller)selectPlaybackFileButton);
    }

    private void createPlaybackMenuList(ControlP5 _cp5, String name, int _x, int _y, int _w, int _h, PFont font) {
        playbackMenuList = new MenuList(_cp5, name, _w, _h, font);
        playbackMenuList.setPosition(_x, _y);
        playbackMenuList.addCallback(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (theEvent.getAction() == ControlP5.ACTION_BROADCAST) {
                    //Check to make sure value of clicked item is in valid range. Fixes #480
                    float valueOfItem = playbackMenuList.getValue();
                    if (valueOfItem < 0 || valueOfItem > (playbackMenuList.items.size() - 1) ) {
                        //println("CP: No such item " + value + " found in list.");
                    } else {
                        Map m = playbackMenuList.getItem(PApplet.parseInt(valueOfItem));
                        //println("got a menu event from item " + value + " : " + m);
                        userSelectedPlaybackMenuList(m.get("copy").toString(), PApplet.parseInt(valueOfItem));
                    }
                }
            }
        });
        playbackMenuList.scrollerLength = 40;
    }
}; //end Playback widget class

//////////////////////////////////////
// GLOBAL FUNCTIONS BELOW THIS LINE //
//////////////////////////////////////

//Called when user selects a playback file from controlPanel dialog box
public void playbackFileSelected(File selection) {
    if (selection == null) {
        println("DataLogging: playbackSelected: Window was closed or the user hit cancel.");
    } else {
        println("DataLogging: playbackSelected: User selected " + selection.getAbsolutePath());
        //Set the name of the file
        playbackFileSelected(selection.getAbsolutePath(), selection.getName());
    }
}


//Activated when user selects a file using the "Select Playback File" button in PlaybackHistory
public void playbackSelectedWidgetButton(File selection) {
    if (selection == null) {
        println("W_Playback: playbackSelected: Window was closed or the user hit cancel.");
    } else {
        println("W_Playback: playbackSelected: User selected " + selection.getAbsolutePath());
        if (playbackFileSelected(selection.getAbsolutePath(), selection.getName())) {
            // restart the session with the new file
            requestReinit();
        }
    }
}

//Activated when user selects a file using the recent file MenuList
public void userSelectedPlaybackMenuList (String filePath, int listItem) {
    if (new File(filePath).isFile()) {
        playbackFileFromList(filePath, listItem);
        // restart the session with the new file
        requestReinit();
    } else {
        verbosePrint("Playback: " + filePath);
        outputError("Playback: Selected file does not exist. Try another file or clear settings to remove this entry.");
    }
}

//Called when user selects a playback file from a list
public void playbackFileFromList (String longName, int listItem) {
    String shortName = "";
    //look at the JSON file to set the range menu using number of recent file entries
    try {
        savePlaybackHistoryJSON = loadJSONObject(userPlaybackHistoryFile);
        JSONArray recentFilesArray = savePlaybackHistoryJSON.getJSONArray("playbackFileHistory");
        JSONObject playbackFile = recentFilesArray.getJSONObject(-listItem + recentFilesArray.size() - 1);
        shortName = playbackFile.getString("id");
        playbackHistoryFileExists = true;
    } catch (NullPointerException e) {
        //println("Playback history JSON file does not exist. Load first file to make it.");
        playbackHistoryFileExists = false;
    }
    playbackFileSelected(longName, shortName);
}

//Handles the work for the above cases
public boolean playbackFileSelected (String longName, String shortName) {
    playbackData_fname = longName;
    playbackData_ShortName = shortName;
    //Process the playback file, check if SD card file or something else
    try {
        BufferedReader brTest = new BufferedReader(new FileReader(longName));
        String line = brTest.readLine();
        if (line.equals("%OpenBCI Raw EEG Data") || line.equals("%OpenBCI Raw EXG Data")) {
            verbosePrint("PLAYBACK: Found OpenBCI Header in File!");
            sdData_fname = "N/A";
            for (int i = 0; i < 3; i++) {
                line = brTest.readLine();
                verbosePrint("PLAYBACK: " + line);
            }
            if (!line.startsWith("%Board")) {
                playbackData_fname = "N/A";
                playbackData_ShortName = "N/A";
                outputError("Found GUI v4 or earlier file. Please convert this file using the provided Python script.");
                PopupMessage msg = new PopupMessage("GUI v4 to v5 File Converter", "Found GUI v4 or earlier file. Please convert this file using the provided Python script. Press the button below to access this open-source fix.", "LINK", "https://github.com/OpenBCI/OpenBCI_GUI/tree/development/tools");
                return false;
            }    
        } else if (line.equals("%STOP AT")) {
            verbosePrint("PLAYBACK: Found SD File Header in File!");
            playbackData_fname = "N/A";
            sdData_fname = longName;
        } else {
            outputError("ERROR: Tried to load an unsupported file for playback! Please try a valid file.");
            playbackData_fname = "N/A";
            playbackData_ShortName = "N/A";
            sdData_fname = "N/A";   
            return false;
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
        return false;
    } catch (IOException e) {
        e.printStackTrace();
        return false;
    }

    //Output new playback settings to GUI as success
    outputSuccess("You have selected \""
    + shortName + "\" for playback.");

    File f = new File(userPlaybackHistoryFile);
    if (!f.exists()) {
        println("OpenBCI_GUI::playbackFileSelected: Playback history file not found.");
        playbackHistoryFileExists = false;
    } else {
        try {
            savePlaybackHistoryJSON = loadJSONObject(userPlaybackHistoryFile);
            JSONArray recentFilesArray = savePlaybackHistoryJSON.getJSONArray("playbackFileHistory");
            playbackHistoryFileExists = true;
        } catch (RuntimeException e) {
            outputError("Found an error in UserPlaybackHistory.json. Deleting this file. Please, Restart the GUI.");
            File file = new File(userPlaybackHistoryFile);
            if (!file.isDirectory()) {
                file.delete();
            }
        }
    }
    
    //add playback file that was processed to the JSON history
    savePlaybackFileToHistory(longName);
    return true;
}

public void savePlaybackFileToHistory(String fileName) {
    int maxNumHistoryFiles = 36;
    if (playbackHistoryFileExists) {
        println("Found user playback history file!");
        savePlaybackHistoryJSON = loadJSONObject(userPlaybackHistoryFile);
        JSONArray recentFilesArray = savePlaybackHistoryJSON.getJSONArray("playbackFileHistory");
        //println("ARRAYSIZE-Check1: " + int(recentFilesArray.size()));
        //Recent file has recentFileNumber=0, and appears at the end of the JSON array
        //check if already in the list, if so, remove from the list
        removePlaybackFileFromHistory(recentFilesArray, playbackData_fname);
        //next, increment fileNumber of all current entries +1
        for (int i = 0; i < recentFilesArray.size(); i++) {
            JSONObject playbackFile = recentFilesArray.getJSONObject(i);
            playbackFile.setInt("recentFileNumber", recentFilesArray.size()-i);
            //println(recentFilesArray.size()-i);
            playbackFile.setString("id", playbackFile.getString("id"));
            playbackFile.setString("filePath", playbackFile.getString("filePath"));
            recentFilesArray.setJSONObject(i, playbackFile);
        }
        //println("ARRAYSIZE-Check2: " + int(recentFilesArray.size()));
        //append selected playback file to position 1 at the end of the JSONArray
        JSONObject mostRecentFile = new JSONObject();
        mostRecentFile.setInt("recentFileNumber", 0);
        mostRecentFile.setString("id", playbackData_ShortName);
        mostRecentFile.setString("filePath", playbackData_fname);
        recentFilesArray.append(mostRecentFile);
        //remove entries greater than max num files
        if (recentFilesArray.size() >= maxNumHistoryFiles) {
            for (int i = 0; i <= recentFilesArray.size()-maxNumHistoryFiles; i++) {
                recentFilesArray.remove(i);
                println("ARRAY INDEX " + i + " REMOVED----");
            }
        }
        //println("ARRAYSIZE-Check3: " + int(recentFilesArray.size()));
        //printArray(recentFilesArray);

        //save the JSON array and file
        savePlaybackHistoryJSON.setJSONArray("playbackFileHistory", recentFilesArray);
        saveJSONObject(savePlaybackHistoryJSON, userPlaybackHistoryFile);

    } else if (!playbackHistoryFileExists) {
        println("Playback history file not found. making a new one.");
        //do this if the file does not exist
        JSONObject newHistoryFile;
        newHistoryFile = new JSONObject();
        JSONArray newHistoryFileArray = new JSONArray();
        //save selected playback file to position 1 in recent file history
        JSONObject mostRecentFile = new JSONObject();
        mostRecentFile.setInt("recentFileNumber", 0);
        mostRecentFile.setString("id", playbackData_ShortName);
        mostRecentFile.setString("filePath", playbackData_fname);
        newHistoryFileArray.setJSONObject(0, mostRecentFile);
        //newHistoryFile.setJSONArray("")

        //save the JSON array and file
        newHistoryFile.setJSONArray("playbackFileHistory", newHistoryFileArray);
        saveJSONObject(newHistoryFile, userPlaybackHistoryFile);

        //now the file exists!
        println("Playback history JSON has been made!");
        playbackHistoryFileExists = true;
    }
}

public void removePlaybackFileFromHistory(JSONArray array, String _filePath) {
    //check if already in the list, if so, remove from the list
    for (int i = 0; i < array.size(); i++) {
        JSONObject playbackFile = array.getJSONObject(i);
        //println("CHECKING " + i + " : " + playbackFile.getString("id") + " == " + fileName + " ?");
        if (playbackFile.getString("filePath").equals(_filePath)) {
            array.remove(i);
            //println("REMOVED: " + fileName);
        }
    }
}

////////////////////////////////////////////////////
//
//    W_PulseSensor.pde
//
//    Created: Joel Murphy, Spring 2017
//
///////////////////////////////////////////////////,

class W_PulseSensor extends Widget {

    //to see all core variables/methods of the Widget class, refer to Widget.pde
    //put your custom variables here...
    int graphStroke = 0xFFD2D2D2;
    int graphBG = 0xFFF5F5F5;
    int textColor = 0xFF000000;

    // Pulse Sensor Visualizer Stuff
    int count = 0;
    int heart = 0;
    int PulseBuffSize = 3*currentBoard.getSampleRate(); // Originally 400
    int BPMbuffSize = 100;

    int PulseWindowWidth;
    int PulseWindowHeight;
    int PulseWindowX;
    int PulseWindowY;
    int BPMwindowWidth;
    int BPMwindowHeight;
    int BPMwindowX;
    int BPMwindowY;
    int BPMposX;
    int BPMposY;
    int IBIposX;
    int IBIposY;
    int padding = 15;
    int eggshell;
    int pulseWave;
    int[] PulseWaveY;      // HOLDS HEARTBEAT WAVEFORM DATA
    int[] BPMwaveY;        // HOLDS BPM WAVEFORM DATA
    boolean rising;

    // Synthetic Wave Generator Stuff
    float theta;  // Start angle at 0
    float amplitude;  // Height of wave
    int syntheticMultiplier;
    long thisTime;
    long thatTime;
    int refreshRate;

    // Pulse Sensor Beat Finder Stuff
    // ASSUMES 250Hz SAMPLE RATE
    int[] rate;                    // array to hold last ten IBI values
    int sampleCounter;          // used to determine pulse timing
    int lastBeatTime;           // used to find IBI
    int P =512;                      // used to find peak in pulse wave, seeded
    int T = 512;                     // used to find trough in pulse wave, seeded
    int thresh = 530;                // used to find instant moment of heart beat, seeded
    int amp = 0;                   // used to hold amplitude of pulse waveform, seeded
    boolean firstBeat = true;        // used to seed rate array so we startup with reasonable BPM
    boolean secondBeat = false;      // used to seed rate array so we startup with reasonable BPM
    int BPM;                   // int that holds raw Analog in 0. updated every 2mS
    int Signal;                // holds the incoming raw data
    int IBI = 600;             // int that holds the time interval between beats! Must be seeded!
    boolean Pulse = false;     // "True" when User's live heartbeat is detected. "False" when not a "live beat".
    int lastProcessedDataPacketInd = 0;
    private Button analogModeButton;

    private AnalogCapableBoard analogBoard;

    W_PulseSensor(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        analogBoard = (AnalogCapableBoard)currentBoard;

        // Pulse Sensor Stuff
        eggshell = color(255, 253, 248);
        pulseWave = BOLD_RED;

        PulseWaveY = new int[PulseBuffSize];
        BPMwaveY = new int[BPMbuffSize];
        rate = new int[10];
        setPulseWidgetVariables();
        initializePulseFinderVariables();

        createAnalogModeButton("pulseSensorAnalogModeButton", "Turn Analog Read On", (int)(x0 + 1), (int)(y0 + navHeight + 1), 128, navHeight - 3, p5, 12, colorNotPressed, OPENBCI_DARKBLUE);
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        if(currentBoard instanceof DataSourcePlayback) {
            if (((DataSourcePlayback)currentBoard) instanceof AnalogCapableBoard
                && (!((AnalogCapableBoard)currentBoard).isAnalogActive())) {
                    return;
            }
        }

        List<double[]> allData = currentBoard.getData(PulseBuffSize);
        int[] analogChannels = analogBoard.getAnalogChannels();

        for (int i=0; i < PulseBuffSize; i++ ) {
            int signal = (int)(allData.get(i)[analogChannels[0]]);
            //processSignal(signal);
            PulseWaveY[i] = signal;
        }

        double[][] frameData = currentBoard.getFrameData();
        for (int i = 0; i < frameData[0].length; i++)
        {
            int signal = (int)(frameData[analogChannels[0]][i]);
            processSignal(signal);
        }

        //ignore top left button interaction when widgetSelector dropdown is active
        List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();
        cp5ElementsToCheck.add((controlP5.Controller)analogModeButton);
        lockElementsOnOverlapCheck(cp5ElementsToCheck);

        if (!analogBoard.canDeactivateAnalog()) {
            analogModeButton.setLock(true);
            analogModeButton.getCaptionLabel().setText("Analog Read On");
            analogModeButton.setColorBackground(BUTTON_LOCKED_GREY);
        }
    }

    private void updateOnOffButton() {
        if (analogBoard.isAnalogActive()) {	
            
            analogModeButton.setOn();
        }
        else {
            	
            analogModeButton.setOff();
        }
    }

    public void addBPM(int bpm) {
        for(int i=0; i<BPMwaveY.length-1; i++){
            BPMwaveY[i] = BPMwaveY[i+1];
        }
        BPMwaveY[BPMwaveY.length-1] = bpm;
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)
        //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        pushStyle();

        fill(graphBG);
        stroke(graphStroke);
        rect(PulseWindowX,PulseWindowY,PulseWindowWidth,PulseWindowHeight);
        rect(BPMwindowX,BPMwindowY,BPMwindowWidth,BPMwindowHeight);

        fill(50);
        textFont(p4, 16);
        textAlign(LEFT,CENTER);
        text("BPM "+BPM, BPMposX, BPMposY);
        text("IBI "+IBI+"mS", IBIposX, IBIposY);

        if (analogBoard.isAnalogActive()) {
            drawWaves();
        }

        popStyle();

    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        setPulseWidgetVariables();
        analogModeButton.setPosition((int)(x0 + 1), (int)(y0 + navHeight + 1));
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
    }

    public void createAnalogModeButton(String name, String text, int _x, int _y, int _w, int _h, PFont _font, int _fontSize, int _bg, int _textColor) {
        analogModeButton = createButton(cp5_widget, name, text, _x, _y, _w, _h, 0, _font, _fontSize, _bg, _textColor, BUTTON_HOVER, BUTTON_PRESSED, OBJECT_BORDER_GREY, 0);
        analogModeButton.setSwitch(true);
        analogModeButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                if (!analogBoard.isAnalogActive()) {
                    analogBoard.setAnalogActive(true);
                    analogModeButton.getCaptionLabel().setText("Turn Analog Read Off");	
                    output("Starting to read analog inputs on pin marked D11.");
                    w_analogRead.toggleAnalogReadButton(true);
                    w_accelerometer.accelBoardSetActive(false);
                    w_digitalRead.toggleDigitalReadButton(false);
                } else {
                    analogBoard.setAnalogActive(false);
                    analogModeButton.getCaptionLabel().setText("Turn Analog Read On");
                    output("Starting to read accelerometer");
                    w_analogRead.toggleAnalogReadButton(false);
                    w_accelerometer.accelBoardSetActive(true);
                    w_digitalRead.toggleDigitalReadButton(false);
                }
            }
        });
        String _helpText = (selectedProtocol == BoardProtocol.WIFI) ? 
            "Click this button to activate/deactivate analog read on Cyton pins A5(D11) and A6(D12)." :
            "Click this button to activate/deactivate analog read on Cyton pins A5(D11), A6(D12) and A7(D13)."
            ;
        analogModeButton.setDescription(_helpText);
    }

    public void toggleAnalogReadButton(boolean _value) {
        String s = _value ? "Turn Analog Read Off" : "Turn Analog Read On";
        analogModeButton.getCaptionLabel().setText(s);
        if (_value) {
            analogModeButton.setOn();
        } else {
            analogModeButton.setOff();
        }
    }

    //add custom functions here
    public void setPulseWidgetVariables(){
        PulseWindowWidth = ((w/4)*3) - padding;
        PulseWindowHeight = h - padding *2;
        PulseWindowX = x + padding;
        PulseWindowY = y + h - PulseWindowHeight - padding;

        BPMwindowWidth = w/4 - (padding + padding/2);
        BPMwindowHeight = PulseWindowHeight; // - padding;
        BPMwindowX = PulseWindowX + PulseWindowWidth + padding/2;
        BPMwindowY = PulseWindowY; // + padding;

        BPMposX = BPMwindowX + padding/2;
        BPMposY = y - padding; // BPMwindowHeight + int(float(padding)*2.5);
        IBIposX = PulseWindowX + PulseWindowWidth/2; // + padding/2
        IBIposY = y - padding;
    }

    public void initializePulseFinderVariables(){
        sampleCounter = 0;
        lastBeatTime = 0;
        P = 512;
        T = 512;
        thresh = 530;
        amp = 0;
        firstBeat = true;
        secondBeat = false;
        BPM = 0;
        Signal = 512;
        IBI = 600;
        Pulse = false;

        theta = 0.0f;
        amplitude = 300;
        syntheticMultiplier = 1;

        thatTime = millis();

        for(int i=0; i<PulseWaveY.length; i++){
            PulseWaveY[i] = Signal;
        }

        for(int i=0; i<BPMwaveY.length; i++){
            BPMwaveY[i] = BPM;
        }

    }

    public void drawWaves(){
        int xi, yi;
        noFill();
        strokeWeight(1);
        stroke(pulseWave);
        beginShape();                                  // using beginShape() renders fast
        for(int i=0; i<PulseWaveY.length; i++){
            xi = PApplet.parseInt(map(i,0, PulseWaveY.length-1,0, PulseWindowWidth-1));
            xi += PulseWindowX;
            yi = PApplet.parseInt(map(PulseWaveY[i],0.0f,1023.0f,
                PApplet.parseFloat(PulseWindowY + PulseWindowHeight),PApplet.parseFloat(PulseWindowY)));
            vertex(xi, yi);
        }
        endShape();

        strokeWeight(2);
        stroke(pulseWave);
        beginShape();                                  // using beginShape() renders fast
        for(int i=0; i<BPMwaveY.length; i++){
            xi = PApplet.parseInt(map(i,0, BPMwaveY.length-1,0, BPMwindowWidth-1));
            xi += BPMwindowX;
            yi = PApplet.parseInt(map(BPMwaveY[i], 0.0f,200.0f,
                PApplet.parseFloat(BPMwindowY + BPMwindowHeight), PApplet.parseFloat(BPMwindowY)));
            vertex(xi, yi);
        }
        endShape();

    }

    // THIS IS THE BEAT FINDING FUNCTION
    // BASED ON CODE FROM World Famous Electronics, MAKERS OF PULSE SENSOR
    // https://github.com/WorldFamousElectronics/PulseSensor_Amped_Arduino
    public void processSignal(int sample){                         // triggered when Timer2 counts to 124
        // cli();                                      // disable interrupts while we do this
        // Signal = analogRead(pulsePin);              // read the Pulse Sensor
        sampleCounter += (4 * syntheticMultiplier);                         // keep track of the time in mS with this variable
        int N = sampleCounter - lastBeatTime;       // monitor the time since the last beat to avoid noise

            //  find the peak and trough of the pulse wave
        if(sample < thresh && N > (IBI/5)*3){       // avoid dichrotic noise by waiting 3/5 of last IBI
            if (sample < T){                        // T is the trough
                T = sample;                         // keep track of lowest point in pulse wave
            }
        }

        if(sample > thresh && sample > P){          // thresh condition helps avoid noise
            P = sample;                             // P is the peak
        }                                        // keep track of highest point in pulse wave

        //  NOW IT'S TIME TO LOOK FOR THE HEART BEAT
        // signal surges up in value every time there is a pulse
        if (N > 250){                                   // avoid high frequency noise
            if ( (sample > thresh) && (Pulse == false) && (N > (IBI/5)*3) ){
                Pulse = true;                               // set the Pulse flag when we think there is a pulse
                IBI = sampleCounter - lastBeatTime;         // measure time between beats in mS
                lastBeatTime = sampleCounter;               // keep track of time for next pulse

                if(secondBeat){                        // if this is the second beat, if secondBeat == TRUE
                    secondBeat = false;                  // clear secondBeat flag
                    for(int i=0; i<=9; i++){             // seed the running total to get a realisitic BPM at startup
                        rate[i] = IBI;
                    }
                }

                if(firstBeat){                         // if it's the first time we found a beat, if firstBeat == TRUE
                    firstBeat = false;                   // clear firstBeat flag
                    secondBeat = true;                   // set the second beat flag
                    // sei();                               // enable interrupts again
                    return;                              // IBI value is unreliable so discard it
                }


                // keep a running total of the last 10 IBI values
                int runningTotal = 0;                  // clear the runningTotal variable

                for(int i=0; i<=8; i++){                // shift data in the rate array
                    rate[i] = rate[i+1];                  // and drop the oldest IBI value
                    runningTotal += rate[i];              // add up the 9 oldest IBI values
                }

                rate[9] = IBI;                          // add the latest IBI to the rate array
                runningTotal += rate[9];                // add the latest IBI to runningTotal
                runningTotal /= 10;                     // average the last 10 IBI values
                BPM = 60000/runningTotal;               // how many beats can fit into a minute? that's BPM!
                BPM = constrain(BPM,0,200);
                addBPM(BPM);
            }
        }

        if (sample < thresh && Pulse == true){   // when the values are going down, the beat is over
            // digitalWrite(blinkPin,LOW);            // turn off pin 13 LED
            Pulse = false;                         // reset the Pulse flag so we can do it again
            amp = P - T;                           // get amplitude of the pulse wave
            thresh = amp/2 + T;                    // set thresh at 50% of the amplitude
            P = thresh;                            // reset these for next time
            T = thresh;
        }

        if (N > 2500){                           // if 2.5 seconds go by without a beat
            thresh = 530;                          // set thresh default
            P = 512;                               // set P default
            T = 512;                               // set T default
            lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date
            firstBeat = true;                      // set these to avoid noise
            secondBeat = false;                    // when we get the heartbeat back
        }

        // sei();                                   // enable interrupts when youre done!
    }// end processSignal


};

//////////////////////////////////////////////////////
//                                                  //
//                  W_Spectrogram.pde               //
//                                                  //
//                                                  //
//    Created by: Richard Waltman, September 2019   //
//                                                  //
//////////////////////////////////////////////////////

class W_Spectrogram extends Widget {

    //to see all core variables/methods of the Widget class, refer to Widget.pde
    public ChannelSelect spectChanSelectTop;
    public ChannelSelect spectChanSelectBot;
    private boolean chanSelectWasOpen = false;
    List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();

    int xPos = 0;
    int hueLimit = 160;

    PImage dataImg;
    int dataImageW = 1800;
    int dataImageH = 200;
    int prevW = 0;
    int prevH = 0;
    float scaledWidth;
    float scaledHeight;
    int graphX = 0;
    int graphY = 0;
    int graphW = 0;
    int graphH = 0;
    int midLineY = 0;

    private int lastShift = 0;
    private int scrollSpeed = 100; // == 10Hz
    private boolean wasRunning = false;

    int paddingLeft = 54;
    int paddingRight = 26;   
    int paddingTop = 8;
    int paddingBottom = 50;
    int numHorizAxisDivs = 3;
    int numVertAxisDivs = 8;
    final int[][] vertAxisLabels = {
        {20, 15, 10, 5, 0, 5, 10, 15, 20},
        {40, 30, 20, 10, 0, 10, 20, 30, 40},
        {60, 45, 30, 15, 0, 15, 30, 45, 60},
        {100, 75, 50, 25, 0, 25,  50, 75, 100},
        {120, 90, 60, 30, 0, 30, 60, 90, 120},
        {250, 188, 125, 63, 0, 63, 125, 188, 250}
    };
    int[] vertAxisLabel;
    final float[][] horizAxisLabels = {
        {30, 25, 20, 15, 10, 5, 0},
        {6, 5, 4, 3, 2, 1, 0},
        {3, 2, 1, 0},
        {1.5f, 1, .5f, 0},
        {1, .5f, 0}
    };
    float[] horizAxisLabel;
    StringList horizAxisLabelStrings;

    float[] topFFTAvg;
    float[] botFFTAvg;

    W_Spectrogram(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        //Add channel select dropdown to this widget
        spectChanSelectTop = new ChannelSelect(pApplet, this, x, y, w, navH, "Spectrogram_Channels_Top");
        spectChanSelectBot = new ChannelSelect(pApplet, this, x, y + navH, w, navH, "Spectrogram_Channels_Bot");
        activateDefaultChannels();
        spectChanSelectTop.setIsDualChannelSelect(true);
        spectChanSelectBot.setIsDualChannelSelect(true);
        spectChanSelectBot.setIsFirstRowChannelSelect(false);
        cp5ElementsToCheck.addAll(spectChanSelectTop.getCp5ElementsForOverlapCheck());
        cp5ElementsToCheck.addAll(spectChanSelectBot.getCp5ElementsForOverlapCheck());

        xPos = w - 1; //draw on the right, and shift pixels to the left
        prevW = w;
        prevH = h;
        graphX = x + paddingLeft;
        graphY = y + paddingTop;
        graphW = w - paddingRight - paddingLeft;
        graphH = h - paddingBottom - paddingTop;

        settings.spectMaxFrqSave = 1;
        settings.spectSampleRateSave = 2;
        settings.spectLogLinSave = 0;
        vertAxisLabel = vertAxisLabels[settings.spectMaxFrqSave];
        horizAxisLabel = horizAxisLabels[settings.spectSampleRateSave];
        horizAxisLabelStrings = new StringList();
        //Fetch/calculate the time strings for the horizontal axis ticks
        fetchTimeStrings(numHorizAxisDivs);

        //This is the protocol for setting up dropdowns.
        //Note that these 3 dropdowns correspond to the 3 global functions below
        //You just need to make sure the "id" (the 1st String) has the same name as the corresponding function
        addDropdown("SpectrogramMaxFreq", "Max Freq", Arrays.asList(settings.spectMaxFrqArray), settings.spectMaxFrqSave);
        addDropdown("SpectrogramSampleRate", "Window", Arrays.asList(settings.spectSampleRateArray), settings.spectSampleRateSave);
        addDropdown("SpectrogramLogLin", "Log/Lin", Arrays.asList(settings.fftLogLinArray), settings.spectLogLinSave);

        //Resize the height of the data image using default 
        dataImageH = vertAxisLabel[0] * 2;
        //Create image using correct dimensions! Fixes bug where image size and labels do not align on session start.
        dataImg = createImage(dataImageW, dataImageH, RGB);
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        //Update channel checkboxes and active channels
        spectChanSelectTop.update(x, y, w);
        spectChanSelectBot.update(x, y + navH, w);
        //Let the top channel select open the bottom one also so we can open both with 1 button
        if (chanSelectWasOpen != spectChanSelectTop.isVisible()) {
            spectChanSelectBot.setIsVisible(spectChanSelectTop.isVisible());
            chanSelectWasOpen = spectChanSelectTop.isVisible();
            //Allow spectrogram to flex size and position depending on if the channel select is open
            flexSpectrogramSizeAndPosition();
        }

        if (spectChanSelectTop.isVisible()) {
            lockElementsOnOverlapCheck(cp5ElementsToCheck);
        }
        
        if (currentBoard.isStreaming()) {
            //Make sure we are always draw new pixels on the right
            xPos = dataImg.width - 1;
            //Fetch/calculate the time strings for the horizontal axis ticks
            fetchTimeStrings(numHorizAxisDivs);
        }
        
        //State change check
        if (currentBoard.isStreaming() && !wasRunning) {
            onStartRunning();
        } else if (!currentBoard.isStreaming() && wasRunning) {
            onStopRunning();
        }
    }

    private void onStartRunning() {
        wasRunning = true;
        lastShift = millis();
    }

    private void onStopRunning() {
        wasRunning = false;
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        //put your code here... //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        
        //Scale the dataImage to fit in inside the widget
        float scaleW = PApplet.parseFloat(graphW) / dataImageW;
        float scaleH = PApplet.parseFloat(graphH) / dataImageH;

        pushStyle();
        fill(0);
        rect(x, y, w, h); //draw a black background for the widget
        popStyle();

        //draw the spectrogram if the widget is open, and update pixels if board is streaming data
        if (currentBoard.isStreaming()) {
            pushStyle();
            dataImg.loadPixels();

            //Shift all pixels to the left! (every scrollspeed ms)
            if(millis() - lastShift > scrollSpeed) {
                for (int r = 0; r < dataImg.height; r++) {
                    if (r != 0) {
                        arrayCopy(dataImg.pixels, dataImg.width * r, dataImg.pixels, dataImg.width * r - 1, dataImg.width);
                    } else {
                        //When there would be an ArrayOutOfBoundsException, account for it!
                        arrayCopy(dataImg.pixels, dataImg.width * (r + 1), dataImg.pixels, r * dataImg.width, dataImg.width);
                    }
                }

                lastShift += scrollSpeed;
            }
            //for (int i = 0; i < fftLin_L.specSize() - 80; i++) {
            for (int i = 0; i <= dataImg.height/2; i++) {
                //LEFT SPECTROGRAM ON TOP
                float hueValue = hueLimit - map((fftAvgs(spectChanSelectTop.activeChan, i)*32), 0, 256, 0, hueLimit);
                if (settings.spectLogLinSave == 0) {
                    hueValue = map(log10(hueValue), 0, 2, 0, hueLimit);
                }
                // colorMode is HSB, the range for hue is 256, for saturation is 100, brightness is 100.
                colorMode(HSB, 256, 100, 100);
                // color for stroke is specified as hue, saturation, brightness.
                stroke(PApplet.parseInt(hueValue), 100, 80);
                // plot a point using the specified stroke
                //point(xPos, i);
                int loc = xPos + ((dataImg.height/2 - i) * dataImg.width);
                if (loc >= dataImg.width * dataImg.height) loc = dataImg.width * dataImg.height - 1;
                try {
                    dataImg.pixels[loc] = color(PApplet.parseInt(hueValue), 100, 80);
                } catch (Exception e) {
                    println("Major drawing error Spectrogram Left image!");
                }

                //RIGHT SPECTROGRAM ON BOTTOM
                hueValue = hueLimit - map((fftAvgs(spectChanSelectBot.activeChan, i)*32), 0, 256, 0, hueLimit);
                if (settings.spectLogLinSave == 0) {
                    hueValue = map(log10(hueValue), 0, 2, 0, hueLimit);
                }
                // colorMode is HSB, the range for hue is 256, for saturation is 100, brightness is 100.
                colorMode(HSB, 256, 100, 100);
                // color for stroke is specified as hue, saturation, brightness.
                stroke(PApplet.parseInt(hueValue), 100, 80);
                int y_offset = -1;
                // Pixel = X + ((Y + Height/2) * Width)
                loc = xPos + ((i + dataImg.height/2 + y_offset) * dataImg.width);
                if (loc >= dataImg.width * dataImg.height) loc = dataImg.width * dataImg.height - 1;
                try {
                    dataImg.pixels[loc] = color(PApplet.parseInt(hueValue), 100, 80);
                } catch (Exception e) {
                    println("Major drawing error Spectrogram Right image!");
                }
            }
            dataImg.updatePixels();
            popStyle();
        }
        
        pushMatrix();
        translate(graphX, graphY);
        scale(scaleW, scaleH);
        image(dataImg, 0, 0);
        popMatrix();

        spectChanSelectTop.draw();
        spectChanSelectBot.draw();
        drawAxes(scaleW, scaleH);
        drawCenterLine();
    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        spectChanSelectTop.screenResized(pApplet);
        spectChanSelectBot.screenResized(pApplet);  
        graphX = x + paddingLeft;
        graphY = y + paddingTop;
        graphW = w - paddingRight - paddingLeft;
        graphH = h - paddingBottom - paddingTop;
        //Allow spectrogram to flex size and position depending on if the channel select is open
        if (spectChanSelectTop.isVisible()) {
            graphY += navH * 2;
            graphH -= navH * 2;
        }
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)

        spectChanSelectTop.mousePressed(this.dropdownIsActive); //Calls channel select mousePressed and checks if clicked
        spectChanSelectBot.mousePressed(this.dropdownIsActive);
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

    }

    public void drawAxes(float scaledW, float scaledH) {
        
        pushStyle();
            fill(255);
            textSize(14);
            //draw horizontal axis label
            text("Time", x + w/2 - textWidth("Time")/3, y + h - 9);
            noFill();
            stroke(255);
            strokeWeight(2);
            //draw rectangle around the spectrogram
            rect(graphX, graphY, scaledW * dataImageW, scaledH * dataImageH);
        popStyle();

        pushStyle();
            //draw horizontal axis ticks from left to right
            int tickMarkSize = 7; //in pixels
            float horizAxisX = graphX;
            float horizAxisY = graphY + scaledH * dataImageH;
            stroke(255);
            fill(255);
            strokeWeight(2);
            textSize(11);
            for (int i = 0; i <= numHorizAxisDivs; i++) {
                float offset = scaledW * dataImageW * (PApplet.parseFloat(i) / numHorizAxisDivs);
                line(horizAxisX + offset, horizAxisY, horizAxisX + offset, horizAxisY + tickMarkSize);
                if (horizAxisLabelStrings.get(i) != null) {
                    text(horizAxisLabelStrings.get(i), horizAxisX + offset - (int)textWidth(horizAxisLabelStrings.get(i))/2, horizAxisY + tickMarkSize * 3);
                }
            }
        popStyle();
        
        pushStyle();
            pushMatrix();
                rotate(radians(-90));
                translate(-h/2 - textWidth("Frequency (Hz)")/3, 20);
                fill(255);
                textSize(14);
                //draw y axis label
                text("Frequency (Hz)", -y, x);
            popMatrix();
        popStyle();

        pushStyle();
            //draw vertical axis ticks from top to bottom
            float vertAxisX = graphX;
            float vertAxisY = graphY;
            stroke(255);
            fill(255);
            textSize(12);
            strokeWeight(2);
            for (int i = 0; i <= numVertAxisDivs; i++) {
                float offset = scaledH * dataImageH * (PApplet.parseFloat(i) / numVertAxisDivs);
                //if (i <= numVertAxisDivs/2) offset -= 2;
                line(vertAxisX, vertAxisY + offset, vertAxisX - tickMarkSize, vertAxisY + offset);
                if (vertAxisLabel[i] == 0) midLineY = PApplet.parseInt(vertAxisY + offset);
                offset += paddingTop/2;
                text(vertAxisLabel[i], vertAxisX - tickMarkSize*2 - textWidth(Integer.toString(vertAxisLabel[i])), vertAxisY + offset);
            }
        popStyle();

        drawColorScaleReference();
    }

    public void drawCenterLine() {
        //draw a thick line down the middle to separate the two plots
        pushStyle();
        stroke(255);
        strokeWeight(3);
        line(graphX, midLineY, graphX + graphW, midLineY);
        popStyle();
    }

    public void drawColorScaleReference() {
        int colorScaleHeight = 128;
        //Dynamically scale the Log/Lin amplitude-to-color reference line. If it won't fit, don't draw it.
        if (graphH < colorScaleHeight) {
            colorScaleHeight = PApplet.parseInt(h * 1/2);
            if (colorScaleHeight > graphH) {
                return;
            }
        }
        pushStyle();
            //draw color scale reference to the right of the spectrogram
            for (int i = 0; i < colorScaleHeight; i++) {
                float hueValue = hueLimit - map(i * 2, 0, colorScaleHeight*2, 0, hueLimit);
                if (settings.spectLogLinSave == 0) {
                    hueValue = map(log(hueValue) / log(10), 0, 2, 0, hueLimit);
                }
                //println(hueValue);
                // colorMode is HSB, the range for hue is 256, for saturation is 100, brightness is 100.
                colorMode(HSB, 256, 100, 100);
                // color for stroke is specified as hue, saturation, brightness.
                stroke(ceil(hueValue), 100, 80);
                strokeWeight(10);
                point(x + w - paddingRight/2 + 1, midLineY + colorScaleHeight/2 - i);
            }
        popStyle();
    }

    public void activateDefaultChannels() {
        int[] topChansToActivate;
        int[] botChansToActivate; 
        if (nchan == 4) {
            topChansToActivate = new int[]{0, 2};
            botChansToActivate = new int[]{1, 3};
        } else if (nchan == 8) {
            topChansToActivate = new int[]{0, 2, 4, 6};
            botChansToActivate = new int[]{1, 3, 5, 7};
        } else {
            topChansToActivate = new int[]{0, 2, 4, 6, 8 ,10, 12, 14};
            botChansToActivate = new int[]{1, 3, 5, 7, 9, 11, 13, 15};
        }

        for (int i = 0; i < topChansToActivate.length; i++) {
            spectChanSelectTop.setToggleState(topChansToActivate[i], true);
            
        }

        for (int i = 0; i < botChansToActivate.length; i++) {
            spectChanSelectBot.setToggleState(botChansToActivate[i], true);
        }
    }

    public void flexSpectrogramSizeAndPosition() {
        if (spectChanSelectTop.isVisible()) {
            graphY += navH * 2;
            graphH -= navH * 2;
        } else {
            graphY -= navH * 2;
            graphH += navH * 2;
        }
    }

    public void setScrollSpeed(int i) {
        scrollSpeed = i;
    }

    public float fftAvgs(List<Integer> _activeChan, int freqBand) {
        float sum = 0f;
        for (int i = 0; i < _activeChan.size(); i++) {
            sum += fftBuff[_activeChan.get(i)].getBand(freqBand);
        }
        return sum / _activeChan.size();
    }

    public void fetchTimeStrings(int numAxisTicks) {
        horizAxisLabelStrings.clear();
        LocalDateTime time;
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss");

        if (getCurrentTimeStamp() == 0) {
            time = LocalDateTime.now();
        } else {
            time = LocalDateTime.ofInstant(Instant.ofEpochMilli(getCurrentTimeStamp()), 
                                            TimeZone.getDefault().toZoneId()); 
        }
        
        for (int i = 0; i <= numAxisTicks; i++) {
            long l = (long)(horizAxisLabel[i] * 60f);
            LocalDateTime t = time.minus(l, ChronoUnit.SECONDS);
            horizAxisLabelStrings.append(t.format(formatter));
        }
    }

    //Identical to the method in TimeSeries, but allows spectrogram to get the data directly from the playback data in the background
    //Find times to display for playback position
    private long getCurrentTimeStamp() {
        //return current playback time
        List<double[]> currentData = currentBoard.getData(1);
        int timeStampChan = currentBoard.getTimestampChannel();
        long timestampMS = (long)(currentData.get(0)[timeStampChan] * 1000.0f);
        return timestampMS;
    }
};

//These functions need to be global! These functions are activated when an item from the corresponding dropdown is selected
//triggered when there is an event in the Spectrogram Widget MaxFreq. Dropdown
public void SpectrogramMaxFreq(int n) {
    settings.spectMaxFrqSave = n;
    //reset the vertical axis labels
    w_spectrogram.vertAxisLabel = w_spectrogram.vertAxisLabels[n];
    //Resize the height of the data image
    w_spectrogram.dataImageH = w_spectrogram.vertAxisLabel[0] * 2;
    //overwrite the existing image because the sample rate is about to change
    w_spectrogram.dataImg = createImage(w_spectrogram.dataImageW, w_spectrogram.dataImageH, RGB);
}

public void SpectrogramSampleRate(int n) {
    settings.spectSampleRateSave = n;
    //overwrite the existing image because the sample rate is about to change
    w_spectrogram.dataImg = createImage(w_spectrogram.dataImageW, w_spectrogram.dataImageH, RGB);
    w_spectrogram.horizAxisLabel = w_spectrogram.horizAxisLabels[n];
    if (n == 0) {
        w_spectrogram.numHorizAxisDivs = 6;
        w_spectrogram.setScrollSpeed(1000);
    } else if (n == 1) {
        w_spectrogram.numHorizAxisDivs = 6;
        w_spectrogram.setScrollSpeed(200);
    } else if (n == 2) {
        w_spectrogram.numHorizAxisDivs = 3;
        w_spectrogram.setScrollSpeed(100);
    } else if (n == 3) {
        w_spectrogram.numHorizAxisDivs = 3;
        w_spectrogram.setScrollSpeed(50);
    } else if (n == 4) {
        w_spectrogram.numHorizAxisDivs = 2;
        w_spectrogram.setScrollSpeed(25);
    }
    w_spectrogram.horizAxisLabelStrings.clear();
    w_spectrogram.fetchTimeStrings(w_spectrogram.numHorizAxisDivs);
}

public void SpectrogramLogLin(int n) {
    settings.spectLogLinSave = n;
}

////////////////////////////////////////////////////
//
//    W_template.pde (ie "Widget Template")
//
//    This is a Template Widget, intended to be used as a starting point for OpenBCI Community members that want to develop their own custom widgets!
//    Good luck! If you embark on this journey, please let us know. Your contributions are valuable to everyone!
//
//    Created by: Conor Russomanno, November 2016
//
///////////////////////////////////////////////////,

class W_template extends Widget {

    //to see all core variables/methods of the Widget class, refer to Widget.pde
    //put your custom variables here...
    ControlP5 localCP5;
    Button widgetTemplateButton;

    W_template(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)
        
        //This is the protocol for setting up dropdowns.
        //Note that these 3 dropdowns correspond to the 3 global functions below
        //You just need to make sure the "id" (the 1st String) has the same name as the corresponding function
        addDropdown("Dropdown1", "Drop 1", Arrays.asList("A", "B"), 0);
        addDropdown("Dropdown2", "Drop 2", Arrays.asList("C", "D", "E"), 1);
        addDropdown("Dropdown3", "Drop 3", Arrays.asList("F", "G", "H", "I"), 3);


        //Instantiate local cp5 for this box. This allows extra control of drawing cp5 elements specifically inside this class.
        localCP5 = new ControlP5(ourApplet);
        localCP5.setGraphics(ourApplet, 0,0);
        localCP5.setAutoDraw(false);

        createWidgetTemplateButton();
       
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        //put your code here...
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        //remember to refer to x,y,w,h which are the positioning variables of the Widget class

        //This draws all cp5 objects in the local instance
        localCP5.draw();
    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        //Very important to allow users to interact with objects after app resize        
        localCP5.setGraphics(ourApplet, 0, 0);

        //We need to set the position of our Cp5 object after the screen is resized
        widgetTemplateButton.setPosition(x + w/2 - widgetTemplateButton.getWidth()/2, y + h/2 - widgetTemplateButton.getHeight()/2);

    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
        //Since GUI v5, these methods should not really be used.
        //Instead, use ControlP5 objects and callbacks. 
        //Example: createWidgetTemplateButton() found below
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
        //Since GUI v5, these methods should not really be used.
    }

    //When creating new UI objects, follow this rough pattern.
    //Using custom methods like this allows us to condense the code required to create new objects.
    //You can find more detailed examples in the Control Panel, where there are many UI objects with varying functionality.
    private void createWidgetTemplateButton() {
        //This is a generalized createButton method that allows us to save code by using a few patterns and method overloading
        widgetTemplateButton = createButton(localCP5, "widgetTemplateButton", "Design Your Own Widget!", x + w/2, y + h/2, 200, navHeight, p4, 14, colorNotPressed, OPENBCI_DARKBLUE);
        //Set the border color explicitely
        widgetTemplateButton.setBorderColor(OBJECT_BORDER_GREY);
        //For this button, only call the callback listener on mouse release
        widgetTemplateButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                //If using a TopNav object, ignore interaction with widget object (ex. widgetTemplateButton)
                if (!topNav.configSelector.isVisible && !topNav.layoutSelector.isVisible) {
                    openURLInBrowser("https://docs.openbci.com/Software/OpenBCISoftware/GUIWidgets/#custom-widget");
                }
            }
        });
        widgetTemplateButton.setDescription("Here is the description for this UI object. It will fade in as help text when hovering over the object.");
    }

    //add custom functions here
    private void customFunction(){
        //this is a fake function... replace it with something relevant to this widget

    }

};

//These functions need to be global! These functions are activated when an item from the corresponding dropdown is selected
public void Dropdown1(int n){
    println("Item " + (n+1) + " selected from Dropdown 1");
    if(n==0){
        //do this
    } else if(n==1){
        //do this instead
    }
}

public void Dropdown2(int n){
    println("Item " + (n+1) + " selected from Dropdown 2");
}

public void Dropdown3(int n){
    println("Item " + (n+1) + " selected from Dropdown 3");
}
////////////////////////////////////////////////////
//
// This class creates a Time Series Plot separate from the old Gui_Manager
// It extends the Widget class
//
// Conor Russomanno, November 2016
//
// Requires the plotting library from grafica ... replacing the old gwoptics (which is now no longer supported)
//
///////////////////////////////////////////////////



public enum TimeSeriesXLim implements IndexingInterface
{
    ONE (0, 1, "1 sec"),
    THREE (1, 3, "3 sec"),
    FIVE (2, 5, "5 sec"),
    TEN (3, 10, "10 sec"),
    TWENTY (4, 20, "20 sec");

    private int index;
    private int value;
    private String label;
    private static TimeSeriesXLim[] vals = values();

    TimeSeriesXLim(int _index, int _value, String _label) {
        this.index = _index;
        this.value = _value;
        this.label = _label;
    }

    public int getValue() {
        return value;
    }

    @Override
    public String getString() {
        return label;
    }

    @Override
    public int getIndex() {
        return index;
    }
    
    public static List<String> getEnumStringsAsList() {
        List<String> enumStrings = new ArrayList<String>();
        for (IndexingInterface val : vals) {
            enumStrings.add(val.getString());
        }
        return enumStrings;
    }
}

public enum TimeSeriesYLim implements IndexingInterface
{
    AUTO (0, 0, "Auto"),
    UV_50 (1, 50, "50 uV"),
    UV_100 (2, 100, "100 uV"),
    UV_200 (3, 200, "200 uV"),
    UV_400 (4, 400, "400 uV"),
    UV_1000 (5, 1000, "1000 uV"),
    UV_10000 (6, 10000, "10000 uV");

    private int index;
    private int value;
    private String label;
    private static TimeSeriesYLim[] vals = values();

    TimeSeriesYLim(int _index, int _value, String _label) {
        this.index = _index;
        this.value = _value;
        this.label = _label;
    }

    public int getValue() {
        return value;
    }

    @Override
    public String getString() {
        return label;
    }

    @Override
    public int getIndex() {
        return index;
    }

    public static List<String> getEnumStringsAsList() {
        List<String> enumStrings = new ArrayList<String>();
        for (IndexingInterface val : vals) {
            enumStrings.add(val.getString());
        }
        return enumStrings;
    }
}

class W_timeSeries extends Widget {
    //to see all core variables/methods of the Widget class, refer to Widget.pde
    //put your custom variables here...
    private int numChannelBars;
    private float xF, yF, wF, hF;
    private float ts_padding;
    private float ts_x, ts_y, ts_h, ts_w; //values for actual time series chart -- rectangle encompassing all channelBars
    private float pb_x, pb_y, pb_h, pb_w; //values for playback sub-widget
    private float plotBottomWell;
    private float playbackWidgetHeight;
    private int channelBarHeight;
    public final int interChannelBarSpace = 2;

    private ControlP5 tscp5;
    private Button hwSettingsButton;

    private ChannelSelect tsChanSelect;
    private ChannelBar[] channelBars;
    private PlaybackScrollbar scrollbar;
    private TimeDisplay timeDisplay;

    TimeSeriesXLim xLimit = TimeSeriesXLim.FIVE;
    TimeSeriesYLim yLimit = TimeSeriesYLim.UV_200;

    private PImage expand_default;
    private PImage expand_hover;
    private PImage expand_active;
    private PImage contract_default;
    private PImage contract_hover;
    private PImage contract_active;

    private ADS1299SettingsController adsSettingsController;

    private boolean allowSpillover = false;
    private boolean hasScrollbar = true; //used to turn playback scrollbar widget on/off

    List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();

    W_timeSeries(PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        tscp5 = new ControlP5(_parent);
        tscp5.setGraphics(_parent, 0,0);
        tscp5.setAutoDraw(false);

        tsChanSelect = new ChannelSelect(pApplet, this, x, y, w, navH, "TS_Channels");
        //activate all channels in channelSelect by default for this widget
        tsChanSelect.activateAllButtons();
        cp5ElementsToCheck.addAll(tsChanSelect.getCp5ElementsForOverlapCheck());

        xF = PApplet.parseFloat(x); //float(int( ... is a shortcut for rounding the float down... so that it doesn't creep into the 1px margin
        yF = PApplet.parseFloat(y);
        wF = PApplet.parseFloat(w);
        hF = PApplet.parseFloat(h);

        plotBottomWell = 45.0f; //this appears to be an arbitrary vertical space adds GPlot leaves at bottom, I derived it through trial and error
        ts_padding = 10.0f;
        ts_x = xF + ts_padding;
        ts_y = yF + ts_padding;
        ts_w = wF - ts_padding*2;
        ts_h = hF - playbackWidgetHeight - plotBottomWell - (ts_padding*2);
        numChannelBars = nchan; //set number of channel bars = to current nchan of system (4, 8, or 16)

        //This is a newer protocol for setting up dropdowns.
        addDropdown("VertScale_TS", "Vert Scale", yLimit.getEnumStringsAsList(), yLimit.getIndex());
        addDropdown("Duration", "Window", xLimit.getEnumStringsAsList(), xLimit.getIndex());

        //Instantiate scrollbar if using playback mode and scrollbar feature in use
        if((currentBoard instanceof FileBoard) && hasScrollbar) {
            playbackWidgetHeight = 50.0f;
            pb_x = ts_x - ts_padding/2;
            pb_y = ts_y + ts_h + playbackWidgetHeight + (ts_padding * 3);
            pb_w = ts_w - ts_padding*4;
            pb_h = playbackWidgetHeight/2;
            int _x = floor(xF) - 1;
            int _y = PApplet.parseInt(ts_y + ts_h + playbackWidgetHeight + 5);
            int _w = PApplet.parseInt(wF) + 1;
            int _h = PApplet.parseInt(playbackWidgetHeight);
            //Make a new scrollbar
            scrollbar = new PlaybackScrollbar(_x, _y, _w, _h, PApplet.parseInt(pb_x), PApplet.parseInt(pb_y), PApplet.parseInt(pb_w), PApplet.parseInt(pb_h));
        } else {
            int td_h = 18;
            timeDisplay = new TimeDisplay(PApplet.parseInt(ts_x), PApplet.parseInt(ts_y + hF - td_h), PApplet.parseInt(ts_w), td_h);
            playbackWidgetHeight = 0.0f;
        }

        expand_default = loadImage("expand_default.png");
        expand_hover = loadImage("expand_hover.png");
        expand_active = loadImage("expand_active.png");
        contract_default = loadImage("contract_default.png");
        contract_hover = loadImage("contract_hover.png");
        contract_active = loadImage("contract_active.png");

        channelBarHeight = PApplet.parseInt(ts_h/numChannelBars);
        channelBars = new ChannelBar[numChannelBars];
        //create our channel bars and populate our channelBars array!
        for(int i = 0; i < numChannelBars; i++) {
            int channelBarY = PApplet.parseInt(ts_y) + i*(channelBarHeight); //iterate through bar locations
            ChannelBar tempBar = new ChannelBar(_parent, i, PApplet.parseInt(ts_x), channelBarY, PApplet.parseInt(ts_w), channelBarHeight, expand_default, expand_hover, expand_active, contract_default, contract_hover, contract_active);
            channelBars[i] = tempBar;
        }

        int x_hsc = PApplet.parseInt(channelBars[0].plot.getPos()[0] + 2);
        int y_hsc = PApplet.parseInt(channelBars[0].plot.getPos()[1]);
        int w_hsc = PApplet.parseInt(channelBars[0].plot.getOuterDim()[0]);
        int h_hsc = channelBarHeight * numChannelBars;

        if (currentBoard instanceof ADS1299SettingsBoard) {
            hwSettingsButton = createHSCButton("HardwareSettings", "Hardware Settings", (int)(x0 + 80), (int)(y0 + navHeight + 1), 120, navHeight - 3);
            cp5ElementsToCheck.add((controlP5.Controller)hwSettingsButton);
            adsSettingsController = new ADS1299SettingsController(_parent, tsChanSelect.activeChan, x_hsc, y_hsc, w_hsc, h_hsc, channelBarHeight);
        }
    }

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        // offset based on whether channel select or hardware settings are open or not
        int chanSelectOffset = tsChanSelect.isVisible() ? navHeight : 0;
        if (currentBoard instanceof ADS1299SettingsBoard) {
            chanSelectOffset += adsSettingsController.getIsVisible() ? navHeight : 0;
        }

        //Responsively size the channelBarHeight
        channelBarHeight = PApplet.parseInt((ts_h - chanSelectOffset) / tsChanSelect.activeChan.size());

        //Update channel checkboxes
        tsChanSelect.update(x, y, w);

        //Update and resize all active channels
        for(int i = 0; i < tsChanSelect.activeChan.size(); i++) {
            int activeChan = tsChanSelect.activeChan.get(i);
            int channelBarY = PApplet.parseInt(ts_y + chanSelectOffset) + i*(channelBarHeight); //iterate through bar locations
            //To make room for channel bar separator, subtract space between channel bars from height
            int cb_h = channelBarHeight - interChannelBarSpace;
            channelBars[activeChan].resize(PApplet.parseInt(ts_x), channelBarY, PApplet.parseInt(ts_w), cb_h);
            channelBars[activeChan].update();
        }
        
        //Responsively size and update the HardwareSettingsController
        if (currentBoard instanceof ADS1299SettingsBoard) {
            int cb_h = channelBarHeight + interChannelBarSpace - 2;
            int h_hsc = channelBarHeight * tsChanSelect.activeChan.size();        
            adsSettingsController.resize((int)channelBars[0].plot.getPos()[0], (int)channelBars[0].plot.getPos()[1], (int)channelBars[0].plot.getOuterDim()[0], h_hsc, cb_h);
            adsSettingsController.update(); //update channel controller
        }
        
        //Update Playback scrollbar and/or display time
        if((currentBoard instanceof FileBoard) && hasScrollbar) {
            //scrub playback file
            scrollbar.update();
        } else {
            timeDisplay.update();
        }

        lockElementsOnOverlapCheck(cp5ElementsToCheck);
    }

    public void draw() {
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        //draw channel bars
        for (int i = 0; i < tsChanSelect.activeChan.size(); i++) {
            int activeChan = tsChanSelect.activeChan.get(i);
            channelBars[activeChan].draw(getAdsSettingsVisible());
        }

        //Display playback scrollbar, timeDisplay, or ADSSettingsController depending on data source
        if ((currentBoard instanceof FileBoard) && hasScrollbar) { //you will only ever see the playback widget in Playback Mode ... otherwise not visible
            scrollbar.draw();
        } else if (currentBoard instanceof ADS1299SettingsBoard) {
            //Hide time display when ADSSettingsController is open for compatible boards
            if (!getAdsSettingsVisible()) {
                timeDisplay.draw();
            }
            adsSettingsController.draw();
        } else {
            timeDisplay.draw();
        }

        tscp5.draw();
        
        tsChanSelect.draw();
    }

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        //Very important to allow users to interact with objects after app resize
        tscp5.setGraphics(ourApplet, 0,0);
        
        tsChanSelect.screenResized(pApplet);

        xF = PApplet.parseFloat(x); //float(int( ... is a shortcut for rounding the float down... so that it doesn't creep into the 1px margin
        yF = PApplet.parseFloat(y);
        wF = PApplet.parseFloat(w);
        hF = PApplet.parseFloat(h);

        ts_x = xF + ts_padding;
        ts_y = yF + (ts_padding);
        ts_w = wF - ts_padding*2;
        ts_h = hF - playbackWidgetHeight - plotBottomWell - (ts_padding*2);
        
        ////Resize the playback slider if using playback mode, or resize timeDisplay div at the bottom of timeSeries
        if((currentBoard instanceof FileBoard) && hasScrollbar) {
            int _x = floor(xF) - 1;
            int _y = PApplet.parseInt(ts_y + ts_h + playbackWidgetHeight + 5);
            int _w = PApplet.parseInt(wF) + 1;
            int _h = PApplet.parseInt(playbackWidgetHeight);
            pb_x = ts_x - ts_padding/2;
            pb_y = ts_y + ts_h + playbackWidgetHeight + (ts_padding*3);
            pb_w = ts_w - ts_padding*4;
            pb_h = playbackWidgetHeight/2;
            scrollbar.screenResized(_x, _y, _w, _h, pb_x, pb_y, pb_w, pb_h);
        } else {
            int td_h = 18;
            timeDisplay.screenResized(PApplet.parseInt(ts_x), PApplet.parseInt(ts_y + hF - td_h), PApplet.parseInt(ts_w), td_h);
        }

        // offset based on whether channel select is open or not.
        int chanSelectOffset = 0;
        if (tsChanSelect.isVisible()) {
            chanSelectOffset = navHeight;
        }
        
        for (ChannelBar cb : channelBars) {
            cb.updateCP5(ourApplet);
        }
        
        for(int i = 0; i < tsChanSelect.activeChan.size(); i++) {
            int activeChan = tsChanSelect.activeChan.get(i);
            int channelBarY = PApplet.parseInt(ts_y + chanSelectOffset) + i*(channelBarHeight); //iterate through bar locations
            channelBars[activeChan].resize(PApplet.parseInt(ts_x), channelBarY, PApplet.parseInt(ts_w), channelBarHeight); //bar x, bar y, bar w, bar h
        }
        
        if (currentBoard instanceof ADS1299SettingsBoard) {
            hwSettingsButton.setPosition(x0 + 80, (int)(y0 + navHeight + 1));
        }
        
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
        tsChanSelect.mousePressed(this.dropdownIsActive); //Calls channel select mousePressed and checks if clicked

        for(int i = 0; i < tsChanSelect.activeChan.size(); i++) {
            int activeChan = tsChanSelect.activeChan.get(i);
            channelBars[activeChan].mousePressed();
        }
    }
    
    public void mouseReleased() {
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

        for(int i = 0; i < tsChanSelect.activeChan.size(); i++) {
            int activeChan = tsChanSelect.activeChan.get(i);
            channelBars[activeChan].mouseReleased();
        }
    }

    private void setAdsSettingsVisible(boolean visible) {
        if(!(currentBoard instanceof ADS1299SettingsBoard)) {
            return;
        }

        String buttonText = "Time Series";

        if (visible && currentBoard.isStreaming()) {
            PopupMessage msg = new PopupMessage("Info", "Streaming needs to be stopped before accessing Hardware Settings");
            return;
        }

        boolean inSync = adsSettingsController.setIsVisible(visible);
        
        if (!visible && adsSettingsController != null && inSync) {
            buttonText = "Hardware Settings";         
        }
        hwSettingsButton.setCaptionLabel(buttonText);
    }

    private boolean getAdsSettingsVisible() {
        return adsSettingsController != null && adsSettingsController.getIsVisible();
    }

    public void closeADSSettings() {
        setAdsSettingsVisible(false);
    }

    private Button createHSCButton(String name, String text, int _x, int _y, int _w, int _h) {
        final Button myButton = createButton(tscp5, name, text, _x, _y, _w, _h);
        myButton.setBorderColor(OBJECT_BORDER_GREY);
        myButton.onClick(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {    
                println("HardwareSettings Toggle: " + !adsSettingsController.getIsVisible());
                setAdsSettingsVisible(!adsSettingsController.getIsVisible());
            }
        });
        return myButton;
    }

    public TimeSeriesYLim getTSVertScale() {
        return yLimit;
    }

    public TimeSeriesXLim getTSHorizScale() {
        return xLimit;
    }

    public void setTSVertScale(int n) {
        yLimit = yLimit.values()[n];
        for (int i = 0; i < numChannelBars; i++) {
            channelBars[i].adjustVertScale(yLimit.getValue());
        }
    }

    public void setTSHorizScale(int n) {
        xLimit = xLimit.values()[n];
        for (int i = 0; i < numChannelBars; i++) {
            channelBars[i].adjustTimeAxis(xLimit.getValue());
        }
    }
};

//These functions are activated when an item from the corresponding dropdown is selected
public void VertScale_TS(int n) {
    w_timeSeries.setTSVertScale(n);
}

//triggered when there is an event in the Duration Dropdown
public void Duration(int n) {
    w_timeSeries.setTSHorizScale(n);

    int newDuration = w_timeSeries.getTSHorizScale().getValue();
    //If selected by user, sync the duration of Time Series, Accelerometer, and Analog Read(Cyton Only)
    if (currentBoard instanceof AccelerometerCapableBoard) {
        if (settings.accHorizScaleSave == 0) {
            //set accelerometer x axis to the duration selected from dropdown
            w_accelerometer.accelerometerBar.adjustTimeAxis(newDuration);
        }
    }
    if (currentBoard instanceof AnalogCapableBoard) {
        if (settings.arHorizScaleSave == 0) {
            //set analog read x axis to the duration selected from dropdown
            for(int i = 0; i < w_analogRead.numAnalogReadBars; i++) {
                w_analogRead.analogReadBars[i].adjustTimeAxis(newDuration);
            }
        }
    }
}

//========================================================================================================================
//                      CHANNEL BAR CLASS -- Implemented by Time Series Widget Class
//========================================================================================================================
//this class contains the plot and buttons for a single channel of the Time Series widget
//one of these will be created for each channel (4, 8, or 16)
class ChannelBar {

    int channelIndex; //duh
    String channelString;
    int x, y, w, h;
    int defaultH;
    ControlP5 cbCp5;
    Button onOffButton;
    int onOff_diameter;
    int yScaleButton_h;
    int yScaleButton_w;
    Button yScaleButton_pos;
    Button yScaleButton_neg;
    int yAxisLabel_h;
    private TextBox yAxisMax;
    private TextBox yAxisMin;
    
    int yAxisUpperLim;
    int yAxisLowerLim;
    int uiSpaceWidth;
    int padding_4 = 4;
    int minimumChannelHeight;
    int plotBottomWellH = 45;

    GPlot plot; //the actual grafica-based GPlot that will be rendering the Time Se ries trace
    GPointsArray channelPoints;
    int nPoints;
    int numSeconds;
    float timeBetweenPoints;

    int channelColor; //color of plot trace

    boolean isAutoscale = false; //when isAutoscale equals true, the y-axis of each channelBar will automatically update to scale to the largest visible amplitude
    float autoscaleMin;
    float autoscaleMax;
    int previousMillis = 0;
    
    TextBox voltageValue;
    TextBox impValue;

    boolean drawVoltageValue;

    ChannelBar(PApplet _parent, int _channelIndex, int _x, int _y, int _w, int _h, PImage expand_default, PImage expand_hover, PImage expand_active, PImage contract_default, PImage contract_hover, PImage contract_active) {
        
        cbCp5 = new ControlP5(ourApplet);
        cbCp5.setGraphics(ourApplet, x, y);
        cbCp5.setAutoDraw(false); //Setting this saves code as cp5 elements will only be drawn/visible when [cp5].draw() is called

        channelIndex = _channelIndex;
        channelString = str(channelIndex + 1);

        x = _x;
        y = _y;
        w = _w;
        h = _h;
        defaultH = h;

        onOff_diameter = h > 26 ? 26 : h - 2;
        createOnOffButton("onOffButton"+channelIndex, channelString, x + 6, y + PApplet.parseInt(h/2) - PApplet.parseInt(onOff_diameter/2), onOff_diameter, onOff_diameter);

        //Create GPlot for this Channel
        uiSpaceWidth = 36 + padding_4;
        yAxisUpperLim = 200;
        yAxisLowerLim = -200;
        numSeconds = 5;
        plot = new GPlot(_parent);
        plot.setPos(x + uiSpaceWidth, y);
        plot.setDim(w - uiSpaceWidth, h);
        plot.setMar(0f, 0f, 0f, 0f);
        plot.setLineColor((int)channelColors[channelIndex%8]);
        plot.setXLim(-5,0);
        plot.setYLim(yAxisLowerLim, yAxisUpperLim);
        plot.setPointSize(2);
        plot.setPointColor(0);
        plot.setAllFontProperties("Arial", 0, 14);
        plot.getXAxis().setFontColor(OPENBCI_DARKBLUE);
        plot.getXAxis().setLineColor(OPENBCI_DARKBLUE);
        plot.getXAxis().getAxisLabel().setFontColor(OPENBCI_DARKBLUE);
        if(channelIndex == nchan-1) {
            plot.getXAxis().setAxisLabelText("Time (s)");
            plot.getXAxis().getAxisLabel().setOffset(plotBottomWellH/2 + 5f);
        }
        // plot.setBgColor(OPENBCI_BLUE);

        //Fill the GPlot with initial data
        nPoints = nPointsBasedOnDataSource();
        channelPoints = new GPointsArray(nPoints);
        timeBetweenPoints = (float)numSeconds / (float)nPoints;
        for (int i = 0; i < nPoints; i++) {
            float time = -(float)numSeconds + (float)i*timeBetweenPoints;
            float filt_uV_value = 0.0f; //0.0 for all points to start
            GPoint tempPoint = new GPoint(time, filt_uV_value);
            channelPoints.set(i, tempPoint);
        }
        plot.setPoints(channelPoints); //set the plot with 0.0 for all channelPoints to start

        //Create a UI to custom scale the Y axis for this channel
        yScaleButton_w = 18;
        yScaleButton_h = 18;
        yAxisLabel_h = 12;
        int padding = 2;
        yAxisMax = new TextBox("+"+yAxisUpperLim+"uV", x + uiSpaceWidth + padding, y + PApplet.parseInt(padding*1.5f), OPENBCI_DARKBLUE, color(255,255,255,175), LEFT, TOP);
        yAxisMin = new TextBox(yAxisLowerLim+"uV", x + uiSpaceWidth + padding, y + h - yAxisLabel_h - padding_4, OPENBCI_DARKBLUE, color(255,255,255,175), LEFT, TOP);
        customYLim(yAxisMax, yAxisUpperLim);
        customYLim(yAxisMin, yAxisLowerLim);
        yScaleButton_neg = createYScaleButton(channelIndex, false, "decreaseYscale", "-T", x + uiSpaceWidth + padding, y + w/2 - yScaleButton_h/2, yScaleButton_w, yScaleButton_h, contract_default, contract_hover, contract_active); 
        yScaleButton_pos = createYScaleButton(channelIndex, true, "increaseYscale", "+T", x + uiSpaceWidth + padding*2 + yScaleButton_w, y + w/2 - yScaleButton_h/2, yScaleButton_w, yScaleButton_h, expand_default, expand_hover, expand_active);
        
        //Create textBoxes to display the current values
        impValue = new TextBox("", x + uiSpaceWidth + (int)plot.getDim()[0], y + padding, OPENBCI_DARKBLUE, color(255,255,255,175), RIGHT, TOP);
        voltageValue = new TextBox("", x + uiSpaceWidth + (int)plot.getDim()[0] - padding, y + h, OPENBCI_DARKBLUE, color(255,255,255,175), RIGHT, BOTTOM);
        drawVoltageValue = true;

        //Establish a minimumChannelHeight
        minimumChannelHeight = padding_4 + yAxisLabel_h*2;
    }

    public void update() {
        //Reusable variables
        String fmt; float val;

        //update the voltage values
        val = dataProcessing.data_std_uV[channelIndex];
        voltageValue.string = String.format(getFmt(val),val) + " uVrms";
        if (is_railed != null) {
            voltageValue.setText(is_railed[channelIndex].notificationString + voltageValue.string);
            voltageValue.setTextColor(is_railed[channelIndex].getColor());
        }

        //update the impedance values
        val = data_elec_imp_ohm[channelIndex]/1000;
        fmt = String.format(getFmt(val),val) + " kOhm";
        if (is_railed != null && is_railed[channelIndex].is_railed == true) {
            fmt = "RAILED - " + fmt;
        }
        impValue.setText(fmt);

        // update data in plot
        updatePlotPoints();

        if(currentBoard.isEXGChannelActive(channelIndex)) {
            onOffButton.setColorBackground(channelColors[channelIndex%8]); // power down == false, set color to vibrant
        }
        else {
            onOffButton.setColorBackground(50); // power down == true, set to grey
        }
    }

    private String getFmt(float val) {
        String fmt;
        if (val > 100.0f) {
            fmt = "%.0f";
        } else if (val > 10.0f) {
            fmt = "%.1f";
        } else {
            fmt = "%.2f";
        }
        return fmt;
    }

    private void updatePlotPoints() {
        autoscaleMax = -Float.MAX_VALUE;
        autoscaleMin = Float.MAX_VALUE;
        // update data in plot
        if (dataProcessingFilteredBuffer[channelIndex].length >= nPoints) {
            for (int i = dataProcessingFilteredBuffer[channelIndex].length - nPoints; i < dataProcessingFilteredBuffer[channelIndex].length; i++) {
                float time = -(float)numSeconds + (float)(i-(dataProcessingFilteredBuffer[channelIndex].length-nPoints))*timeBetweenPoints;
                float filt_uV_value = dataProcessingFilteredBuffer[channelIndex][i];

                // update channel point in place
                channelPoints.set(i-(dataProcessingFilteredBuffer[channelIndex].length-nPoints), time, filt_uV_value, "");
                autoscaleMax = Math.max(filt_uV_value, autoscaleMax);
                autoscaleMin = Math.min(filt_uV_value, autoscaleMin);
            }
            applyAutoscale();
            plot.setPoints(channelPoints); //reset the plot with updated channelPoints
        }
    }

    public void draw(boolean hardwareSettingsAreOpen) {        

        plot.beginDraw();
        plot.drawBox();
        plot.drawGridLines(GPlot.VERTICAL);
        try {
            plot.drawLines();
        } catch (NullPointerException e) {
            e.printStackTrace();
            println("PLOT ERROR ON CHANNEL " + channelIndex);
            
        }
        //Draw the x axis label on the bottom channel bar, hide if hardware settings are open
        if (isBottomChannel() && !hardwareSettingsAreOpen) {
            plot.drawXAxis();
            plot.getXAxis().draw();
        }
        plot.endDraw();

        //draw channel holder background
        pushStyle();
        stroke(OPENBCI_BLUE_ALPHA50);
        noFill();
        rect(x,y,w,h);
        popStyle();

        //draw channelBar separator line in the middle of interChannelBarSpace
        if (!isBottomChannel()) {
            pushStyle();
            stroke(OPENBCI_DARKBLUE);
            strokeWeight(1);
            int separator_y = y + h + PApplet.parseInt(w_timeSeries.interChannelBarSpace/2);
            line(x, separator_y, x + w, separator_y);
            popStyle();
        }

        //draw impedance values in time series also for each channel
        drawVoltageValue = true;
        if (currentBoard instanceof ImpedanceSettingsBoard) {
            if(((ImpedanceSettingsBoard)currentBoard).isCheckingImpedance(channelIndex)) {
                impValue.draw();
                drawVoltageValue = false;
            }
        }
        
        if (drawVoltageValue) {
            voltageValue.draw();
        }
        
        //Hide yAxisButtons when hardware settings are open, labels would start to overlap, or using autoscale
        boolean b = !hardwareSettingsAreOpen && (h > yScaleButton_h + yAxisLabel_h*2 + 2) && !isAutoscale;
        yScaleButton_pos.setVisible(b);
        yScaleButton_neg.setVisible(b);
        b = !hardwareSettingsAreOpen && h > minimumChannelHeight;
        yAxisMin.setVisible(b);
        yAxisMax.setVisible(b);
        yAxisMin.draw();
        yAxisMax.draw();

        try {
            cbCp5.draw();
        } catch (NullPointerException e) {
            e.printStackTrace();
            println("CP5 ERROR ON CHANNEL " + channelIndex);
        }
    }

    private int nPointsBasedOnDataSource() {
        return numSeconds * currentBoard.getSampleRate();
    }

    public void adjustTimeAxis(int _newTimeSize) {
        numSeconds = _newTimeSize;
        plot.setXLim(-_newTimeSize,0);

        nPoints = nPointsBasedOnDataSource();
        channelPoints = new GPointsArray(nPoints);
        if(_newTimeSize > 1) {
            plot.getXAxis().setNTicks(_newTimeSize);  //sets the number of axis divisions...
        }else{
            plot.getXAxis().setNTicks(10);
        }
        
        updatePlotPoints();
    }

    //Happens when user selects vert scale dropdown
    public void adjustVertScale(int _vertScaleValue) {
        //Early out if autoscale
        if (_vertScaleValue == 0) {
            isAutoscale = true;
            return;
        }
        isAutoscale = false;
        yAxisLowerLim = -_vertScaleValue;
        yAxisUpperLim = _vertScaleValue;
        plot.setYLim(yAxisLowerLim, yAxisUpperLim);
        //Update button text
        customYLim(yAxisMin, yAxisLowerLim);
        customYLim(yAxisMax, yAxisUpperLim);
    }

    public void applyAutoscale() {
        //Do this once a second for all TimeSeries ChannelBars to save on resources
        int newMillis = millis();
        boolean doAutoscale = newMillis > previousMillis + 1000;
        if (isAutoscale && currentBoard.isStreaming() && doAutoscale) {
            autoscaleMin = (int) Math.floor(autoscaleMin);
            autoscaleMax = (int) Math.ceil(autoscaleMax);
            previousMillis = newMillis;
            plot.setYLim(autoscaleMin, autoscaleMax); //<---- This is a very expensive method. Here is the bottleneck.
            customYLim(yAxisMin, (int)autoscaleMin);
            customYLim(yAxisMax, (int)autoscaleMax);
        }
    }

    //Update yAxis text and responsively size Textfield
    private void customYLim(TextBox tb, int limit) {
        StringBuilder s = new StringBuilder(limit > 0 ? "+" : "");
        s.append(limit);
        s.append("uV");
        tb.setText(s.toString());
    }

    public void resize(int _x, int _y, int _w, int _h) {
        x = _x;
        y = _y;
        w = _w;
        h = _h;

        //reposition & resize the plot
        int plotW = w - uiSpaceWidth;
        plot.setPos(x + uiSpaceWidth, y);
        plot.setDim(plotW, h);

        int padding = 2;
        voltageValue.setPosition(x + uiSpaceWidth + (w - uiSpaceWidth) - padding, y + h);
        impValue.setPosition(x + uiSpaceWidth + (int)plot.getDim()[0], y + padding);

        yScaleButton_neg.setPosition(x + uiSpaceWidth + padding, y + h/2 - yScaleButton_h/2);
        yScaleButton_pos.setPosition(x + uiSpaceWidth + padding*2 + yScaleButton_w, y + h/2 - yScaleButton_h/2);

        yAxisMax.setPosition(x + uiSpaceWidth + padding, y + PApplet.parseInt(padding*1.5f) - 2);
        yAxisMin.setPosition(x + uiSpaceWidth + padding, y + h - yAxisLabel_h - padding - 1);

        onOff_diameter = h > 26 ? 26 : h - 2;
        onOffButton.setSize(onOff_diameter, onOff_diameter);
        onOffButton.setPosition(x + 6, y + PApplet.parseInt(h/2) - PApplet.parseInt(onOff_diameter/2));
    }

    public void updateCP5(PApplet _parent) {
        cbCp5.setGraphics(_parent, 0, 0);
    }

    private boolean isBottomChannel() {
        int numActiveChannels = w_timeSeries.tsChanSelect.activeChan.size();
        boolean isLastChannel = channelIndex ==  w_timeSeries.tsChanSelect.activeChan.get(numActiveChannels - 1);
        return isLastChannel;
    }

    public void mousePressed() {
    }

    public void mouseReleased() {
    }

    private void createOnOffButton(String name, String text, int _x, int _y, int _w, int _h) {
        onOffButton = createButton(cbCp5, name, text, _x, _y, _w, _h, 0, h2, 16, channelColors[channelIndex%8], WHITE, BUTTON_HOVER, BUTTON_PRESSED, (Integer) null, -2);
        onOffButton.setCircularButton(true);
        onOffButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                boolean newState = !currentBoard.isEXGChannelActive(channelIndex);
                println("[" + channelString + "] onOff released - " + (newState ? "On" : "Off"));
                currentBoard.setEXGChannelActive(channelIndex, newState);
                if (currentBoard instanceof ADS1299SettingsBoard) {
                    w_timeSeries.adsSettingsController.updateChanSettingsDropdowns(channelIndex, currentBoard.isEXGChannelActive(channelIndex));
                    boolean hasUnappliedChanges = currentBoard.isEXGChannelActive(channelIndex) != newState;
                    w_timeSeries.adsSettingsController.setHasUnappliedSettings(channelIndex, hasUnappliedChanges);
                }
            }
        });
        onOffButton.setDescription("Click to toggle channel " + channelString + ".");
    }

    private Button createYScaleButton(int chan, boolean shouldIncrease, String bName, String bText, int _x, int _y, int _w, int _h, PImage _default, PImage _hover, PImage _active) {
        _default.resize(_w, _h);
        _hover.resize(_w, _h);
        _active.resize(_w, _h);
        final Button myButton = cbCp5.addButton(bName)
                .setPosition(_x, _y)
                .setSize(_w, _h)
                .setColorLabel(color(255))
                .setColorForeground(OPENBCI_BLUE)
                .setColorBackground(color(144, 100))
                .setImages(_default, _hover, _active)
                ;
        myButton.onClick(new yScaleButtonCallbackListener(chan, shouldIncrease));
        return myButton;
    }

    private class yScaleButtonCallbackListener implements CallbackListener {
        private int channel;
        private boolean increase;
        private final int hardLimit = 25;
        private int yLimOption = TimeSeriesYLim.UV_200.getValue();
        //private int delta = 0; //value to change limits by

        yScaleButtonCallbackListener(int theChannel, boolean isIncrease)  {
            channel = theChannel;
            increase = isIncrease;
        }
        public void controlEvent(CallbackEvent theEvent) {
            verbosePrint("A button was pressed for channel " + (channel+1) + ". Should we increase (or decrease?): " + increase);

            int inc = increase ? 1 : -1;
            int n = (int)(log10(abs(yAxisLowerLim))) * 25 * inc;
            yAxisLowerLim -= n;
            n = (int)(log10(yAxisUpperLim)) * 25 * inc;
            yAxisUpperLim += n;
            
            yAxisLowerLim = yAxisLowerLim <= -hardLimit ? yAxisLowerLim : -hardLimit;
            yAxisUpperLim = yAxisUpperLim >= hardLimit ? yAxisUpperLim : hardLimit;
            plot.setYLim(yAxisLowerLim, yAxisUpperLim);
            //Update button text
            customYLim(yAxisMin, yAxisLowerLim);
            customYLim(yAxisMax, yAxisUpperLim);
        }
    }
};

//========================================================================================================================
//                                          END OF -- CHANNEL BAR CLASS
//========================================================================================================================


//========================== PLAYBACKSLIDER ==========================
class PlaybackScrollbar {
    private final float ps_Padding = 50.0f; //used to make room for skip to start button
    private int x, y, w, h;
    private int swidth, sheight;    // width and height of bar
    private float xpos, ypos;       // x and y position of bar
    private float spos;    // x position of slider
    private float sposMin, sposMax; // max and min values of slider
    private boolean over;           // is the mouse over the slider?
    private boolean locked;
    private ControlP5 pbsb_cp5;
    private Button skipToStartButton;
    private int skipToStart_diameter;
    private String currentAbsoluteTimeToDisplay = "";
    private String currentTimeInSecondsToDisplay = "";
    private FileBoard fileBoard;
    
    private final DateFormat currentTimeFormatShort = new SimpleDateFormat("mm:ss");
    private final DateFormat currentTimeFormatLong = new SimpleDateFormat("HH:mm:ss");
    private final DateFormat timeStampFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    PlaybackScrollbar (int _x, int _y, int _w, int _h, float xp, float yp, int sw, int sh) {
        x = _x;
        y = _y;
        w = _w;
        h = _h;
        swidth = sw;
        sheight = sh;
        //float widthtoheight = sw - sh;
        //ratio = (float)sw / widthtoheight;
        xpos = xp + ps_Padding; //lots of padding to make room for button
        ypos = yp-sheight/2;
        spos = xpos;
        sposMin = xpos;
        sposMax = xpos + swidth - sheight/2;

        pbsb_cp5 = new ControlP5(ourApplet);
        pbsb_cp5.setGraphics(ourApplet, 0,0);
        pbsb_cp5.setAutoDraw(false);

        //Let's make a button to return to the start of playback!!
        skipToStart_diameter = 30;
        createSkipToStartButton("skipToStartButton", "", PApplet.parseInt(xp) + PApplet.parseInt(skipToStart_diameter*.5f), PApplet.parseInt(yp) + PApplet.parseInt(sh/2) - skipToStart_diameter, skipToStart_diameter, skipToStart_diameter);

        fileBoard = (FileBoard)currentBoard;
    }

    private void createSkipToStartButton(String name, String text, int _x, int _y, int _w, int _h) {
        skipToStartButton = createButton(pbsb_cp5, name, text, _x, _y, _w, _h, 0, p5, 12, GREY_235, OPENBCI_DARKBLUE, BUTTON_HOVER, BUTTON_PRESSED, (Integer)null, 0);
        PImage defaultImage = loadImage("skipToStart_default-30x26.png");
        skipToStartButton.setImage(defaultImage);
        skipToStartButton.setForceDrawBackground(true);
        skipToStartButton.onRelease(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
               skipToStartButtonAction();
            }
        });
        skipToStartButton.setDescription("Click to go back to the beginning of the file.");
    }

    /////////////// Update loop for PlaybackScrollbar
    public void update() {
        checkMouseOver(); // check if mouse is over

        if (mousePressed && over) {
            locked = true;
        }
        if (!mousePressed) {
            locked = false;
        }
        //if the slider is being used, update new position based on user mouseX
        if (locked) {
            spos = constrain(mouseX-sheight/2, sposMin, sposMax);
            scrubToPosition();
        }
        else {
            updateCursor();
        }

        // update timestamp
        currentAbsoluteTimeToDisplay = getAbsoluteTimeToDisplay();

        //update elapsed time to display
        currentTimeInSecondsToDisplay = getCurrentTimeToDisplaySeconds();

    } //end update loop for PlaybackScrollbar

    public void updateCursor() {
        float currentSample = PApplet.parseFloat(fileBoard.getCurrentSample());
        float totalSamples = PApplet.parseFloat(fileBoard.getTotalSamples());
        float currentPlaybackPos = currentSample / totalSamples;

        spos =  lerp(sposMin, sposMax, currentPlaybackPos);
    }

    public void scrubToPosition() {
        int totalSamples = fileBoard.getTotalSamples();
        int newSamplePos = floor(totalSamples * getCursorPercentage());

        fileBoard.goToIndex(newSamplePos);
    }

    public float getCursorPercentage() {
        return (spos - sposMin) / (sposMax - sposMin);
    }

    public String getAbsoluteTimeToDisplay() {
        List<double[]> currentData = currentBoard.getData(1);
        int timeStampChan = currentBoard.getTimestampChannel();
        long timestampMS = (long)(currentData.get(0)[timeStampChan] * 1000.0f);
        if(timestampMS == 0) {
            return "";
        }
        
        return timeStampFormat.format(new Date(timestampMS));
    }

    public String getCurrentTimeToDisplaySeconds() {
        double totalMillis = fileBoard.getTotalTimeSeconds() * 1000.0f;
        double currentMillis = fileBoard.getCurrentTimeSeconds() * 1000.0f;

        String totalTimeStr = formatCurrentTime(totalMillis);
        String currentTimeStr = formatCurrentTime(currentMillis);

        return currentTimeStr + " / " + totalTimeStr;
    }

    public String formatCurrentTime(double millis) {
        DateFormat formatter = currentTimeFormatShort;
        if (millis >= 3600000.0f) { // bigger than 60 minutes
            formatter = currentTimeFormatLong;
        }

        return formatter.format(new Date((long)millis));
    }

    //checks if mouse is over the playback scrollbar
    private void checkMouseOver() {
        if (mouseX > xpos && mouseX < xpos+swidth &&
            mouseY > ypos && mouseY < ypos+sheight) {
            if(!over) {
                onMouseEnter();
            }
        }
        else {
            if (over) {
                onMouseExit();
            }
        }
    }

    // called when the mouse enters the playback scrollbar
    private void onMouseEnter() {
        over = true;
        cursor(HAND); //changes cursor icon to a hand
    }

    private void onMouseExit() {
        over = false;
        cursor(ARROW);
    }

    public void draw() {
        pushStyle();

        fill(GREY_235);
        stroke(OPENBCI_BLUE);
        rect(x, y, w, h);

        //draw the playback slider inside the playback sub-widget
        noStroke();
        fill(GREY_200);
        rect(xpos, ypos, swidth, sheight);

        //select color for playback indicator
        if (over || locked) {
            fill(OPENBCI_DARKBLUE);
        } else {
            fill(102, 102, 102);
        }
        //draws playback position indicator
        rect(spos, ypos, sheight/2, sheight);

        //draw current timestamp and X of Y Seconds above scrollbar
        int fontSize = 17;
        textFont(p2, fontSize);
        fill(OPENBCI_DARKBLUE);
        float tw = textWidth(currentAbsoluteTimeToDisplay);
        text(currentAbsoluteTimeToDisplay, xpos + swidth - tw, ypos - fontSize - 4);
        text(currentTimeInSecondsToDisplay, xpos, ypos - fontSize - 4);

        popStyle();

        pbsb_cp5.draw();
    }

    public void screenResized(int _x, int _y, int _w, int _h, float _pbx, float _pby, float _pbw, float _pbh) {
        x = _x;
        y = _y;
        w = _w;
        h = _h;
        swidth = PApplet.parseInt(_pbw);
        sheight = PApplet.parseInt(_pbh);
        xpos = _pbx + ps_Padding; //add lots of padding for use
        ypos = _pby - sheight/2;
        sposMin = xpos;
        sposMax = xpos + swidth - sheight/2;
        //update the position of the playback indicator us
        //newspos = updatePos();

        pbsb_cp5.setGraphics(ourApplet, 0, 0);

        skipToStartButton.setPosition(
            PApplet.parseInt(_pbx) + PApplet.parseInt(skipToStart_diameter*.5f),
            PApplet.parseInt(_pby) - PApplet.parseInt(skipToStart_diameter*.5f)
            );
    }

    //This function scrubs to the beginning of the playback file
    //Useful to 'reset' the scrollbar before loading a new playback file
    public void skipToStartButtonAction() {       
        fileBoard.goToIndex(0);
    }
    
};//end PlaybackScrollbar class

//========================== TimeDisplay ==========================
class TimeDisplay {
    int swidth, sheight;    // width and height of bar
    float xpos, ypos;       // x and y position of bar
    String currentAbsoluteTimeToDisplay = "";
    Boolean updatePosition = false;
    LocalDateTime time;

    TimeDisplay (float xp, float yp, int sw, int sh) {
        swidth = sw;
        sheight = sh;
        xpos = xp; //lots of padding to make room for button
        ypos = yp;
        currentAbsoluteTimeToDisplay = fetchCurrentTimeString();
    }

    /////////////// Update loop for TimeDisplay when data stream is running
    public void update() {
        if (currentBoard.isStreaming()) {
            //Fetch Local time
            try {
                currentAbsoluteTimeToDisplay = fetchCurrentTimeString();
            } catch (NullPointerException e) {
                println("TimeDisplay: Timestamp error...");
                e.printStackTrace();
            }

        }
    } //end update loop for TimeDisplay

    public void draw() {
        pushStyle();
        //draw current timestamp at the bottom of the Widget container
        if (!currentAbsoluteTimeToDisplay.equals(null)) {
            int fontSize = 17;
            textFont(p2, fontSize);
            fill(OPENBCI_DARKBLUE);
            float tw = textWidth(currentAbsoluteTimeToDisplay);
            text(currentAbsoluteTimeToDisplay, xpos + swidth - tw, ypos);
            text(streamTimeElapsed.toString(), xpos + 10, ypos);
        }
        popStyle();
    }

    public void screenResized(float _x, float _y, float _w, float _h) {
        swidth = PApplet.parseInt(_w);
        sheight = PApplet.parseInt(_h);
        xpos = _x;
        ypos = _y;
    }

    public String fetchCurrentTimeString() {
        time = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss");
        return time.format(formatter);
    }
};//end TimeDisplay class
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    Widget
//      the idea here is that the widget class takes care of all of the responsiveness/structural stuff in the bg so that it is very easy to create a new custom widget to add to the GUI
//      the "Widgets" will be able to be mapped to the various containers of the GUI
//      created by Conor Russomanno ... 11/17/2016
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Used for Widget Dropdown Enums
interface IndexingInterface {
    public int getIndex();
    public String getString();
}

class Widget{

    protected PApplet pApplet;

    protected int x0, y0, w0, h0; //true x,y,w,h of container
    protected int x, y, w, h; //adjusted x,y,w,h of white space `blank rectangle` under the nav...

    private int currentContainer; //this determines where the widget is located ... based on the x/y/w/h of the parent container

    protected boolean dropdownIsActive = false;
    private boolean previousDropdownIsActive = false;
    private boolean previousTopNavDropdownMenuIsOpen = false;
    private boolean widgetSelectorIsActive = false;

    private ArrayList<NavBarDropdown> dropdowns;
    protected ControlP5 cp5_widget;
    protected String widgetTitle = "No Title Set";
    //used to limit the size of the widget selector, forces a scroll bar to show and allows us to add even more widgets in the future
    private final float widgetDropdownScaling = .90f;
    private boolean isWidgetActive = false;

    //some variables for the dropdowns
    protected final int navH = 22;
    private int widgetSelectorWidth = 160;
    private int widgetSelectorHeight = 0;
    protected int dropdownWidth = 64;
    private boolean initialResize = false; //used to properly resize the widgetSelector when loading default settings

    Widget(PApplet _parent){
        pApplet = _parent;
        cp5_widget = new ControlP5(pApplet);
        cp5_widget.setAutoDraw(false); //this prevents the cp5 object from drawing automatically (if it is set to true it will be drawn last, on top of all other GUI stuff... not good)
        dropdowns = new ArrayList<NavBarDropdown>();
        //setup dropdown menus

        currentContainer = 5; //central container by default
        mapToCurrentContainer();

    }

    public boolean getIsActive() {
        return isWidgetActive;
    }

    public void setIsActive(boolean isActive) {
        isWidgetActive = isActive;
        //mapToCurrentContainer();
    }

    public void update(){
        updateDropdowns();
    }

    public void draw(){
        pushStyle();
        noStroke();
        fill(255);
        rect(x,y-1,w,h+1); //draw white widget background
        popStyle();

        //draw nav bars and button bars
        pushStyle();
        fill(150, 150, 150);
        rect(x0, y0, w0, navH); //top bar
        fill(200, 200, 200);
        rect(x0, y0+navH, w0, navH); //button bar
        popStyle();
    }

    public void addDropdown(String _id, String _title, List _items, int _defaultItem){
        NavBarDropdown dropdownToAdd = new NavBarDropdown(_id, _title, _items, _defaultItem);
        dropdowns.add(dropdownToAdd);
    }

    public void setupWidgetSelectorDropdown(ArrayList<String> _widgetOptions){
        cp5_widget.setColor(settings.dropdownColors);
        ScrollableList scrollList = cp5_widget.addScrollableList("WidgetSelector")
            .setPosition(x0+2, y0+2) //upper left corner
            // .setFont(h2)
            .setOpen(false)
            .setColor(settings.dropdownColors)
            .setOutlineColor(OBJECT_BORDER_GREY)
            //.setSize(widgetSelectorWidth, int(h0 * widgetDropdownScaling) )// + maxFreqList.size())
            //.setSize(widgetSelectorWidth, (NUM_WIDGETS_TO_SHOW+1)*(navH-4) )// + maxFreqList.size())
            // .setScrollSensitivity(0.0)
            .setBarHeight(navH-4) //height of top/primary bar
            .setItemHeight(navH-4) //height of all item/dropdown bars
            .addItems(_widgetOptions) // used to be .addItems(maxFreqList)
            ;
        
        scrollList.getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(widgetTitle)
            .setFont(h4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        
        scrollList.getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(widgetTitle)
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;        
    }

    public void setupNavDropdowns(){
        cp5_widget.setColor(settings.dropdownColors);
        // println("Setting up dropdowns...");
        for(int i = 0; i < dropdowns.size(); i++){
            int dropdownPos = dropdowns.size() - i;
            // println("dropdowns.get(i).id = " + dropdowns.get(i).id);
            ScrollableList scrollList = cp5_widget.addScrollableList(dropdowns.get(i).id)
                .setPosition(x0+w0-(dropdownWidth*(dropdownPos))-(2*(dropdownPos)), y0 + navH + 2) //float right
                .setFont(h5)
                .setOpen(false)
                .setColor(settings.dropdownColors)
                .setOutlineColor(OBJECT_BORDER_GREY)
                .setSize(dropdownWidth, (dropdowns.get(i).items.size()+1)*(navH-4) )// + maxFreqList.size())
                .setBarHeight(navH-4)
                .setItemHeight(navH-4)
                .addItems(dropdowns.get(i).items) // used to be .addItems(maxFreqList)
                ;
                
            scrollList.getCaptionLabel()
                .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
                .setText(dropdowns.get(i).returnDefaultAsString())
                .setSize(12)
                .getStyle()
                .setPaddingTop(4)
                ;

            scrollList.getValueLabel() //the value label is connected to the text objects in the dropdown item bars
                .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
                .setText(widgetTitle)
                .setSize(12) //set the font size of the item bars to 14pt
                .getStyle() //need to grab style before affecting the paddingTop
                .setPaddingTop(3) //4-pixel vertical offset to center text
                ;
        }
    }
    private void updateDropdowns(){
        //if a dropdown is open and mouseX/mouseY is outside of dropdown, then close it
        // println("dropdowns.size() = " + dropdowns.size());
        dropdownIsActive = false;

        if (!initialResize) {
            resizeWidgetSelector(); //do this once after instantiation to fix grey background drawing error
            initialResize = true;
        }

        //auto close dropdowns based on mouse location
        if(cp5_widget.get(ScrollableList.class, "WidgetSelector").isOpen()){
            dropdownIsActive = true;

        }
        for(int i = 0; i < dropdowns.size(); i++){
            if(cp5_widget.get(ScrollableList.class, dropdowns.get(i).id).isOpen()){
                //println("++++++++Mouse is over " + dropdowns.get(i).id);
                dropdownIsActive = true;
            }
        }

        //make sure that the widgetSelector CaptionLabel always corresponds to its widget
        cp5_widget.getController("WidgetSelector")
            .getCaptionLabel()
            .setText(widgetTitle)
            ;

    }

    private void drawDropdowns(){
        cp5_widget.draw(); //this draws all cp5 elements... in this case, the scrollable lists that populate our dropdowns<>

        //draw dropdown titles		
        pushStyle();		
        noStroke();		
        textFont(h5);		
        textSize(12);		
        textAlign(CENTER, BOTTOM);		
        fill(OPENBCI_DARKBLUE);		
        for(int i = 0; i < dropdowns.size(); i++){		
            int dropdownPos = dropdowns.size() - i;
            int _width = cp5_widget.getController(dropdowns.get(i).id).getWidth();
            int _x = PApplet.parseInt(cp5_widget.getController(dropdowns.get(i).id).getPosition()[0]);	
            text(dropdowns.get(i).title, _x+_width/2, y0+(navH-2));	
        }
        popStyle();
    }

    public void mouseDragged(){
    }

    public void mousePressed(){
    }

    public void mouseReleased(){
    }

    public void screenResized(){
        mapToCurrentContainer();
    }

    public void setTitle(String _widgetTitle){
        widgetTitle = _widgetTitle;
    }

    public void setContainer(int _currentContainer){
        currentContainer = _currentContainer;
        mapToCurrentContainer();
        screenResized();

    }

    private void resizeWidgetSelector() {
        int dropdownsItemsToShow = PApplet.parseInt((h0 * widgetDropdownScaling) / (navH - 4));
        widgetSelectorHeight = (dropdownsItemsToShow + 1) * (navH - 4);
        if (wm != null) {
            int maxDropdownHeight = (wm.widgetOptions.size() + 1) * (navH - 4);
            if (widgetSelectorHeight > maxDropdownHeight) widgetSelectorHeight = maxDropdownHeight;
        }

        cp5_widget.getController("WidgetSelector")
            .setPosition(x0+2, y0+2) //upper left corner
            ;
        cp5_widget.getController("WidgetSelector")
            .setSize(widgetSelectorWidth, widgetSelectorHeight);
            ;
    }

    private void mapToCurrentContainer(){
        x0 = (int)container[currentContainer].x;
        y0 = (int)container[currentContainer].y;
        w0 = (int)container[currentContainer].w;
        h0 = (int)container[currentContainer].h;

        x = x0;
        y = y0 + navH*2;
        w = w0;
        h = h0 - navH*2;

        //This line resets the origin for all cp5 elements under "cp5_widget" when the screen is resized, otherwise there will be drawing errors
        cp5_widget.setGraphics(pApplet, 0, 0);

        if (cp5_widget.getController("WidgetSelector") != null) {
            resizeWidgetSelector();
        }

        //Other dropdowns
        for(int i = 0; i < dropdowns.size(); i++){
            int dropdownPos = dropdowns.size() - i;
            cp5_widget.getController(dropdowns.get(i).id)
                //.setPosition(w-(dropdownWidth*dropdownPos)-(2*(dropdownPos+1)), navHeight+(y+2)) // float left
                .setPosition(x0+w0-(dropdownWidth*(dropdownPos))-(2*(dropdownPos)), navH +(y0+2)) //float right
                //.setSize(dropdownWidth, (maxFreqList.size()+1)*(navBarHeight-4))
                ;
        }
    }

    public boolean isMouseHere(){
        if(getIsActive()){
            if(mouseX >= x0 && mouseX <= x0 + w0 && mouseY >= y0 && mouseY <= y0 + h0){
                println("Your cursor is in " + widgetTitle);
                return true;
            } else{
                return false;
            }
        } else {
            return false;
        }
    }

    //For use with multiple Cp5 controllers per class/widget. Can only be called once per widget during update loop.
    protected void lockElementsOnOverlapCheck(List<controlP5.Controller> listOfControllers) {
        //Check against TopNav Menus
        if (topNav.getDropdownMenuIsOpen() != previousTopNavDropdownMenuIsOpen) {
            for (controlP5.Controller c : listOfControllers) {
                if (c == null) {
                    continue; //Gracefully skip over a controller if it is null
                }
                //println(widgetTitle, " ", c.getName(), " lock because of topnav == ", topNav.getDropdownMenuIsOpen());
                c.setLock(topNav.getDropdownMenuIsOpen());
            }
            previousTopNavDropdownMenuIsOpen = topNav.getDropdownMenuIsOpen();
            if (previousTopNavDropdownMenuIsOpen) {
                return;
            }
        }
        //Check against Widget Dropdowns
        if (dropdownIsActive != previousDropdownIsActive) {
            for (controlP5.Controller c : listOfControllers) {
                if (c == null) {
                    continue; //Gracefully skip over a controller if it is null
                }
                //println(widgetTitle, " ", c.getName(), " lock because of widget navbar dropdown == ", dropdownIsActive);
                c.setLock(dropdownIsActive);
            } 
            previousDropdownIsActive = dropdownIsActive;
        }
    }
}; //end of base Widget class

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    NavBarDropdown is a single dropdown item in any instance of a Widget
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class NavBarDropdown{

    String id;
    String title;
    // String[] items;
    List<String> items;
    int defaultItem;

    NavBarDropdown(String _id, String _title, List _items, int _defaultItem){
        id = _id;
        title = _title;
        // int dropdownSize = _items.length;
        // items = new String[_items.length];
        items = _items;

        defaultItem = _defaultItem;
    }

    public void update(){
    }

    public void draw(){
    }

    public void screenResized(){
    }

    public void mousePressed(){
    }

    public void mouseReleased(){
    }

    public String returnDefaultAsString(){
        String _defaultItem = items.get(defaultItem);
        return _defaultItem;
    }

}

public void WidgetSelector(int n){
    println("New widget [" + n + "] selected for container...");
    //find out if the widget you selected is already active
    boolean isSelectedWidgetActive = wm.widgets.get(n).getIsActive();

    //find out which widget & container you are currently in...
    int theContainer = -1;
    for(int i = 0; i < wm.widgets.size(); i++){
        if(wm.widgets.get(i).isMouseHere()){
            theContainer = wm.widgets.get(i).currentContainer; //keep track of current container (where mouse is...)
            if(isSelectedWidgetActive){ //if the selected widget was already active
                wm.widgets.get(i).setContainer(wm.widgets.get(n).currentContainer); //just switch the widget locations (ie swap containers)
            } else{
                wm.widgets.get(i).setIsActive(false);   //deactivate the current widget (if it is different than the one selected)
            }
        }
    }

    wm.widgets.get(n).setIsActive(true);//activate the new widget
    wm.widgets.get(n).setContainer(theContainer);//map it to the current container
}

// This is a helpful class that will add a channel select feature to a Widget
class ChannelSelect {
    protected Widget widget;
    private List<controlP5.Controller> cp5ElementsToCheck = new ArrayList<controlP5.Controller>();
    protected int x, y, w, h, navH, butToggleY;
    public float tri_xpos = 0;
    protected float chanSelectXPos = 0;
    protected final int button_spacer = 10;
    public ControlP5 cp5_chanSelect;   //ControlP5 to contain our checkboxes
    protected List<Toggle> channelButtons;
    protected int offset;  //offset on nav bar of checkboxes
    protected int buttonW;
    protected int buttonH;
    protected boolean channelSelectHover;
    protected boolean isVisible;
    public List<Integer> activeChan;
    public String chanDropdownName;
    protected boolean isFirstRowChannelSelect = true;
    protected boolean isDualChannelSelect = false;

    private int labelWidth = 0;
    private int labelSpacer = 0;
    private String firstRowLabel = "Top";
    private String secondRowLabel = "Bot";

    ChannelSelect(PApplet _parent, Widget _widget, int _x, int _y, int _w, int _navH, String checkBoxName) {
        widget = _widget;
        x = _x;
        y = _y;
        w = _w;
        h = _navH;
        navH = _navH;
        activeChan = new ArrayList<Integer>();
        chanDropdownName = checkBoxName;

        //setup for checkboxes
        cp5_chanSelect = new ControlP5(_parent);
        cp5_chanSelect.setGraphics(_parent, 0, 0);
        cp5_chanSelect.setAutoDraw(false); //draw only when specified
        createButtons(nchan);
    }

    public void update(int _x, int _y, int _w) {
        //update the x,y,w for this class using the parent class
        x = _x;
        y = _y;
        w = _w;
        //Toggle open/closed the channel menu
        if (mouseX > (chanSelectXPos) && mouseX < (tri_xpos + 10) && mouseY < (y - navH*0.25f) && mouseY > (y - navH*0.65f)) {
            channelSelectHover = true;
        } else {
            channelSelectHover = false;
        }
        //Update position of buttons on every update and check for UI overlap
        for (int i = 0; i < nchan; i++) {
            channelButtons.get(i).setPosition(x + labelWidth + labelSpacer + (button_spacer*(i+1)) + (buttonW*i), y + offset);
        }
    }

    public void draw() {
        chanSelectXPos = x + 2;
        pushStyle();
        noStroke();
        if (isFirstRowChannelSelect) {
            //change "Channels" text color and triangle color on hover
            if (channelSelectHover) {
                fill(OPENBCI_BLUE);
            } else {
                fill(OPENBCI_DARKBLUE);
            }
            textFont(p5, 12);
            
            text("Channels", chanSelectXPos, y - 6);
            tri_xpos = x + textWidth("Channels") + 7;

            //draw triangle as pointing up or down, depending on if channel Select is active or closed
            if (!isVisible) {
                triangle(tri_xpos, y - 7, tri_xpos + 6, y - 13, tri_xpos + 12, y - 7);
            } else {
                triangle(tri_xpos, y - 13, tri_xpos + 6, y - 7, tri_xpos + 12, y - 13);
                //if active, draw a grey background for the channel select checkboxes
                fill(200);
                rect(x,y,w,navH);
            }
        } else { //This is the case in Spectrogram where we need a second channel selector
            //this draws extra grey space behind the checklist buttons
            if (isVisible) {
                fill(200);
                rect(x,y,w,navH);
            }
        }
        popStyle();

        if (isVisible) {
            //Draw channel select buttons
            cp5_chanSelect.draw();
            //Draw a border around toggle buttons to indicate if channel is on or off
            pushStyle();
            int weight = 1;
            strokeWeight(weight);
            noFill();
            for (int i = 0; i < nchan; i++) {
                int c = currentBoard.isEXGChannelActive(i) ? color(0,255,0,255) : color(255,0,0,255);
                stroke(c);
                rect(x + labelWidth + labelSpacer + (button_spacer*(i+1)) + (buttonW*i) - weight, y + offset - weight, channelButtons.get(i).getWidth() + weight, channelButtons.get(i).getHeight() + weight);
            }
            popStyle();
            //Draw label 
            if (isDualChannelSelect) {
                pushStyle();
                fill(0);
                textFont(p5, 12);
                textAlign(CENTER, TOP);
                String label = isFirstRowChannelSelect ? firstRowLabel : secondRowLabel;
                text(label, x + labelSpacer + labelWidth/2, y + offset);
                popStyle();
            }
        }
    }

    public void screenResized(PApplet _parent) {
        cp5_chanSelect.setGraphics(_parent, 0, 0);
    }

    public void mousePressed(boolean dropdownIsActive) {
        if (!dropdownIsActive) {
            if (mouseX > (chanSelectXPos) && mouseX < (tri_xpos + 10) && mouseY < (y - navH*0.25f) && mouseY > (y - navH*0.65f)) {
                isVisible = !isVisible;
            }
        }
    }

    private void createButtons(int _nchan) {
        channelButtons = new ArrayList<Toggle>();
        
        int checkSize = navH - 6;
        offset = (navH - checkSize)/2;

        channelSelectHover = false;
        isVisible = false;

        buttonW = checkSize;
        buttonH = buttonW;

        for (int i = 0; i < _nchan; i++) {
            //start all items as invisible until user clicks dropdown to show checkboxes
            channelButtons.add(
                createButton("ch"+(i+1), (i+1), true, x + (button_spacer*(i+2)) + (buttonW*i), y + offset, buttonW, buttonH)
            );
            cp5ElementsToCheck.add((controlP5.Controller)channelButtons.get(i));
        }
    }

    private Toggle createButton(String name, int chan, boolean _isVisible, int _x, int _y, int _w, int _h) {
        int _fontSize = 12;
        int marginLeftOffset = chan > 9 ? -9 : -6;
        Toggle myButton = cp5_chanSelect.addToggle(name)
            .setPosition(_x, _y)
            .setSize(_w, _h)
            .setColorLabel(OPENBCI_DARKBLUE)
            .setColorForeground(color(120))
            .setColorBackground(color(150))
            .setColorActive(color(57, 128, 204))
            .setVisible(_isVisible)
            ;
        myButton
            .getCaptionLabel()
            .setFont(createFont("Arial", _fontSize, true))
            .toUpperCase(false)
            .setSize(_fontSize)
            .setText(String.valueOf(chan))
            .getStyle() //need to grab style before affecting margin and padding
            .setMargin(-_h - 3, 0, 0, marginLeftOffset)
            .setPaddingLeft(10)
            ;
        myButton.onPress(new CallbackListener() {
            public void controlEvent(CallbackEvent theEvent) {
                int chan = Integer.parseInt(((Toggle)theEvent.getController()).getCaptionLabel().getText()) - 1;  
                boolean b = ((Toggle)theEvent.getController()).getBooleanValue();
                setToggleState(chan, b);
                //println(widget + " || " + activeChan);
            }
        });
        return myButton;
    }

    public void setIsFirstRowChannelSelect(boolean b) {
        isFirstRowChannelSelect = b;
    }

    public void setIsDualChannelSelect(boolean b) {
        isDualChannelSelect = b;
        if (isDualChannelSelect) {
            labelWidth = 28;
            labelSpacer = 4;
        }
    }

    public List<controlP5.Controller> getCp5ElementsForOverlapCheck() {
        return cp5ElementsToCheck;
    }

    public void setFirstRowLabel(String s) {
        firstRowLabel = s;
    }

    public void setSecondRowLabel(String s) {
        secondRowLabel = s;
    }

    public boolean isVisible() {
        return isVisible;
    }

    public void setIsVisible(boolean b) {
        isVisible = b;
    }

    public void deactivateAllButtons() {
        for (int i = 0; i < nchan; i++) {
            channelButtons.get(i).setState(false);
        }
        activeChan.clear();
    }

    public void activateAllButtons() {
        for (int i = 0; i < nchan; i++) {
            channelButtons.get(i).setState(true);
            activeChan.add(i);
        }
        Collections.sort(activeChan);
    }

    public void setToggleState(Integer chan, boolean b) {
        channelButtons.get(chan).setState(b);
        if (b && !activeChan.contains(chan)) {
            activeChan.add(chan);
        } else if (!b && activeChan.contains(chan)) {
            activeChan.remove(chan);
        }
        Collections.sort(activeChan);
        //println(activeChan.toArray());
    }
    
    public int getHeight() {
        return h;
    }

} //end of ChannelSelect class
//========================================================================================
//=================              ADD NEW WIDGETS HERE            =========================
//========================================================================================
/*
    Notes:
    - In this file all you have to do is MAKE YOUR WIDGET GLOBALLY, and then ADD YOUR WIDGET TO WIDGETS OF WIDGETMANAGER in the setupWidgets() function below
    - the order in which they are added will effect the order in which they appear in the GUI and in the WidgetSelector dropdown menu of each widget
    - use the WidgetTemplate.pde file as a starting point for creating new widgets (also check out W_timeSeries.pde, W_fft.pde, and W_HeadPlot.pde)
*/

// MAKE YOUR WIDGET GLOBALLY
W_timeSeries w_timeSeries;
W_fft w_fft;
W_Networking w_networking;
W_BandPower w_bandPower;
W_Accelerometer w_accelerometer;
W_CytonImpedance w_cytonImpedance;
W_GanglionImpedance w_ganglionImpedance;
W_HeadPlot w_headPlot;
W_template w_template1;
W_emg w_emg;
W_PulseSensor w_pulsesensor;
W_AnalogRead w_analogRead;
W_DigitalRead w_digitalRead;
W_playback w_playback;
W_Spectrogram w_spectrogram;
W_PacketLoss w_packetLoss;
W_Focus w_focus;
W_EMGJoystick w_emgJoystick;
W_EEGMapping w_eegMapping;

//ADD YOUR WIDGET TO WIDGETS OF WIDGETMANAGER
public void setupWidgets(PApplet _this, ArrayList<Widget> w){
    // println("  setupWidgets start -- " + millis());

    //Widget_0 -- The Widget number helps when debugging GUI front-end
    w_timeSeries = new W_timeSeries(_this);
    w_timeSeries.setTitle("Time Series");
    addWidget(w_timeSeries, w);
    // println("  setupWidgets time series -- " + millis());

    //Widget_1
    w_fft = new W_fft(_this);
    w_fft.setTitle("FFT Plot");
    addWidget(w_fft, w);
    // println("  setupWidgets fft -- " + millis());

    if (currentBoard instanceof AccelerometerCapableBoard) {
        w_accelerometer = new W_Accelerometer(_this);
        w_accelerometer.setTitle("Accelerometer");
        addWidget(w_accelerometer, w);
    }

    if (currentBoard instanceof BoardCyton) {
        w_cytonImpedance = new W_CytonImpedance(_this);
        w_cytonImpedance.setTitle("Cyton Signal");
        addWidget(w_cytonImpedance, w);
    }

    if(currentBoard instanceof DataSourcePlayback){
        //Playback Widget_3
        w_playback = new W_playback(_this);
        w_playback.setTitle("Playback History");
        addWidget(w_playback, w);
    }

    //only instantiate this widget if you are using a Ganglion board for live streaming
    if(nchan == 4 && currentBoard instanceof BoardGanglion){
        //If using Ganglion, this is Widget_3
        w_ganglionImpedance = new W_GanglionImpedance(_this);
        w_ganglionImpedance.setTitle("Ganglion Signal");
        addWidget(w_ganglionImpedance, w);
    }

    //Cyton Widget_12, Synthetic Widget_9, Ganglion/Playback Widget_10
    w_focus = new W_Focus(_this);
    w_focus.setTitle("Focus Widget");
    addWidget(w_focus, w);
    // println("  setupWidgets focus widget -- " + millis());

    //Cyton/Synthetic Widget_3, Ganglion/Playback Widget_4
    w_networking = new W_Networking(_this);
    w_networking.setTitle("Networking");
    addWidget(w_networking, w);
    
    w_eegMapping = new W_EEGMapping(_this);
    w_eegMapping.setTitle("EEG Mapping");
    addWidget(w_eegMapping, w);

    //Cyton/Synthetic Widget_4, Ganglion/Playback Widget_5
    w_bandPower = new W_BandPower(_this);
    w_bandPower.setTitle("Band Power");
    addWidget(w_bandPower, w);
    // println("  setupWidgets band power -- " + millis());

    //Cyton/Synthetic Widget_5, Ganglion/Playback Widget_6
    w_headPlot = new W_HeadPlot(_this);
    w_headPlot.setTitle("Head Plot");
    addWidget(w_headPlot, w);
    // println("  setupWidgets head plot -- " + millis());

    //Cyton/Synthetic Widget_6, Ganglion/Playback Widget_7
    w_emg = new W_emg(_this);
    w_emg.setTitle("EMG");
    addWidget(w_emg, w);
    // println("  setupWidgets emg -- " + millis());
 
    w_emgJoystick = new W_EMGJoystick(_this);
    w_emgJoystick.setTitle("EMG Joystick");
    addWidget(w_emgJoystick, w);

    //Cyton/Synthetic Widget_7, Ganglion/Playback Widget_8
    w_spectrogram = new W_Spectrogram(_this);
    w_spectrogram.setTitle("Spectrogram");
    addWidget(w_spectrogram, w);

    //only instantiate these widgets if you are using a Cyton board for live streaming
    if(currentBoard instanceof AnalogCapableBoard){
        //Cyton Widget_8
        w_pulsesensor = new W_PulseSensor(_this);
        w_pulsesensor.setTitle("Pulse Sensor");
        addWidget(w_pulsesensor, w);
        // println("  setupWidgets pulse sensor -- " + millis());
    }

    if(currentBoard instanceof DigitalCapableBoard) {
        //Cyton Widget_9
        w_digitalRead = new W_DigitalRead(_this);
        w_digitalRead.setTitle("Digital Read");
        addWidget(w_digitalRead, w);
    }
    
    if(currentBoard instanceof AnalogCapableBoard) {
        //Cyton Widget_10
        w_analogRead = new W_AnalogRead(_this);
        w_analogRead.setTitle("Analog Read");
        addWidget(w_analogRead, w);
    }

    if (currentBoard instanceof Board) {
        w_packetLoss = new W_PacketLoss(_this);
        w_packetLoss.setTitle("Packet Loss");
        addWidget(w_packetLoss, w);
    }
    
    //Cyton Widget_11, Synthetic Widget_8, Ganglion/Playback Widget_9
    //DEVELOPERS: Here is an example widget with the essentials/structure in place
    w_template1 = new W_template(_this);
    w_template1.setTitle("Widget Template 1");
    addWidget(w_template1, w);

    


}

//========================================================================================
//========================================================================================
//========================================================================================

class WidgetManager{

    //this holds all of the widgets ... when creating/adding new widgets, we will add them to this ArrayList (below)
    ArrayList<Widget> widgets;
    ArrayList<String> widgetOptions; //List of Widget Titles, used to populate cp5 widgetSelector dropdown of all widgets

    //Variables for
    int currentContainerLayout; //this is the Layout structure for the main body of the GUI ... refer to [PUT_LINK_HERE] for layouts/numbers image
    ArrayList<Layout> layouts = new ArrayList<Layout>();  //this holds all of the different layouts ...

    public boolean isWMInitialized = false;
    private boolean visible = true;

    WidgetManager(PApplet _this){
        widgets = new ArrayList<Widget>();
        widgetOptions = new ArrayList<String>();
        isWMInitialized = false;

        //DO NOT re-order the functions below
        setupLayouts();
        setupWidgets(_this, widgets);
        setupWidgetSelectorDropdowns();

        if(nchan == 4 && eegDataSource == DATASOURCE_GANGLION) {
            currentContainerLayout = 1;
            settings.currentLayout = 1; // used for save/load settings
            setNewContainerLayout(currentContainerLayout); //sets and fills layout with widgets in order of widget index, to reorganize widget index, reorder the creation in setupWidgets()
        } else if (eegDataSource == DATASOURCE_PLAYBACKFILE) {
            currentContainerLayout = 1;
            settings.currentLayout = 1; // used for save/load settings
            setNewContainerLayout(currentContainerLayout); //sets and fills layout with widgets in order of widget index, to reorganize widget index, reorder the creation in setupWidgets()
        } else {
            currentContainerLayout = 4; //default layout ... tall container left and 2 shorter containers stacked on the right
            settings.currentLayout = 4; // used for save/load settings
            setNewContainerLayout(currentContainerLayout); //sets and fills layout with widgets in order of widget index, to reorganize widget index, reorder the creation in setupWidgets()
        }

        isWMInitialized = true;
    }
    public boolean isVisible() {
        return visible;
    }

    public void setVisible(boolean _visible) {
        visible = _visible;
    }

    public void setupWidgetSelectorDropdowns(){
        //create the widgetSelector dropdown of each widget
        //println("widgets.size() = " + widgets.size());
        //create list of WidgetTitles.. we will use this to populate the dropdown (widget selector) of each widget
        for(int i = 0; i < widgets.size(); i++){
            widgetOptions.add(widgets.get(i).widgetTitle);
        }
        //println("widgetOptions.size() = " + widgetOptions.size());
        for(int i = 0; i <widgetOptions.size(); i++){
            widgets.get(i).setupWidgetSelectorDropdown(widgetOptions);
            widgets.get(i).setupNavDropdowns();
        }
    }

    public void update(){
        // if(visible && updating){
        if(visible){
            for(int i = 0; i < widgets.size(); i++){
                if(widgets.get(i).getIsActive()){
                    widgets.get(i).update();
                    //if the widgets are not mapped to containers correctly, remap them..
                    // if(widgets.get(i).x != container[widgets.get(i).currentContainer].x || widgets.get(i).y != container[widgets.get(i).currentContainer].y || widgets.get(i).w != container[widgets.get(i).currentContainer].w || widgets.get(i).h != container[widgets.get(i).currentContainer].h){
                    if(widgets.get(i).x0 != (int)container[widgets.get(i).currentContainer].x || widgets.get(i).y0 != (int)container[widgets.get(i).currentContainer].y || widgets.get(i).w0 != (int)container[widgets.get(i).currentContainer].w || widgets.get(i).h0 != (int)container[widgets.get(i).currentContainer].h){
                        screenResized();
                        println("WidgetManager.pde: Remapping widgets to container layout...");
                    }
                }
            }
        }
    }

    public void draw(){
        if(visible){
            for(int i = 0; i < widgets.size(); i++){
                if(widgets.get(i).getIsActive()){
                    widgets.get(i).draw();
                    widgets.get(i).drawDropdowns();
                }else{
                    if(widgets.get(i).widgetTitle.equals("Networking")){
                        try{
                            w_networking.shutDown();
                        }catch (NullPointerException e){
                            println("WM:Networking_shutDown_Error: " + e);
                        }
                    }
                }
            }
        }
    }

    public void screenResized(){
        for(int i = 0; i < widgets.size(); i++){
            widgets.get(i).screenResized();
        }
    }

    public void mousePressed(){
        for(int i = 0; i < widgets.size(); i++){
            if(widgets.get(i).getIsActive()){
                widgets.get(i).mousePressed();
            }

        }
    }

    public void mouseReleased(){
        for(int i = 0; i < widgets.size(); i++){
            if(widgets.get(i).getIsActive()){
                widgets.get(i).mouseReleased();
            }
        }
    }

    public void mouseDragged(){
        for(int i = 0; i < widgets.size(); i++){
            if(widgets.get(i).getIsActive()){
                widgets.get(i).mouseDragged();
            }
        }
    }

    public void setupLayouts(){
        //refer to [PUT_LINK_HERE] for layouts/numbers image
        //note that the order you create/add these layouts matters... if you reorganize these, the LayoutSelector will be out of order
        layouts.add(new Layout(new int[]{5})); //layout 1
        layouts.add(new Layout(new int[]{1,3,7,9})); //layout 2
        layouts.add(new Layout(new int[]{4,6})); //layout 3
        layouts.add(new Layout(new int[]{2,8})); //etc.
        layouts.add(new Layout(new int[]{4,3,9}));
        layouts.add(new Layout(new int[]{1,7,6}));
        layouts.add(new Layout(new int[]{1,3,8}));
        layouts.add(new Layout(new int[]{2,7,9}));
        layouts.add(new Layout(new int[]{4,11,12,13,14}));
        layouts.add(new Layout(new int[]{4,15,16,17,18}));
        layouts.add(new Layout(new int[]{1,7,11,12,13,14}));
        layouts.add(new Layout(new int[]{1,7,15,16,17,18}));
    }

    public void printLayouts(){
        for(int i = 0; i < layouts.size(); i++){
            println("WM:printLayouts: " + layouts.get(i));
            String layoutString = "";
            for(int j = 0; j < layouts.get(i).myContainers.length; j++){
                // println("WM:layoutContainers: " + layouts.get(i).myContainers[j]);
                layoutString += layouts.get(i).myContainers[j].x + ", ";
                layoutString += layouts.get(i).myContainers[j].y + ", ";
                layoutString += layouts.get(i).myContainers[j].w + ", ";
                layoutString += layouts.get(i).myContainers[j].h;
            }
            println("WM:printLayouts: " + layoutString);
        }
    }

    public void setNewContainerLayout(int _newLayout){

        //find out how many active widgets we need...
        int numActiveWidgetsNeeded = layouts.get(_newLayout).myContainers.length;
        //calculate the number of current active widgets & keep track of which widgets are active
        int numActiveWidgets = 0;
        // ArrayList<int> activeWidgets = new ArrayList<int>();
        for(int i = 0; i < widgets.size(); i++){
            if(widgets.get(i).getIsActive()){
                numActiveWidgets++; //increment numActiveWidgets
                // activeWidgets.add(i); //keep track of the active widget
            }
        }

        if(numActiveWidgets > numActiveWidgetsNeeded){ //if there are more active widgets than needed
            //shut some down
            int numToShutDown = numActiveWidgets - numActiveWidgetsNeeded;
            int counter = 0;
            println("WM: Powering " + numToShutDown + " widgets down, and remapping.");
            for(int i = widgets.size()-1; i >= 0; i--){
                if(widgets.get(i).getIsActive() && counter < numToShutDown){
                    verbosePrint("WM: Deactivating widget [" + i + "]");
                    widgets.get(i).setIsActive(false);
                    counter++;
                }
            }

            //and map active widgets
            counter = 0;
            for(int i = 0; i < widgets.size(); i++){
                if(widgets.get(i).getIsActive()){
                    widgets.get(i).setContainer(layouts.get(_newLayout).containerInts[counter]);
                    counter++;
                }
            }

        } else if(numActiveWidgetsNeeded > numActiveWidgets){ //if there are less active widgets than needed
            //power some up
            int numToPowerUp = numActiveWidgetsNeeded - numActiveWidgets;
            int counter = 0;
            verbosePrint("WM: Powering " + numToPowerUp + " widgets up, and remapping.");
            for(int i = 0; i < widgets.size(); i++){
                if(!widgets.get(i).getIsActive() && counter < numToPowerUp){
                    verbosePrint("WM: Activating widget [" + i + "]");
                    widgets.get(i).setIsActive(true);
                    counter++;
                }
            }

            //and map active widgets
            counter = 0;
            for(int i = 0; i < widgets.size(); i++){
                if(widgets.get(i).getIsActive()){
                    widgets.get(i).setContainer(layouts.get(_newLayout).containerInts[counter]);
                    // widgets.get(i).screenResized(); // do this to make sure the container is updated
                    counter++;
                }
            }

        } else{ //if there are the same amount
            //simply remap active widgets
            verbosePrint("WM: Remapping widgets.");
            int counter = 0;
            for(int i = 0; i < widgets.size(); i++){
                if(widgets.get(i).getIsActive()){
                    widgets.get(i).setContainer(layouts.get(_newLayout).containerInts[counter]);
                    counter++;
                }
            }
        }
    }
};

//this is a global function for adding new widgets--and their children (timeSeries, FFT, headPlot, etc.)--to the WidgetManager's widget ArrayList
public void addWidget(Widget myNewWidget, ArrayList<Widget> w){
    w.add(myNewWidget);
}

//the Layout class is an orgnanizational tool ... a layout consists of a combination of containers ... refer to Container.pde
class Layout{

    Container[] myContainers;
    int[] containerInts;

    Layout(int[] _myContainers){ //when creating a new layout, you pass in the integer #s of the containers you want as part of the layout ... so if I pass in the array {5}, my layout is 1 container that takes up the whole GUI body
        //constructor stuff
        myContainers = new Container[_myContainers.length]; //make the myContainers array equal to the size of the incoming array of ints
        containerInts = new int[_myContainers.length];
        for(int i = 0; i < _myContainers.length; i++){
            myContainers[i] = container[_myContainers[i]];
            containerInts[i] = _myContainers[i];
        }
    }

    public Container getContainer(int _numContainer){
        if(_numContainer < myContainers.length){
            return myContainers[_numContainer];
        } else{
            println("WM: Tried to return a non-existant container...");
            return myContainers[myContainers.length-1];
        }
    }
};


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "OpenBCI_GUI" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
